<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Module :: \XPM.xpm_fifo_base </title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<link type="text/css" rel="stylesheet" href="css/.breadcrumb.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript" src="js/.breadcrumb.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  if ($("#north-bread-crumb")) {
    $("#north-bread-crumb").jBreadCrumb({easing:'swing'})
  }
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    },
    west: {
      size: 500,
      resizable: true,
      initClosed: false
    }
  });
  centerLayout = $('div.ui-layout-center').layout({
    north__paneSelector: ".ui-layout-center-inner-north",
    center__paneSelector: ".ui-layout-center-inner-center", 
    north__size: 50,
    spacing_open: 4,
    spacing_closed: 4
  });
});
</script>
</head>
<body onLoad="initPage();"><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Module Definition</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | asserts</div>

</div>
<div class="ui-layout-west">
<div name='tag_\XPM.xpm_fifo_base '>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module : <a href="#"  onclick="showContent('tag_\\XPM.xpm_fifo_base ')">\XPM.xpm_fifo_base </a></span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="s6 cl rt"> 66.10</td>
<td class="s6 cl rt"><a href="mod18.html#Line" > 60.56</a></td>
<td class="s6 cl rt"><a href="mod18.html#Cond" > 66.67</a></td>
<td class="s7 cl rt"><a href="mod18.html#Toggle" > 71.06</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<span class=repname>Source File(s) : </span>
<br clear=all>
<a href="javascript:void(0);"  onclick="openSrcFile('/opt/xilinx/Vivado/2021.2/data/ip/xpm/xpm_fifo/hdl/xpm_fifo.sv')">/opt/xilinx/Vivado/2021.2/data/ip/xpm/xpm_fifo/hdl/xpm_fifo.sv</a><br clear=all>
<br clear=all>
<span class=repname>Module self-instances :</span>
<br clear=all>
<table align=left class="sortable">
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod18.html#inst_tag_275"  onclick="showContent('inst_tag_275')">AdaptedSharpener.fifo.lineBuffer_4.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></td>
<td class="s6 cl rt"> 65.75</td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_275_Line" > 60.56</a></td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_275_Cond" > 66.67</a></td>
<td class="s7 cl rt"><a href="mod18.html#inst_tag_275_Toggle" > 70.02</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod18.html#inst_tag_274"  onclick="showContent('inst_tag_274')">AdaptedSharpener.fifo.lineBuffer_3.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></td>
<td class="s6 cl rt"> 65.79</td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_274_Line" > 60.56</a></td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_274_Cond" > 66.67</a></td>
<td class="s7 cl rt"><a href="mod18.html#inst_tag_274_Toggle" > 70.14</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod18.html#inst_tag_271"  onclick="showContent('inst_tag_271')">AdaptedSharpener.fifo.lineBuffer_0.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></td>
<td class="s6 cl rt"> 65.83</td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_271_Line" > 60.56</a></td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_271_Cond" > 66.67</a></td>
<td class="s7 cl rt"><a href="mod18.html#inst_tag_271_Toggle" > 70.25</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod18.html#inst_tag_273"  onclick="showContent('inst_tag_273')">AdaptedSharpener.fifo.lineBuffer_2.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></td>
<td class="s6 cl rt"> 65.83</td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_273_Line" > 60.56</a></td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_273_Cond" > 66.67</a></td>
<td class="s7 cl rt"><a href="mod18.html#inst_tag_273_Toggle" > 70.25</a></td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod18.html#inst_tag_272"  onclick="showContent('inst_tag_272')">AdaptedSharpener.fifo.lineBuffer_1.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></td>
<td class="s6 cl rt"> 65.98</td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_272_Line" > 60.56</a></td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_272_Cond" > 66.67</a></td>
<td class="s7 cl rt"><a href="mod18.html#inst_tag_272_Toggle" > 70.72</a></td>
<td class="wht cl rt"></td>
</tr></table></div>
</div>
<br clear=all>
<div name='inst_tag_275'>
<hr>
<a name="inst_tag_275"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_275" >AdaptedSharpener.fifo.lineBuffer_4.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="s6 cl rt"> 65.75</td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_275_Line" > 60.56</a></td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_275_Cond" > 66.67</a></td>
<td class="s7 cl rt"><a href="mod18.html#inst_tag_275_Toggle" > 70.02</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="s4 cl rt"> 47.93</td>
<td class="s4 cl rt"> 43.81</td>
<td class="s3 cl rt"> 37.04</td>
<td class="s6 cl rt"> 62.95</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s6 cl rt"> 68.58</td>
<td class="s5 cl rt"> 55.56</td>
<td class="wht cl rt"></td>
<td class="s8 cl rt"> 81.61</td>
<td class="wht cl rt"></td>
<td><a href="mod1.html#inst_tag_11" >xpm_fifo_sync_inst</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod0_2.html#inst_tag_4" id="tag_urg_inst_4">gen_sdpram.xpm_memory_base_inst</a></td>
<td class="s3 cl rt"> 37.91</td>
<td class="s3 cl rt"> 37.88</td>
<td class="s2 cl rt"> 28.57</td>
<td class="s4 cl rt"> 47.27</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_160" id="tag_urg_inst_160">rdp_inst</a></td>
<td class="s9 cl rt"> 97.62</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 95.24</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_161" id="tag_urg_inst_161">rdpp1_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod7.html#inst_tag_135" id="tag_urg_inst_135">rst_d1_inst</a></td>
<td class="s7 cl rt"> 70.83</td>
<td class="s6 cl rt"> 66.67</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 75.00</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod7.html#inst_tag_136" id="tag_urg_inst_136">rst_d2_inst</a></td>
<td class="s7 cl rt"> 70.83</td>
<td class="s6 cl rt"> 66.67</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 75.00</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_157" id="tag_urg_inst_157">wrp_inst</a></td>
<td class="s9 cl rt"> 97.62</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 95.24</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_158" id="tag_urg_inst_158">wrpp1_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_159" id="tag_urg_inst_159">wrpp2_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_122" id="tag_urg_inst_122">xpm_fifo_rst_inst</a></td>
<td class="s9 cl rt"> 92.31</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s8 cl rt"> 84.62</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_274'>
<hr>
<a name="inst_tag_274"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_274" >AdaptedSharpener.fifo.lineBuffer_3.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="s6 cl rt"> 65.79</td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_274_Line" > 60.56</a></td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_274_Cond" > 66.67</a></td>
<td class="s7 cl rt"><a href="mod18.html#inst_tag_274_Toggle" > 70.14</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="s4 cl rt"> 47.95</td>
<td class="s4 cl rt"> 43.81</td>
<td class="s3 cl rt"> 37.04</td>
<td class="s6 cl rt"> 63.00</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s6 cl rt"> 68.58</td>
<td class="s5 cl rt"> 55.56</td>
<td class="wht cl rt"></td>
<td class="s8 cl rt"> 81.61</td>
<td class="wht cl rt"></td>
<td><a href="mod1.html#inst_tag_10" >xpm_fifo_sync_inst</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod0_1.html#inst_tag_3" id="tag_urg_inst_3">gen_sdpram.xpm_memory_base_inst</a></td>
<td class="s3 cl rt"> 37.91</td>
<td class="s3 cl rt"> 37.88</td>
<td class="s2 cl rt"> 28.57</td>
<td class="s4 cl rt"> 47.27</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_155" id="tag_urg_inst_155">rdp_inst</a></td>
<td class="s9 cl rt"> 97.62</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 95.24</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_156" id="tag_urg_inst_156">rdpp1_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod7.html#inst_tag_133" id="tag_urg_inst_133">rst_d1_inst</a></td>
<td class="s7 cl rt"> 70.83</td>
<td class="s6 cl rt"> 66.67</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 75.00</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod7.html#inst_tag_134" id="tag_urg_inst_134">rst_d2_inst</a></td>
<td class="s7 cl rt"> 70.83</td>
<td class="s6 cl rt"> 66.67</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 75.00</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_152" id="tag_urg_inst_152">wrp_inst</a></td>
<td class="s9 cl rt"> 97.62</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 95.24</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_153" id="tag_urg_inst_153">wrpp1_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_154" id="tag_urg_inst_154">wrpp2_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_121" id="tag_urg_inst_121">xpm_fifo_rst_inst</a></td>
<td class="s9 cl rt"> 92.31</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s8 cl rt"> 84.62</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_271'>
<hr>
<a name="inst_tag_271"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_271" >AdaptedSharpener.fifo.lineBuffer_0.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="s6 cl rt"> 65.83</td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_271_Line" > 60.56</a></td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_271_Cond" > 66.67</a></td>
<td class="s7 cl rt"><a href="mod18.html#inst_tag_271_Toggle" > 70.25</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="s4 cl rt"> 47.97</td>
<td class="s4 cl rt"> 43.81</td>
<td class="s3 cl rt"> 37.04</td>
<td class="s6 cl rt"> 63.05</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s6 cl rt"> 68.87</td>
<td class="s5 cl rt"> 55.56</td>
<td class="wht cl rt"></td>
<td class="s8 cl rt"> 82.18</td>
<td class="wht cl rt"></td>
<td><a href="mod1.html#inst_tag_7" >xpm_fifo_sync_inst</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod0_0.html#inst_tag_0" id="tag_urg_inst_0">gen_sdpram.xpm_memory_base_inst</a></td>
<td class="s3 cl rt"> 37.91</td>
<td class="s3 cl rt"> 37.88</td>
<td class="s2 cl rt"> 28.57</td>
<td class="s4 cl rt"> 47.27</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_140" id="tag_urg_inst_140">rdp_inst</a></td>
<td class="s9 cl rt"> 97.62</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 95.24</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_141" id="tag_urg_inst_141">rdpp1_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod7.html#inst_tag_127" id="tag_urg_inst_127">rst_d1_inst</a></td>
<td class="s7 cl rt"> 70.83</td>
<td class="s6 cl rt"> 66.67</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 75.00</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod7.html#inst_tag_128" id="tag_urg_inst_128">rst_d2_inst</a></td>
<td class="s7 cl rt"> 70.83</td>
<td class="s6 cl rt"> 66.67</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 75.00</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_137" id="tag_urg_inst_137">wrp_inst</a></td>
<td class="s9 cl rt"> 97.62</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 95.24</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_138" id="tag_urg_inst_138">wrpp1_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_139" id="tag_urg_inst_139">wrpp2_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_118" id="tag_urg_inst_118">xpm_fifo_rst_inst</a></td>
<td class="s9 cl rt"> 92.31</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s8 cl rt"> 84.62</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_273'>
<hr>
<a name="inst_tag_273"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_273" >AdaptedSharpener.fifo.lineBuffer_2.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="s6 cl rt"> 65.83</td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_273_Line" > 60.56</a></td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_273_Cond" > 66.67</a></td>
<td class="s7 cl rt"><a href="mod18.html#inst_tag_273_Toggle" > 70.25</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="s4 cl rt"> 47.97</td>
<td class="s4 cl rt"> 43.81</td>
<td class="s3 cl rt"> 37.04</td>
<td class="s6 cl rt"> 63.05</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s6 cl rt"> 68.87</td>
<td class="s5 cl rt"> 55.56</td>
<td class="wht cl rt"></td>
<td class="s8 cl rt"> 82.18</td>
<td class="wht cl rt"></td>
<td><a href="mod1.html#inst_tag_9" >xpm_fifo_sync_inst</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod0_1.html#inst_tag_2" id="tag_urg_inst_2">gen_sdpram.xpm_memory_base_inst</a></td>
<td class="s3 cl rt"> 37.91</td>
<td class="s3 cl rt"> 37.88</td>
<td class="s2 cl rt"> 28.57</td>
<td class="s4 cl rt"> 47.27</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_150" id="tag_urg_inst_150">rdp_inst</a></td>
<td class="s9 cl rt"> 97.62</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 95.24</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_151" id="tag_urg_inst_151">rdpp1_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod7.html#inst_tag_131" id="tag_urg_inst_131">rst_d1_inst</a></td>
<td class="s7 cl rt"> 70.83</td>
<td class="s6 cl rt"> 66.67</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 75.00</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod7.html#inst_tag_132" id="tag_urg_inst_132">rst_d2_inst</a></td>
<td class="s7 cl rt"> 70.83</td>
<td class="s6 cl rt"> 66.67</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 75.00</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_147" id="tag_urg_inst_147">wrp_inst</a></td>
<td class="s9 cl rt"> 97.62</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 95.24</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_148" id="tag_urg_inst_148">wrpp1_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_149" id="tag_urg_inst_149">wrpp2_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_120" id="tag_urg_inst_120">xpm_fifo_rst_inst</a></td>
<td class="s9 cl rt"> 92.31</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s8 cl rt"> 84.62</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
</div>
</div>
<div name='inst_tag_272'>
<hr>
<a name="inst_tag_272"></a>
<div class=modhdr>
<br clear=all>
<span class=titlename>Module Instance : <a href="hierarchy.html#tag_urg_inst_272" >AdaptedSharpener.fifo.lineBuffer_1.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></span>
<br clear=all>
<br clear=all>
<span class=repname>Instance :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="s6 cl rt"> 65.98</td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_272_Line" > 60.56</a></td>
<td class="s6 cl rt"><a href="mod18.html#inst_tag_272_Cond" > 66.67</a></td>
<td class="s7 cl rt"><a href="mod18.html#inst_tag_272_Toggle" > 70.72</a></td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Instance's subtree :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="s4 cl rt"> 48.04</td>
<td class="s4 cl rt"> 43.81</td>
<td class="s3 cl rt"> 37.04</td>
<td class="s6 cl rt"> 63.26</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Parent : </span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td><td class="alfsrt">NAME</td></tr><tr>
<td class="s6 cl rt"> 69.16</td>
<td class="s5 cl rt"> 55.56</td>
<td class="wht cl rt"></td>
<td class="s8 cl rt"> 82.76</td>
<td class="wht cl rt"></td>
<td><a href="mod1.html#inst_tag_8" >xpm_fifo_sync_inst</a></td>
</tr></table><br clear=all>
<br clear=all>
<span class=repname>Subtrees :</span>
<br clear=all>
<table align=left>
<tr class="sortablehead">
<td class="alfsrt">NAME</td><td>SCORE</td><td>LINE</td><td>COND</td><td>TOGGLE</td><td>FSM</td></tr><tr>
<td class="wht cl wordwrap"><a href="mod0_0.html#inst_tag_1" id="tag_urg_inst_1">gen_sdpram.xpm_memory_base_inst</a></td>
<td class="s3 cl rt"> 37.91</td>
<td class="s3 cl rt"> 37.88</td>
<td class="s2 cl rt"> 28.57</td>
<td class="s4 cl rt"> 47.27</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_145" id="tag_urg_inst_145">rdp_inst</a></td>
<td class="s9 cl rt"> 97.62</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 95.24</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_146" id="tag_urg_inst_146">rdpp1_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod7.html#inst_tag_129" id="tag_urg_inst_129">rst_d1_inst</a></td>
<td class="s7 cl rt"> 70.83</td>
<td class="s6 cl rt"> 66.67</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 75.00</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod7.html#inst_tag_130" id="tag_urg_inst_130">rst_d2_inst</a></td>
<td class="s7 cl rt"> 70.83</td>
<td class="s6 cl rt"> 66.67</td>
<td class="wht cl rt"></td>
<td class="s7 cl rt"> 75.00</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_142" id="tag_urg_inst_142">wrp_inst</a></td>
<td class="s9 cl rt"> 97.62</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 95.24</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_143" id="tag_urg_inst_143">wrpp1_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod8.html#inst_tag_144" id="tag_urg_inst_144">wrpp2_inst</a></td>
<td class="s9 cl rt"> 97.37</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s9 cl rt"> 94.74</td>
<td class="wht cl rt"></td>
</tr><tr>
<td class="wht cl wordwrap"><a href="mod5.html#inst_tag_119" id="tag_urg_inst_119">xpm_fifo_rst_inst</a></td>
<td class="s9 cl rt"> 92.31</td>
<td class="s10 cl rt">100.00</td>
<td class="wht cl rt"></td>
<td class="s8 cl rt"> 84.62</td>
<td class="wht cl rt"></td>
</tr></table><br clear=all>
</div>
</div>
</div>
<div class="ui-layout-center">
<div class="ui-layout-center-inner-center">
<div name='tag_\XPM.xpm_fifo_base '>
<a name="Line"></a>
Line Coverage for Module : <a href="mod18.html" >\XPM.xpm_fifo_base </a><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">TOTAL</td><td></td><td>142</td><td>86</td><td>60.56</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>126</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">ROUTINE</td><td>304</td><td>5</td><td>4</td><td>80.00</td></tr>
<tr class="s3"><td class="lf">INITIAL</td><td>314</td><td>81</td><td>29</td><td>35.80</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>958</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>994</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1026</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1041</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1049</td><td>9</td><td>8</td><td>88.89</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1064</td><td>9</td><td>9</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1081</td><td>7</td><td>6</td><td>85.71</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1481</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1491</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1507</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1526</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">INITIAL</td><td>1546</td><td>4</td><td>3</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
125                       begin 
126        1/1              value = value-1;
127        1/1              for (clog2=0; value&gt;0; clog2=clog2+1)
128        1/1                value = value&gt;&gt;1;
129                         end 
130                       endfunction
131                       // Function to convert ASCII value to binary 
132                       function [3:0] str2bin;
133                         input [7:0] str_val_ascii;
134                           if((str_val_ascii == 8'h30) || (str_val_ascii == 8'h31) || 
135                              (str_val_ascii == 8'h32) || (str_val_ascii == 8'h33) || 
136                              (str_val_ascii == 8'h34) || (str_val_ascii == 8'h35) || 
137                              (str_val_ascii == 8'h36) || (str_val_ascii == 8'h37) || 
138                              (str_val_ascii == 8'h38) || (str_val_ascii == 8'h39) || 
139                              (str_val_ascii == 8'h41) || (str_val_ascii == 8'h42) || 
140                              (str_val_ascii == 8'h43) || (str_val_ascii == 8'h44) || 
141                              (str_val_ascii == 8'h45) || (str_val_ascii == 8'h46) || 
142                              (str_val_ascii == 8'h61) || (str_val_ascii == 8'h62) || 
143                              (str_val_ascii == 8'h63) || (str_val_ascii == 8'h64) || 
144                              (str_val_ascii == 8'h65) || (str_val_ascii == 8'h66) || 
145                              (str_val_ascii == 8'h00)) begin
146                              if (!str_val_ascii[6])
147                                 str2bin = str_val_ascii[3:0];
148                              else begin
149                                str2bin [3] = 1'b1;
150                                str2bin [2] = str_val_ascii[2] | (str_val_ascii[1] &amp; str_val_ascii[0]);
151                                str2bin [1] = str_val_ascii[0] ^ str_val_ascii[1];
152                                str2bin [0] = !str_val_ascii[0];
153                              end
154                           end
155                           else
156                             $error(&quot;Found Invalid character while parsing the string, please cross check the value specified for either READ_RESET_VALUE_A|B or MEMORY_INIT_PARAM (if initialization of memory through parameter is used). XPM_MEMORY supports strings (hex) that contains characters 0-9, A-F and a-f.&quot;);
157                       endfunction
158                       // Function that parses the complete reset value string
159                       function logic [15:0] hstr2bin;
160                         input [16*8-1 : 0] hstr_val;
161                         integer rst_loop_a;
162                         localparam integer  rsta_loop_iter  =  16;
163                         logic [rsta_loop_iter-1 : 0] rst_val_conv_a_i;
164                         for (rst_loop_a=1; rst_loop_a &lt;= rsta_loop_iter/4; rst_loop_a = rst_loop_a+1) begin
165                           rst_val_conv_a_i[(rst_loop_a*4)-1 -: 4] =  str2bin(hstr_val[(rst_loop_a*8)-1 -: 8]);
166                         end
167                         return rst_val_conv_a_i[15:0];
168                       endfunction
169                     
170                     
171                       localparam invalid             = 0;
172                       localparam stage1_valid        = 2;
173                       localparam stage2_valid        = 1;
174                       localparam both_stages_valid   = 3;
175                     
176                       reg  [1:0] curr_fwft_state = invalid;
177                       reg  [1:0] next_fwft_state;// = invalid;
178                     
179                     
180                     
181                       localparam FIFO_MEM_TYPE   = FIFO_MEMORY_TYPE;
182                       localparam RD_MODE         = READ_MODE;
183                       localparam ENABLE_ECC      = (ECC_MODE == 1) ? 3 : 0;
184                       localparam FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH;
185                       localparam FIFO_SIZE       = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH;
186                       localparam WR_WIDTH_LOG    = clog2(WRITE_DATA_WIDTH);
187                       localparam WR_DEPTH_LOG    = clog2(FIFO_WRITE_DEPTH);
188                       localparam WR_PNTR_WIDTH   = clog2(FIFO_WRITE_DEPTH);
189                       localparam RD_PNTR_WIDTH   = clog2(FIFO_READ_DEPTH);
190                       localparam FULL_RST_VAL    = FULL_RESET_VALUE == 0 ? 1'b0 : 1'b1;
191                       localparam WR_RD_RATIO     = (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) ? (WR_PNTR_WIDTH-RD_PNTR_WIDTH) : 0;
192                       localparam READ_MODE_LL    = (READ_MODE == 0) ? 0 : 1;
193                       localparam PF_THRESH_ADJ   = (READ_MODE == 0) ? PROG_FULL_THRESH :
194                                                    PROG_FULL_THRESH - (2*(2**WR_RD_RATIO));
195                       localparam PE_THRESH_ADJ   = (READ_MODE_LL == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) ? PROG_EMPTY_THRESH - 2'h2 : PROG_EMPTY_THRESH;
196                     
197                       localparam PF_THRESH_MIN   = 3+(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1))+(COMMON_CLOCK?0:CDC_DEST_SYNC_FF);
198                       localparam PF_THRESH_MAX   = (FIFO_WRITE_DEPTH-3)-(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1));
199                       localparam PE_THRESH_MIN   = 3+(READ_MODE_LL*2);
200                       localparam PE_THRESH_MAX   = (FIFO_READ_DEPTH-3)-(READ_MODE_LL*2);
201                       localparam WR_DC_WIDTH_EXT = clog2(FIFO_WRITE_DEPTH)+1;
202                       localparam RD_DC_WIDTH_EXT = clog2(FIFO_READ_DEPTH)+1;
203                       localparam RD_LATENCY      = (READ_MODE == 2) ? 1 : (READ_MODE == 1) ? 2 : FIFO_READ_LATENCY;
204                       localparam WIDTH_RATIO     = (READ_DATA_WIDTH &gt; WRITE_DATA_WIDTH) ? (READ_DATA_WIDTH/WRITE_DATA_WIDTH) : (WRITE_DATA_WIDTH/READ_DATA_WIDTH);
205                     
206                       localparam [15:0] EN_ADV_FEATURE = hstr2bin(USE_ADV_FEATURES);
207                     
208                       localparam EN_OF           = EN_ADV_FEATURE[0];  //EN_ADV_FLAGS_WR[0] ? 1 : 0;
209                       localparam EN_PF           = EN_ADV_FEATURE[1];  //EN_ADV_FLAGS_WR[1] ? 1 : 0;
210                       localparam EN_WDC          = EN_ADV_FEATURE[2];  //EN_ADV_FLAGS_WR[2] ? 1 : 0;
211                       localparam EN_AF           = EN_ADV_FEATURE[3];  //EN_ADV_FLAGS_WR[3] ? 1 : 0;
212                       localparam EN_WACK         = EN_ADV_FEATURE[4];  //EN_ADV_FLAGS_WR[4] ? 1 : 0;
213                       localparam FG_EQ_ASYM_DOUT = EN_ADV_FEATURE[5];  //EN_ADV_FLAGS_WR[5] ? 1 : 0;
214                       localparam EN_UF           = EN_ADV_FEATURE[8];  //EN_ADV_FLAGS_RD[0] ? 1 : 0;
215                       localparam EN_PE           = EN_ADV_FEATURE[9];  //EN_ADV_FLAGS_RD[1] ? 1 : 0;
216                       localparam EN_RDC          = EN_ADV_FEATURE[10]; //EN_ADV_FLAGS_RD[2] ? 1 : 0;
217                       localparam EN_AE           = EN_ADV_FEATURE[11]; //EN_ADV_FLAGS_RD[3] ? 1 : 0;
218                       localparam EN_DVLD         = EN_ADV_FEATURE[12]; //EN_ADV_FLAGS_RD[4] ? 1 : 0;
219                     
220                       wire                       wrst_busy;
221                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr;
222                       wire [WR_PNTR_WIDTH:0]     wr_pntr_ext;
223                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd_cdc;
224                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_cdc_dc;
225                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd;
226                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_dc;
227                       wire [WR_PNTR_WIDTH-1:0]   rd_pntr_wr_adj;
228                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_dc;
229                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus1;
230                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus2;
231                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus3;
232                       wire [WR_PNTR_WIDTH:0]     wr_pntr_plus1_pf;
233                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_inv_pf;
234                       reg  [WR_PNTR_WIDTH:0]     diff_pntr_pf_q = {WR_PNTR_WIDTH{1'b0}};
235                       wire [WR_PNTR_WIDTH-1:0]   diff_pntr_pf;
236                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr;
237                       wire [RD_PNTR_WIDTH:0]     rd_pntr_ext;
238                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr_cdc;
239                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr;
240                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_cdc_dc;
241                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_dc;
242                       wire [RD_PNTR_WIDTH-1:0]   wr_pntr_rd_adj;
243                       wire [RD_PNTR_WIDTH:0]     wr_pntr_rd_adj_dc;
244                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus1;
245                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus2;
246                       wire                       invalid_state;
247                       wire                       valid_fwft;
248                       wire                       ram_valid_fwft;
249                       wire                       going_empty;
250                       wire                       leaving_empty;
251                       wire                       going_aempty;
252                       wire                       leaving_aempty;
253                       reg                        ram_empty_i  = 1'b1;
254                       reg                        ram_aempty_i = 1'b1;
255                       wire                       empty_i;
256                       wire                       going_full;
257                       wire                       leaving_full;
258                       wire                       going_afull;
259                       wire                       leaving_afull;
260                       reg                        prog_full_i = FULL_RST_VAL;
261                       reg                        ram_full_i  = FULL_RST_VAL;
262                       reg                        ram_afull_i = FULL_RST_VAL;
263                       reg                        ram_full_n  = ~FULL_RST_VAL;
264                       wire                       ram_wr_en_i;
265                       wire                       ram_rd_en_i;
266                       reg                        wr_ack_i = 1'b0;
267                       wire                       rd_en_i;
268                       reg                        rd_en_fwft;
269                       wire                       ram_regce;
270                       wire                       ram_regce_pipe;
271                       wire [READ_DATA_WIDTH-1:0] dout_i;
272                       reg                        empty_fwft_i     = 1'b1;
273                       reg                        aempty_fwft_i    = 1'b1;
274                       reg                        empty_fwft_fb    = 1'b1;
275                       reg                        overflow_i       = 1'b0;
276                       reg                        underflow_i      = 1'b0;
277                       reg                        data_valid_fwft  = 1'b0;
278                       reg                        data_valid_std   = 1'b0;
279                       wire                       data_vld_std;
280                       wire                       wrp_gt_rdp_and_red;
281                       wire                       wrp_lt_rdp_and_red;
282                       reg                        ram_wr_en_pf_q = 1'b0;
283                       reg                        ram_rd_en_pf_q = 1'b0;
284                       wire                       ram_wr_en_pf;
285                       wire                       ram_rd_en_pf;
286                       wire                       wr_pntr_plus1_pf_carry;
287                       wire                       rd_pntr_wr_adj_pf_carry;
288                       wire                       write_allow;
289                       wire                       read_allow;
290                       wire                       read_only;
291                       wire                       write_only;
292                       reg                        write_only_q;
293                       reg                        read_only_q;
294                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg1;
295                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg2;
296                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe = 'b0;
297                       reg                        prog_empty_i = 1'b1;
298                       reg                        ram_empty_i_d1 = 1'b1;
299                       wire                       fe_of_empty;
300                       // function to validate the write depth value
301                       function logic dpth_pwr_2;
302                         input integer fifo_depth;
303                         integer log2_of_depth; // correcponding to the default value of 2k depth
304        1/1              log2_of_depth = clog2(fifo_depth);
305        1/1              if (fifo_depth == 2 ** log2_of_depth)
306        1/1                dpth_pwr_2 = 1;
307                         else
308        <font color = "red">0/1     ==>        dpth_pwr_2 = 0;</font>
309        1/1              return dpth_pwr_2;
310                       endfunction
311                       
312                       initial begin : config_drc
313                         reg drc_err_flag;
314        1/1              drc_err_flag = 0;
315        2/2              #1;
316                     
317        1/1              if (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEM_TYPE == 3) begin
318        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] UltraRAM cannot be used as asynchronous FIFO because it has only one clock support %m&quot;, &quot;XPM_FIFO&quot;, 1, 1);</font>
319        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
320                         end
                        MISSING_ELSE
321                     
322        1/1              if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 1) begin
323        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Related Clocks cannot be used in synchronous FIFO because it is applicable only for asynchronous FIFO %m&quot;, &quot;XPM_FIFO&quot;, 1, 2);</font>
324        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
325                         end
                        MISSING_ELSE
326                     
327        1/1              if(!(FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
328        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is not within the supported ranges. Miniumum supported depth is 16, and the maximum supported depth is 4*1024*1024 locations. %m&quot;, &quot;XPM_FIFO&quot;, 1, 3, FIFO_WRITE_DEPTH);</font>
329        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
330                         end
                        MISSING_ELSE
331                     
332        1/1              if(!dpth_pwr_2(FIFO_WRITE_DEPTH) &amp;&amp; (FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
333        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is non-power of 2, but this release of XPM_FIFO supports configurations having the fifo write depth set to power of 2. %m&quot;, &quot;XPM_FIFO&quot;, 1, 4, FIFO_WRITE_DEPTH);</font>
334        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
335                         end
                        MISSING_ELSE
336                     
337        1/1              if (CDC_DEST_SYNC_FF &lt; 2 || CDC_DEST_SYNC_FF &gt; 8) begin
338        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but this beta release of XPM_FIFO supports CDC_DEST_SYNC_FF values in between 2 and 8. %m&quot;, &quot;XPM_FIFO&quot;, 1, 5,CDC_DEST_SYNC_FF);</font>
339        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
340                         end
                        MISSING_ELSE
341        1/1              if (CDC_DEST_SYNC_FF != 2 &amp;&amp; RELATED_CLOCKS == 1) begin
342        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but CDC_DEST_SYNC_FF value can not be modified from default value when RELATED_CLOCKS parameter is set to 1. %m&quot;, &quot;XPM_FIFO&quot;, 1, 6,CDC_DEST_SYNC_FF);</font>
343        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
344                         end
                        MISSING_ELSE
345        1/1              if (FIFO_WRITE_DEPTH == 16 &amp;&amp; CDC_DEST_SYNC_FF &gt; 4) begin
346        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF = %0d and FIFO_WRITE_DEPTH = %0d. This is invalid combination. Either FIFO_WRITE_DEPTH should be increased or CDC_DEST_SYNC_FF should be reduced. %m&quot;, &quot;XPM_FIFO&quot;, 1, 7,CDC_DEST_SYNC_FF, FIFO_WRITE_DEPTH);</font>
347        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
348                         end
                        MISSING_ELSE
349        1/1              if (EN_ADV_FEATURE[7:5] != 3'h0) begin
350        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[7:5] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 8, EN_ADV_FEATURE[7:5]);</font>
351        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
352                         end
                        MISSING_ELSE
353        1/1              if (EN_ADV_FEATURE[15:14] != 3'h0) begin
354        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[15:13] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 9, EN_ADV_FEATURE[15:13]);</font>
355        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
356                         end
                        MISSING_ELSE
357                     //    if(WIDTH_RATIO &gt; 32) begin
358                     //      $error(&quot;[%s %0d-%0d] The ratio between WRITE_DATA_WIDTH (%0d) and READ_DATA_WIDTH (%0d) is greater than 32, but this release of XPM_FIFO supports configurations having the ratio between data widths must be less than 32. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH, READ_DATA_WIDTH);
359                     //      drc_err_flag = 1;
360                     //    end
361        1/1              if (WR_WIDTH_LOG+WR_DEPTH_LOG &gt; 30) begin
362        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The specified Width(%0d) and Depth(%0d) exceeds the maximum supported FIFO SIZE. Please reduce either FIFO Width or Depth. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH,FIFO_WRITE_DEPTH);</font>
363        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
364                         end
                        MISSING_ELSE
365        1/1              if(FIFO_READ_DEPTH &lt; 16) begin
366        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Width is %0d Read Width is %0d and Write Depth is %0d, this results in the Read Depth(%0d) less than 16. This is an invalid combination, Ensure the depth on both sides is minimum 16. %m&quot;, &quot;XPM_FIFO&quot;, 1, 11, WRITE_DATA_WIDTH, READ_DATA_WIDTH, FIFO_WRITE_DEPTH, FIFO_READ_DEPTH);</font>
367        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
368                         end
                        MISSING_ELSE
369                     
370                         // Range Checks
371        1/1              if (COMMON_CLOCK &gt; 1) begin
372        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] COMMON_CLOCK (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 1, COMMON_CLOCK);</font>
373        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
374                         end
                        MISSING_ELSE
375        1/1              if (FIFO_MEMORY_TYPE &gt; 3) begin
376        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_MEMORY_TYPE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 2, FIFO_MEMORY_TYPE);</font>
377        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
378                         end
                        MISSING_ELSE
379        1/1          	if (READ_MODE &gt; 2) begin
380        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 3, READ_MODE);</font>
381        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
382                         end
                        MISSING_ELSE
383                     
384        1/1              if (ECC_MODE &gt; 1) begin
385        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] ECC_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 4, ECC_MODE);</font>
386        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
387                         end
                        MISSING_ELSE
388        1/1          	if (!(WAKEUP_TIME == 0 || WAKEUP_TIME == 2)) begin
389        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WAKEUP_TIME (%0d) value is outside of legal range. WAKEUP_TIME should be either 0 or 2. %m&quot;, &quot;XPM_FIFO&quot;, 10, 5, WAKEUP_TIME);</font>
390        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
391                         end
                        MISSING_ELSE
392        1/1              if (!(VERSION == 0)) begin
393        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] VERSION (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 6, VERSION);</font>
394        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
395                         end
                        MISSING_ELSE
396                     
397        1/1              if (!(WRITE_DATA_WIDTH &gt; 0)) begin
398        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 2, WRITE_DATA_WIDTH);</font>
399        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
400                         end
                        MISSING_ELSE
401        1/1              if (!(READ_DATA_WIDTH &gt; 0)) begin
402        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 3, READ_DATA_WIDTH);</font>
403        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
404                         end
                        MISSING_ELSE
405                     
406        1/1              if (EN_PF == 1 &amp;&amp; ((PROG_FULL_THRESH &lt; PF_THRESH_MIN) || (PROG_FULL_THRESH &gt; PF_THRESH_MAX))) begin
407        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Full flag is enabled, but PROG_FULL_THRESH (%0d) value is outside of legal range. PROG_FULL_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 4, PROG_FULL_THRESH, PF_THRESH_MIN, PF_THRESH_MAX);</font>
408        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
409                         end
                        MISSING_ELSE
410                     
411        1/1              if (EN_PE == 1 &amp;&amp; (WIDTH_RATIO &lt;= 32) &amp;&amp; ((PROG_EMPTY_THRESH &lt; PE_THRESH_MIN) || (PROG_EMPTY_THRESH &gt; PE_THRESH_MAX))) begin
412        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Empty flag is enabled, but PROG_EMPTY_THRESH (%0d) value is outside of legal range. PROG_EMPTY_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 5, PROG_EMPTY_THRESH, PE_THRESH_MIN, PE_THRESH_MAX);</font>
413        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
414                         end
                        MISSING_ELSE
415                     
416        1/1              if (EN_WDC == 1 &amp;&amp; ((WR_DATA_COUNT_WIDTH &lt; 0) || (WR_DATA_COUNT_WIDTH &gt; WR_DC_WIDTH_EXT))) begin
417        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Data Count is enabled, but WR_DATA_COUNT_WIDTH (%0d) value is outside of legal range. WR_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 6, WR_DATA_COUNT_WIDTH, 0, WR_DC_WIDTH_EXT);</font>
418        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
419                         end
                        MISSING_ELSE
420                     
421                     
422        1/1              if (EN_RDC == 1 &amp;&amp; ((RD_DATA_COUNT_WIDTH &lt; 0) || (RD_DATA_COUNT_WIDTH &gt; RD_DC_WIDTH_EXT))) begin
423        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Read Data Count is enabled, but RD_DATA_COUNT_WIDTH (%0d) value is outside of legal range. RD_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 7, RD_DATA_COUNT_WIDTH, 0, RD_DC_WIDTH_EXT);</font>
424        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
425                         end
                        MISSING_ELSE
426                     
427                         //DRCs on Low Latency FWFT mode
428        1/1              if (READ_MODE == 2 &amp;&amp; FIFO_MEMORY_TYPE != 1) begin
429        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] XPM_FIFO does not support Read Mode (Low Latency FWFT) for FIFO_MEMORY_TYPE other than lutram/distributed. %m&quot;, &quot;XPM_FIFO&quot;, 16, 2);</font>
430        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
431                         end
                        MISSING_ELSE
432        1/1              if (READ_MODE == 2 &amp;&amp; EN_ADV_FEATURE != 16'h0) begin
433        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES = %0h. XPM_FIFO does not support Advanced Features in Low Latency FWFT mode. %m&quot;, &quot;XPM_FIFO&quot;, 16, 3, EN_ADV_FEATURE);</font>
434        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
435                         end
                        MISSING_ELSE
436                     
437                         // Infos
438                     
439                         // Warnings
440        1/1              if (drc_err_flag == 1)
441        <font color = "red">0/2     ==>        #1 $finish;</font>
                        MISSING_ELSE
442                       end : config_drc
443                     
444                       wire wr_en_i;
445                       wire wr_rst_i;
446                       wire rd_rst_i;
447                       reg  rd_rst_d2 = 1'b0;
448                       wire rst_d1;
449                       wire rst_d2;
450                       wire clr_full;
451                       wire empty_fwft_d1;
452                       wire leaving_empty_fwft_fe;
453                       wire leaving_empty_fwft_re;
454                       wire le_fwft_re;
455                       wire le_fwft_fe;
456                       wire [1:0] extra_words_fwft;
457                       wire le_fwft_re_wr;
458                       wire le_fwft_fe_wr;
459                     
460                       generate
461                     
462                       xpm_fifo_rst # (COMMON_CLOCK, CDC_DEST_SYNC_FF, SIM_ASSERT_CHK)
463                         xpm_fifo_rst_inst (rst, wr_clk, rd_clk, wr_rst_i, rd_rst_i, wrst_busy, rd_rst_busy);
464                       assign wr_rst_busy = wrst_busy | rst_d1;
465                     
466                       xpm_fifo_reg_bit #(0)
467                         rst_d1_inst (1'b0, wr_clk, wrst_busy, rst_d1);
468                       xpm_fifo_reg_bit #(0)
469                         rst_d2_inst (1'b0, wr_clk, rst_d1, rst_d2);
470                     
471                       assign clr_full = ~wrst_busy &amp; rst_d1 &amp; ~rst;
472                       assign rd_en_i = (RD_MODE == 0) ? rd_en : rd_en_fwft;
473                     
474                       if (REMOVE_WR_RD_PROT_LOGIC == 1) begin : ngen_wr_rd_prot
475                         assign ram_wr_en_i = wr_en;
476                         assign ram_rd_en_i = rd_en_i;
477                       end : ngen_wr_rd_prot
478                       else begin : gen_wr_rd_prot
479                         assign ram_wr_en_i = wr_en &amp; ~ram_full_i &amp; ~(wrst_busy|rst_d1);
480                         assign ram_rd_en_i = rd_en_i &amp; ~ram_empty_i;
481                       end : gen_wr_rd_prot
482                     
483                       // Write pointer generation
484                       xpm_counter_updn # (WR_PNTR_WIDTH+1, 0)
485                         wrp_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_ext);
486                       assign wr_pntr = wr_pntr_ext[WR_PNTR_WIDTH-1:0];
487                     
488                       xpm_counter_updn # (WR_PNTR_WIDTH, 1)
489                         wrpp1_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus1);
490                     
491                       xpm_counter_updn # (WR_PNTR_WIDTH, 2)
492                         wrpp2_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus2);
493                     
494                       if (EN_AF == 1) begin : gaf_wptr_p3
495                         xpm_counter_updn # (WR_PNTR_WIDTH, 3)
496                           wrpp3_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus3);
497                       end : gaf_wptr_p3
498                     
499                       // Read pointer generation
500                       xpm_counter_updn # (RD_PNTR_WIDTH+1, 0)
501                         rdp_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_ext);
502                       assign rd_pntr = rd_pntr_ext[RD_PNTR_WIDTH-1:0];
503                     
504                       xpm_counter_updn # (RD_PNTR_WIDTH, 1)
505                         rdpp1_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus1);
506                     
507                       if (EN_AE == 1) begin : gae_rptr_p2
508                         xpm_counter_updn # (RD_PNTR_WIDTH, 2)
509                           rdpp2_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus2);
510                       end : gae_rptr_p2
511                     
512                       assign full        = ram_full_i;
513                       assign full_n      = ram_full_n;
514                       assign almost_full = EN_AF == 1 ? ram_afull_i : 1'b0;
515                       assign wr_ack      = EN_WACK == 1 ? wr_ack_i : 1'b0;
516                       if (EN_WACK == 1) begin : gwack
517                         always @ (posedge wr_clk) begin
518                           if (rst | wr_rst_i | wrst_busy)
519                             wr_ack_i  &lt;= 1'b0;
520                           else
521                             wr_ack_i  &lt;= ram_wr_en_i;
522                         end
523                       end : gwack
524                     
525                       assign prog_full  = EN_PF == 1 ? (PROG_FULL_THRESH &gt; 0)  ? prog_full_i  : 1'b0 : 1'b0;
526                       assign prog_empty = EN_PE == 1 ? (PROG_EMPTY_THRESH &gt; 0) ? prog_empty_i : 1'b1 : 1'b0;
527                       
528                       assign empty_i = (RD_MODE == 0)? ram_empty_i : empty_fwft_i;
529                       assign empty   = empty_i;
530                       assign almost_empty = EN_AE == 1 ? (RD_MODE == 0) ? ram_aempty_i : aempty_fwft_i : 1'b0;
531                       
532                       assign data_valid   = EN_DVLD == 1 ? (RD_MODE == 0) ? data_valid_std : data_valid_fwft : 1'b0;
533                       if (EN_DVLD == 1) begin : gdvld
534                         assign data_vld_std = (RD_MODE == 0) ? (FIFO_READ_LATENCY == 1) ? ram_rd_en_i: ram_regce_pipe : ram_regce;
535                         always @ (posedge rd_clk) begin
536                           if (rd_rst_i)
537                             data_valid_std  &lt;= 1'b0;
538                           else
539                             data_valid_std  &lt;= data_vld_std;
540                         end
541                       end : gdvld
542                     
543                       // Simple dual port RAM instantiation for non-Built-in FIFO
544                       if (FIFO_MEMORY_TYPE &lt; 4) begin : gen_sdpram
545                     
546                       // Reset is not supported when ECC is enabled by the BRAM/URAM primitives
547                         wire rst_int;
548                         if(ECC_MODE !=0) begin : gnd_rst
549                           assign rst_int = 0;
550                         end : gnd_rst
551                         else begin : rst_gen
552                           assign rst_int = rd_rst_i;
553                         end : rst_gen
554                       // ----------------------------------------------------------------------
555                       // Base module instantiation with simple dual port RAM configuration
556                       // ----------------------------------------------------------------------
557                       localparam USE_DRAM_CONSTRAINT = (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEMORY_TYPE == 1) ? 1 : 0;
558                       localparam WR_MODE_B           = (FIFO_MEMORY_TYPE == 1 || FIFO_MEMORY_TYPE == 3) ? 1 : 2;
559                       xpm_memory_base # (
560                     
561                         // Common module parameters
562                         .MEMORY_TYPE              (1                    ),
563                         .MEMORY_SIZE              (FIFO_SIZE            ),
564                         .MEMORY_PRIMITIVE         (FIFO_MEMORY_TYPE     ),
565                         .CLOCKING_MODE            (COMMON_CLOCK ? 0 : 1 ),
566                         .ECC_MODE                 (ENABLE_ECC           ),
567                         .USE_MEM_INIT             (0                    ),
568                         .MEMORY_INIT_FILE         (&quot;none&quot;               ),
569                         .MEMORY_INIT_PARAM        (&quot;&quot;                   ),
570                         .WAKEUP_TIME              (WAKEUP_TIME          ),
571                         .MESSAGE_CONTROL          (0                    ),
572                         .VERSION                  (0                    ),
573                         .MEMORY_OPTIMIZATION      (&quot;true&quot;               ),
574                         .AUTO_SLEEP_TIME          (0                    ),
575                         .USE_EMBEDDED_CONSTRAINT  (USE_DRAM_CONSTRAINT  ),
576                         .CASCADE_HEIGHT           (CASCADE_HEIGHT       ),
577                     
578                         // Port A module parameters
579                         .WRITE_DATA_WIDTH_A       (WRITE_DATA_WIDTH     ),
580                         .READ_DATA_WIDTH_A        (WRITE_DATA_WIDTH     ),
581                         .BYTE_WRITE_WIDTH_A       (WRITE_DATA_WIDTH     ),
582                         .ADDR_WIDTH_A             (WR_PNTR_WIDTH        ),
583                         .READ_RESET_VALUE_A       (&quot;0&quot;                  ),
584                         .READ_LATENCY_A           (2                    ),
585                         .WRITE_MODE_A             (2                    ),
586                     
587                         // Port B module parameters
588                         .WRITE_DATA_WIDTH_B       (READ_DATA_WIDTH      ),
589                         .READ_DATA_WIDTH_B        (READ_DATA_WIDTH      ),
590                         .BYTE_WRITE_WIDTH_B       (READ_DATA_WIDTH      ),
591                         .ADDR_WIDTH_B             (RD_PNTR_WIDTH        ),
592                         .READ_RESET_VALUE_B       (DOUT_RESET_VALUE     ),
593                         .READ_LATENCY_B           (RD_LATENCY           ),
594                         .WRITE_MODE_B             (WR_MODE_B            )
595                       ) xpm_memory_base_inst (
596                     
597                         // Common module ports
598                         .sleep          (sleep                    ),
599                     
600                         // Port A module ports
601                         .clka           (wr_clk                   ),
602                         .rsta           (1'b0                     ),
603                         .ena            (ram_wr_en_i              ),
604                         .regcea         (1'b0                     ),
605                         .wea            (ram_wr_en_i              ),
606                         .addra          (wr_pntr                  ),
607                         .dina           (din                      ),
608                         .injectsbiterra (injectsbiterr            ),
609                         .injectdbiterra (injectdbiterr            ),
610                         .douta          (                         ),
611                         .sbiterra       (                         ),
612                         .dbiterra       (                         ),
613                     
614                         // Port B module ports
615                         .clkb           (rd_clk                   ),
616                         .rstb           (rst_int                  ),
617                         .enb            (ram_rd_en_i              ),
618                         .regceb         (READ_MODE == 0 ? ram_regce_pipe: ram_regce),
619                         .web            (1'b0                     ),
620                         .addrb          (rd_pntr                  ),
621                         .dinb           ({READ_DATA_WIDTH{1'b0}}  ),
622                         .injectsbiterrb (1'b0                     ),
623                         .injectdbiterrb (1'b0                     ),
624                         .doutb          (dout_i                   ),
625                         .sbiterrb       (sbiterr                  ),
626                         .dbiterrb       (dbiterr                  )
627                       );
628                       end : gen_sdpram
629                     
630                       if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
631                         assign wr_pntr_rd_adj    = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
632                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
633                         assign rd_pntr_wr_adj    = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
634                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
635                       end : wrp_eq_rdp
636                     
637                       if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
638                         assign wr_pntr_rd_adj = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
639                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
640                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr;
641                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
642                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr_dc;
643                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
644                       end : wrp_gt_rdp
645                     
646                       if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
647                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd;
648                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
649                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd_dc;
650                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
651                         assign rd_pntr_wr_adj = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
652                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
653                       end : wrp_lt_rdp
654                     
655                       if (COMMON_CLOCK == 0 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_cdc_pntr
656                         // Synchronize the write pointer in rd_clk domain
657                         xpm_cdc_gray #(
658                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
659                           .INIT_SYNC_FF          (1),
660                           .WIDTH                 (WR_PNTR_WIDTH))
661                           
662                           wr_pntr_cdc_inst (
663                             .src_clk             (wr_clk),
664                             .src_in_bin          (wr_pntr),
665                             .dest_clk            (rd_clk),
666                             .dest_out_bin        (wr_pntr_rd_cdc));
667                     
668                         // Register the output of XPM_CDC_GRAY on read side
669                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
670                           wpr_gray_reg (rd_rst_i, rd_clk, wr_pntr_rd_cdc, wr_pntr_rd);
671                     
672                         // Synchronize the extended write pointer in rd_clk domain
673                         xpm_cdc_gray #(
674                           .DEST_SYNC_FF          (READ_MODE == 0 ? CDC_DEST_SYNC_FF : CDC_DEST_SYNC_FF+2),
675                           .INIT_SYNC_FF          (1),
676                           .WIDTH                 (WR_PNTR_WIDTH+1))
677                           wr_pntr_cdc_dc_inst (
678                             .src_clk             (wr_clk),
679                             .src_in_bin          (wr_pntr_ext),
680                             .dest_clk            (rd_clk),
681                             .dest_out_bin        (wr_pntr_rd_cdc_dc));
682                     
683                         // Register the output of XPM_CDC_GRAY on read side
684                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
685                           wpr_gray_reg_dc (rd_rst_i, rd_clk, wr_pntr_rd_cdc_dc, wr_pntr_rd_dc);
686                     
687                         // Synchronize the read pointer in wr_clk domain
688                         xpm_cdc_gray #(
689                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
690                           .INIT_SYNC_FF          (1),
691                           .WIDTH                 (RD_PNTR_WIDTH))
692                           rd_pntr_cdc_inst (
693                             .src_clk             (rd_clk),
694                             .src_in_bin          (rd_pntr),
695                             .dest_clk            (wr_clk),
696                             .dest_out_bin        (rd_pntr_wr_cdc));
697                     
698                         // Register the output of XPM_CDC_GRAY on write side
699                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
700                           rpw_gray_reg (wrst_busy, wr_clk, rd_pntr_wr_cdc, rd_pntr_wr);
701                     
702                         // Synchronize the read pointer, subtracted by the extra word read for FWFT, in wr_clk domain
703                         xpm_cdc_gray #(
704                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
705                           .INIT_SYNC_FF          (1),
706                           .WIDTH                 (RD_PNTR_WIDTH+1))
707                           rd_pntr_cdc_dc_inst (
708                             .src_clk             (rd_clk),
709                             .src_in_bin          (rd_pntr_ext-extra_words_fwft),
710                             .dest_clk            (wr_clk),
711                             .dest_out_bin        (rd_pntr_wr_cdc_dc));
712                     
713                         // Register the output of XPM_CDC_GRAY on write side
714                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
715                           rpw_gray_reg_dc (wrst_busy, wr_clk, rd_pntr_wr_cdc_dc, rd_pntr_wr_dc);
716                     
717                       end : gen_cdc_pntr
718                     
719                       if (RELATED_CLOCKS == 1) begin : gen_pntr_pf_rc
720                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
721                           rpw_rc_reg (wrst_busy, wr_clk, rd_pntr, rd_pntr_wr);
722                     
723                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
724                           wpr_rc_reg (rd_rst_i, rd_clk, wr_pntr, wr_pntr_rd);
725                     
726                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
727                           wpr_rc_reg_dc (rd_rst_i, rd_clk, wr_pntr_ext, wr_pntr_rd_dc);
728                     
729                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
730                           rpw_rc_reg_dc (wrst_busy, wr_clk, (rd_pntr_ext-extra_words_fwft), rd_pntr_wr_dc);
731                       end : gen_pntr_pf_rc
732                     
733                       if (COMMON_CLOCK == 0 || RELATED_CLOCKS == 1) begin : gen_pf_ic_rc
734                       
735                         assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_rd_en_i);
736                         assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr));
737                         assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ram_rd_en_i);
738                         assign leaving_aempty  = ((wr_pntr_rd_adj == rd_pntr_plus1));
739                       
740                         assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i);
741                         assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr_plus1));
742                         assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus3) &amp; ram_wr_en_i);
743                         assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus2));
744                       
745                         // Empty flag generation
746                         always @ (posedge rd_clk) begin
747                           if (rd_rst_i) begin
748                              ram_empty_i  &lt;= 1'b1;
749                           end else begin
750                              ram_empty_i  &lt;= going_empty | leaving_empty;
751                           end
752                         end
753                     
754                         if (EN_AE == 1) begin : gae_ic_std
755                           always @ (posedge rd_clk) begin
756                             if (rd_rst_i) begin
757                               ram_aempty_i &lt;= 1'b1;
758                             end else if (~ram_empty_i) begin
759                               ram_aempty_i &lt;= going_aempty | leaving_aempty;
760                             end
761                           end
762                         end : gae_ic_std
763                       
764                         // Full flag generation
765                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
766                           always @ (posedge wr_clk) begin
767                     	if (wrst_busy) begin
768                               ram_full_i      &lt;= FULL_RST_VAL;
769                               ram_full_n      &lt;= ~FULL_RST_VAL;
770                             end else begin
771                     	  if (clr_full) begin
772                                 ram_full_i    &lt;= 1'b0;
773                                 ram_full_n    &lt;= 1'b1;
774                     	  end else begin
775                                 ram_full_i    &lt;= going_full | leaving_full;
776                                 ram_full_n    &lt;= ~(going_full | leaving_full);
777                               end
778                             end
779                           end
780                         end : gen_full_rst_val
781                         else begin : ngen_full_rst_val
782                           always @ (posedge wr_clk) begin
783                     	if (wrst_busy) begin
784                               ram_full_i   &lt;= 1'b0;
785                               ram_full_n   &lt;= 1'b1;
786                     	end else begin
787                               ram_full_i   &lt;= going_full | leaving_full;
788                               ram_full_n   &lt;= ~(going_full | leaving_full);
789                     	end
790                           end
791                         end : ngen_full_rst_val
792                     
793                         if (EN_AF == 1) begin : gaf_ic
794                           always @ (posedge wr_clk) begin
795                     	if (wrst_busy) begin
796                               ram_afull_i  &lt;= FULL_RST_VAL;
797                             end else if (~rst) begin
798                     	  if (clr_full) begin
799                                 ram_afull_i  &lt;= 1'b0;
800                     	  end else if (~ram_full_i) begin
801                                 ram_afull_i  &lt;= going_afull | leaving_afull;
802                               end
803                             end
804                           end
805                         end : gaf_ic
806                     
807                       // synthesis translate_off
808                         `ifndef DISABLE_XPM_ASSERTIONS
809                         if (SIM_ASSERT_CHK == 1) begin: assert_wr_rd_en
810                           always @ (posedge rd_clk) begin
811                             assert (!$isunknown(rd_en)) else $warning (&quot;Input port 'rd_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'rd_en' has a valid value ('0' or '1')&quot;,$time);
812                           end
813                     
814                           always @ (posedge wr_clk) begin
815                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
816                           end
817                     
818                           always @ (posedge wr_clk) begin
819                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
820                           end
821                     
822                         end : assert_wr_rd_en
823                         `endif
824                       // synthesis translate_on
825                     
826                         // Programmable Full flag generation
827                         if (EN_PF == 1) begin : gpf_ic
828                           assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
829                           assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
830                       
831                           // PF carry generation
832                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i;
833                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i;
834                       
835                           // PF diff pointer generation
836                           always @ (posedge wr_clk) begin
837                             if (wrst_busy)
838                                diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
839                             else
840                                diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
841                           end
842                           assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
843                       
844                           always @ (posedge wr_clk) begin
845                             if (wrst_busy)
846                                prog_full_i  &lt;= FULL_RST_VAL;
847                             else if (clr_full)
848                                prog_full_i  &lt;= 1'b0;
849                             else if (~ram_full_i) begin
850                               if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
851                                 prog_full_i  &lt;= 1'b1;
852                               else
853                                 prog_full_i  &lt;= 1'b0;
854                             end else
855                               prog_full_i  &lt;= prog_full_i;
856                           end
857                         end : gpf_ic
858                     
859                         /*********************************************************
860                          * Programmable EMPTY flags
861                          *********************************************************/
862                         //Determine the Assert and Negate thresholds for Programmable Empty
863                         if (EN_PE == 1) begin : gpe_ic
864                      
865                           always @(posedge rd_clk) begin
866                             if (rd_rst_i) begin
867                               diff_pntr_pe      &lt;= 0;
868                               prog_empty_i       &lt;= 1'b1;
869                             end else begin
870                               if (ram_rd_en_i)
871                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr) - 1'h1;
872                               else
873                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr);
874                          
875                               if (~empty_i) begin
876                                 if (diff_pntr_pe &lt;= PE_THRESH_ADJ)
877                                   prog_empty_i &lt;= 1'b1;
878                                 else
879                                   prog_empty_i &lt;= 1'b0;
880                               end else
881                                 prog_empty_i   &lt;= prog_empty_i;
882                             end
883                           end
884                         end : gpe_ic
885                       end : gen_pf_ic_rc
886                     
887                       if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_pntr_flags_cc
888                         assign wr_pntr_rd = wr_pntr;
889                         assign rd_pntr_wr = rd_pntr;
890                         assign wr_pntr_rd_dc = wr_pntr_ext;
891                         assign rd_pntr_wr_dc = rd_pntr_ext-extra_words_fwft;
892                         assign write_allow  = ram_wr_en_i &amp; ~ram_full_i;
893                         assign read_allow   = ram_rd_en_i &amp; ~empty_i;
894                     
895                         if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
896                           assign ram_wr_en_pf  = ram_wr_en_i;
897                           assign ram_rd_en_pf  = ram_rd_en_i;
898                       
899                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
900                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
901                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
902                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
903                       
904                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
905                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
906                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
907                           assign leaving_afull  = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_rd_en_i &amp; ~ram_wr_en_i);
908                     
909                           assign write_only    = write_allow &amp; ~read_allow;
910                           assign read_only     = read_allow &amp; ~write_allow;
911                     
912                         end : wrp_eq_rdp
913                       
914                         if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
915                           assign wrp_gt_rdp_and_red = &amp;wr_pntr_rd[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0];
916                       
917                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
918                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red));
919                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
920                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ~ram_rd_en_i);
921                       
922                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
923                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
924                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
925                           assign leaving_afull  = (((rd_pntr_wr_adj == wr_pntr) | (rd_pntr_wr_adj == wr_pntr_plus1) | (rd_pntr_wr_adj == wr_pntr_plus2)) &amp; ram_rd_en_i);
926                       
927                           assign ram_wr_en_pf  = ram_wr_en_i &amp; wrp_gt_rdp_and_red;
928                           assign ram_rd_en_pf  = ram_rd_en_i;
929                     
930                           assign read_only     = read_allow &amp; (~(write_allow  &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0])));
931                           assign write_only    = write_allow &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0]) &amp; ~read_allow;
932                     
933                     
934                         end : wrp_gt_rdp
935                       
936                         if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
937                           assign wrp_lt_rdp_and_red = &amp;rd_pntr_wr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0];
938                       
939                           assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
940                           assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
941                           assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
942                           assign leaving_aempty  = (((wr_pntr_rd_adj == rd_pntr) | (wr_pntr_rd_adj == rd_pntr_plus1) | (wr_pntr_rd_adj == rd_pntr_plus2)) &amp; ram_wr_en_i);
943                       
944                           assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
945                           assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr) &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
946                           assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
947                           assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~ram_wr_en_i &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
948                       
949                           assign ram_wr_en_pf = ram_wr_en_i;
950                           assign ram_rd_en_pf = ram_rd_en_i &amp; wrp_lt_rdp_and_red;
951                     
952                           assign read_only   = read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0]) &amp; ~write_allow;
953                           assign write_only    = write_allow    &amp; (~(read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0])));
954                         end : wrp_lt_rdp
955                       
956                         // Empty flag generation
957                         always @ (posedge rd_clk) begin
958        1/1                if (rd_rst_i) begin
959        1/1                   ram_empty_i  &lt;= 1'b1;
960                           end else begin
961        1/1                   ram_empty_i  &lt;= going_empty | (~leaving_empty &amp; ram_empty_i);
962                           end
963                         end
964                     
965                         if (EN_AE == 1) begin : gae_cc_std
966                           always @ (posedge rd_clk) begin
967                             if (rd_rst_i) begin
968                               ram_aempty_i &lt;= 1'b1;
969                             end else begin
970                               ram_aempty_i &lt;= going_aempty | (~leaving_aempty &amp; ram_aempty_i);
971                             end
972                           end
973                         end : gae_cc_std
974                     
975                         // Full flag generation
976                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
977                           always @ (posedge wr_clk) begin
978                     	if (wrst_busy) begin
979                               ram_full_i   &lt;= FULL_RST_VAL;
980                               ram_full_n   &lt;= ~FULL_RST_VAL;
981                             end else begin
982                     	  if (clr_full) begin
983                                 ram_full_i   &lt;= 1'b0;
984                                 ram_full_n   &lt;= 1'b1;
985                     	  end else begin
986                                 ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
987                                 ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
988                               end
989                             end
990                           end
991                         end : gen_full_rst_val
992                         else begin : ngen_full_rst_val
993                           always @ (posedge wr_clk) begin
994        1/1          	if (wrst_busy) begin
995        1/1                    ram_full_i   &lt;= 1'b0;
996        1/1                    ram_full_n   &lt;= 1'b1;
997                     	end else begin
998        1/1                    ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
999        1/1                    ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
1000                    	end
1001                          end
1002                        end : ngen_full_rst_val
1003                    
1004                        if (EN_AF == 1) begin : gaf_cc
1005                          always @ (posedge wr_clk) begin
1006                    	if (wrst_busy) begin
1007                              ram_afull_i  &lt;= FULL_RST_VAL;
1008                            end else if (~rst) begin
1009                    	  if (clr_full) begin
1010                                ram_afull_i  &lt;= 1'b0;
1011                    	  end else begin
1012                                ram_afull_i  &lt;= going_afull | (~leaving_afull &amp; ram_afull_i);
1013                              end
1014                            end
1015                          end
1016                        end : gaf_cc
1017                        // Programmable Full flag generation
1018                        if ((WR_PNTR_WIDTH == RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_eq_rdp_pf_cc
1019                          if (EN_PF == 1) begin : gpf_cc_sym
1020                    
1021                            assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
1022                            assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
1023                      
1024                            // Delayed write/read enable for PF generation
1025                            always @ (posedge wr_clk) begin
1026       1/1                    if (wrst_busy) begin
1027       1/1                       ram_wr_en_pf_q   &lt;= 1'b0;
1028       1/1                       ram_rd_en_pf_q   &lt;= 1'b0;
1029                              end else begin
1030       1/1                       ram_wr_en_pf_q   &lt;= ram_wr_en_pf;
1031       1/1                       ram_rd_en_pf_q   &lt;= ram_rd_en_pf;
1032                              end
1033                            end
1034                      
1035                            // PF carry generation
1036                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i &amp; ~ram_rd_en_pf;
1037                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i &amp; ~ram_rd_en_pf;
1038                      
1039                            // PF diff pointer generation
1040                            always @ (posedge wr_clk) begin
1041       1/1                    if (wrst_busy)
1042       1/1                       diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1043                              else
1044       1/1                       diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
1045                            end
1046                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1047                      
1048                            always @ (posedge wr_clk) begin
1049       1/1                    if (wrst_busy)
1050       1/1                       prog_full_i  &lt;= FULL_RST_VAL;
1051       1/1                    else if (clr_full)
1052       1/1                       prog_full_i  &lt;= 1'b0;
1053       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ram_wr_en_pf_q &amp; ~ram_rd_en_pf_q)
1054       1/1                       prog_full_i  &lt;= 1'b1;
1055       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ~ram_wr_en_pf_q &amp; ram_rd_en_pf_q)
1056       <font color = "red">0/1     ==>               prog_full_i  &lt;= 1'b0;</font>
1057                              else
1058       1/1                       prog_full_i  &lt;= prog_full_i;
1059                            end
1060                          end : gpf_cc_sym
1061                    
1062                          if (EN_PE == 1) begin : gpe_cc_sym
1063                            always @(posedge rd_clk) begin
1064       1/1                    if (rd_rst_i) begin
1065       1/1                      read_only_q    &lt;= 1'b0;
1066       1/1                      write_only_q   &lt;= 1'b0;
1067       1/1                      diff_pntr_pe   &lt;= 0;
1068                              end 
1069                              else begin
1070       1/1                      read_only_q  &lt;= read_only;
1071       1/1                      write_only_q &lt;= write_only;
1072                                // Add 1 to the difference pointer value when write or both write &amp; read or no write &amp; read happen.
1073       1/1                      if (read_only)
1074       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr - 1;
1075                                else
1076       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr;
1077                              end
1078                            end
1079                      
1080                            always @(posedge rd_clk) begin
1081       1/1                    if (rd_rst_i)
1082       1/1                      prog_empty_i  &lt;= 1'b1;
1083                              else begin
1084       1/1                      if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; read_only_q)
1085       <font color = "red">0/1     ==>                prog_empty_i &lt;= 1'b1;</font>
1086       1/1                      else if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; write_only_q)
1087       1/1                        prog_empty_i &lt;= 1'b0;
1088                                else
1089       1/1                        prog_empty_i &lt;= prog_empty_i;
1090                              end
1091                            end
1092                          end : gpe_cc_sym
1093                        end : wrp_eq_rdp_pf_cc
1094                    
1095                        if ((WR_PNTR_WIDTH != RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_neq_rdp_pf_cc
1096                          if (EN_PF == 1) begin : gpf_cc_asym
1097                            // PF diff pointer generation
1098                            always @ (posedge wr_clk) begin
1099                              if (wrst_busy)
1100                                 diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1101                              else if (~ram_full_i)
1102                                 diff_pntr_pf_q[WR_PNTR_WIDTH:1]  &lt;= wr_pntr + ~rd_pntr_wr_adj + 1;
1103                            end
1104                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1105                            always @ (posedge wr_clk) begin
1106                              if (wrst_busy)
1107                                 prog_full_i  &lt;= FULL_RST_VAL;
1108                              else if (clr_full)
1109                                 prog_full_i  &lt;= 1'b0;
1110                              else if (~ram_full_i) begin
1111                                if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
1112                                   prog_full_i  &lt;= 1'b1;
1113                                else if (diff_pntr_pf &lt; PF_THRESH_ADJ)
1114                                   prog_full_i  &lt;= 1'b0;
1115                                else
1116                                   prog_full_i  &lt;= prog_full_i;
1117                              end
1118                            end
1119                          end : gpf_cc_asym
1120                          if (EN_PE == 1) begin : gpe_cc_asym
1121                            // Programmanble Empty flag Generation
1122                            // Diff pointer Generation
1123                            localparam [RD_PNTR_WIDTH-1 : 0] DIFF_MAX_RD = {RD_PNTR_WIDTH{1'b1}};
1124                            wire [RD_PNTR_WIDTH-1:0] diff_pntr_pe_max;
1125                            wire                     carry;
1126                            reg  [RD_PNTR_WIDTH : 0] diff_pntr_pe_asym = 'b0;
1127                            wire [RD_PNTR_WIDTH : 0] wr_pntr_rd_adj_asym;
1128                            wire [RD_PNTR_WIDTH : 0] rd_pntr_asym;
1129                            reg                      full_reg;
1130                            reg                      rst_full_ff_reg1;
1131                            reg                      rst_full_ff_reg2;
1132                      
1133                            assign diff_pntr_pe_max = DIFF_MAX_RD;
1134                            assign wr_pntr_rd_adj_asym[RD_PNTR_WIDTH:0] = {wr_pntr_rd_adj,1'b1};
1135                            assign rd_pntr_asym[RD_PNTR_WIDTH:0] = {~rd_pntr,1'b1};
1136                      
1137                            always @(posedge rd_clk ) begin
1138                              if (rd_rst_i) begin
1139                                diff_pntr_pe_asym    &lt;= 0;
1140                                full_reg             &lt;= 0;
1141                                rst_full_ff_reg1     &lt;= 1;
1142                                rst_full_ff_reg2     &lt;= 1;
1143                                diff_pntr_pe_reg1    &lt;= 0;
1144                              end else begin
1145                                diff_pntr_pe_asym &lt;= wr_pntr_rd_adj_asym + rd_pntr_asym;
1146                                full_reg          &lt;= ram_full_i;
1147                                rst_full_ff_reg1  &lt;= FULL_RST_VAL;
1148                                rst_full_ff_reg2  &lt;= rst_full_ff_reg1;
1149                              end
1150                            end
1151                            wire [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_i;
1152                            assign carry = (~(|(diff_pntr_pe_asym [RD_PNTR_WIDTH : 1])));
1153                            assign diff_pntr_pe_i = (full_reg &amp;&amp; ~rst_d2 &amp;&amp; carry ) ? diff_pntr_pe_max : diff_pntr_pe_asym[RD_PNTR_WIDTH:1];
1154                        
1155                            always @(posedge rd_clk) begin
1156                              if (rd_rst_i)
1157                                prog_empty_i  &lt;= 1'b1;
1158                              else begin
1159                                if (diff_pntr_pe_i &lt;= PE_THRESH_ADJ)
1160                                  prog_empty_i &lt;= 1'b1;
1161                                else if (diff_pntr_pe_i &gt; PE_THRESH_ADJ)
1162                                  prog_empty_i &lt;= 1'b0;
1163                                else
1164                                  prog_empty_i &lt;= prog_empty_i;
1165                              end
1166                            end
1167                          end : gpe_cc_asym
1168                        end : wrp_neq_rdp_pf_cc
1169                    
1170                      end : gen_pntr_flags_cc
1171                    
1172                      if (READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1) begin : gen_regce_std
1173                        xpm_reg_pipe_bit #(FIFO_READ_LATENCY-1, 0)
1174                          regce_pipe_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_regce_pipe);
1175                      end : gen_regce_std
1176                      if (!(READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1)) begin : gnen_regce_std
1177                        assign ram_regce_pipe = 1'b0;
1178                      end : gnen_regce_std
1179                    
1180                      if (!((READ_MODE == 1 || READ_MODE == 2)&amp;&amp; FIFO_MEMORY_TYPE != 4)) begin : gn_fwft
1181                       assign invalid_state = 1'b0;
1182                      end : gn_fwft
1183                      //if (READ_MODE == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1184                      if (READ_MODE != 0 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1185                      // First word fall through logic
1186                    
1187                       //localparam invalid             = 0;
1188                       //localparam stage1_valid        = 2;
1189                       //localparam stage2_valid        = 1;
1190                       //localparam both_stages_valid   = 3;
1191                    
1192                       //reg  [1:0] curr_fwft_state = invalid;
1193                       //reg  [1:0] next_fwft_state;// = invalid;
1194                       wire next_fwft_state_d1;
1195                       assign invalid_state = ~|curr_fwft_state;
1196                       assign valid_fwft = next_fwft_state_d1;
1197                       assign ram_valid_fwft = curr_fwft_state[1];
1198                    
1199                        xpm_fifo_reg_bit #(0)
1200                          next_state_d1_inst (1'b0, rd_clk, next_fwft_state[0], next_fwft_state_d1);
1201                       //FSM : To generate the enable, clock enable for xpm_memory and to generate
1202                       //empty signal
1203                       //FSM : Next state Assignment
1204                         if (READ_MODE == 1) begin : gen_fwft_ns
1205                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1206                           case (curr_fwft_state)
1207                             invalid: begin
1208                               if (~ram_empty_i)
1209                                  next_fwft_state     = stage1_valid;
1210                               else
1211                                  next_fwft_state     = invalid;
1212                               end
1213                             stage1_valid: begin
1214                               if (ram_empty_i)
1215                                  next_fwft_state     = stage2_valid;
1216                               else
1217                                  next_fwft_state     = both_stages_valid;
1218                               end
1219                             stage2_valid: begin
1220                               if (ram_empty_i &amp;&amp; rd_en)
1221                                  next_fwft_state     = invalid;
1222                               else if (~ram_empty_i &amp;&amp; rd_en)
1223                                  next_fwft_state     = stage1_valid;
1224                               else if (~ram_empty_i &amp;&amp; ~rd_en)
1225                                  next_fwft_state     = both_stages_valid;
1226                               else
1227                                  next_fwft_state     = stage2_valid;
1228                               end
1229                             both_stages_valid: begin
1230                               if (ram_empty_i &amp;&amp; rd_en)
1231                                  next_fwft_state     = stage2_valid;
1232                               else if (~ram_empty_i &amp;&amp; rd_en)
1233                                  next_fwft_state     = both_stages_valid;
1234                               else
1235                                  next_fwft_state     = both_stages_valid;
1236                               end
1237                             default: next_fwft_state    = invalid;
1238                           endcase
1239                         end
1240                         end : gen_fwft_ns
1241                         if (READ_MODE == 2) begin : gen_fwft_ns_ll
1242                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1243                           case (curr_fwft_state)
1244                             invalid: begin
1245                               if (~ram_empty_i)
1246                                  next_fwft_state     = stage1_valid;
1247                               else
1248                                  next_fwft_state     = invalid;
1249                               end
1250                             stage1_valid: begin
1251                               if (ram_empty_i &amp;&amp; rd_en)
1252                                  next_fwft_state     = invalid;
1253                               else
1254                                  next_fwft_state     = stage1_valid;
1255                               end
1256                             default: next_fwft_state    = invalid;
1257                           endcase
1258                         end
1259                         end : gen_fwft_ns_ll
1260                         // FSM : current state assignment
1261                         always @ (posedge rd_clk) begin
1262                           if (rd_rst_i)
1263                              curr_fwft_state  &lt;= invalid;
1264                           else
1265                              curr_fwft_state  &lt;= next_fwft_state;
1266                         end
1267                     
1268                         reg ram_regout_en;
1269                    
1270                         // FSM(output assignments) : clock enable generation for xpm_memory
1271                         if (READ_MODE == 1) begin : gen_fwft_ro
1272                         always @(curr_fwft_state or rd_en) begin
1273                           case (curr_fwft_state)
1274                             invalid:           ram_regout_en = 1'b0;
1275                             stage1_valid:      ram_regout_en = 1'b1;
1276                             stage2_valid:      ram_regout_en = 1'b0;
1277                             both_stages_valid: ram_regout_en = rd_en;
1278                             default:           ram_regout_en = 1'b0;
1279                           endcase
1280                         end
1281                         end : gen_fwft_ro
1282                         if (READ_MODE == 2) begin : gen_fwft_ro_ll
1283                         always @(curr_fwft_state or rd_en or ram_empty_i or fe_of_empty) begin
1284                           case (curr_fwft_state)
1285                             invalid:           ram_regout_en = fe_of_empty;
1286                             stage1_valid:      ram_regout_en = rd_en &amp; !ram_empty_i;
1287                             default:           ram_regout_en = 1'b0;
1288                           endcase
1289                         end
1290                         end : gen_fwft_ro_ll
1291                    
1292                         // FSM(output assignments) : rd_en (enable) signal generation for xpm_memory
1293                         if (READ_MODE == 1) begin : gen_fwft_re
1294                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1295                           case (curr_fwft_state)
1296                             invalid :
1297                               if (~ram_empty_i)
1298                                 rd_en_fwft = 1'b1;
1299                               else
1300                                 rd_en_fwft = 1'b0;
1301                             stage1_valid :
1302                               if (~ram_empty_i)
1303                                 rd_en_fwft = 1'b1;
1304                               else
1305                                 rd_en_fwft = 1'b0;
1306                             stage2_valid :
1307                               if (~ram_empty_i)
1308                                 rd_en_fwft = 1'b1;
1309                               else
1310                                 rd_en_fwft = 1'b0;
1311                             both_stages_valid :
1312                               if (~ram_empty_i &amp;&amp; rd_en)
1313                                 rd_en_fwft = 1'b1;
1314                               else
1315                                 rd_en_fwft = 1'b0;
1316                             default :
1317                               rd_en_fwft = 1'b0;
1318                           endcase
1319                         end
1320                         end : gen_fwft_re
1321                         if (READ_MODE == 2) begin : gen_fwft_re_ll
1322                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1323                           case (curr_fwft_state)
1324                             invalid :
1325                               if (~ram_empty_i)
1326                                 rd_en_fwft = 1'b1;
1327                               else
1328                                 rd_en_fwft = 1'b0;
1329                             stage1_valid :
1330                               if (~ram_empty_i &amp;&amp; rd_en)
1331                                 rd_en_fwft = 1'b1;
1332                               else
1333                                 rd_en_fwft = 1'b0;
1334                             default :
1335                               rd_en_fwft = 1'b0;
1336                           endcase
1337                         end
1338                         end : gen_fwft_re_ll
1339                         // assingment to control regce xpm_memory
1340                         assign ram_regce = ram_regout_en;
1341                    
1342                         reg going_empty_fwft;
1343                         reg leaving_empty_fwft;
1344                    
1345                         if (READ_MODE == 1) begin : gen_fwft_ge
1346                         always @(curr_fwft_state or rd_en) begin
1347                           case (curr_fwft_state)
1348                             stage2_valid : going_empty_fwft = rd_en;
1349                             default      : going_empty_fwft = 1'b0;
1350                           endcase
1351                         end
1352                    
1353                         always @(curr_fwft_state or rd_en) begin
1354                           case (curr_fwft_state)
1355                             stage1_valid : leaving_empty_fwft = 1'b1;
1356                             default      : leaving_empty_fwft = 1'b0;
1357                           endcase
1358                         end
1359                         end : gen_fwft_ge
1360                         if (READ_MODE == 2) begin : gen_fwft_ge_ll
1361                         always @(curr_fwft_state or rd_en or ram_empty_i) begin
1362                           case (curr_fwft_state)
1363                             stage1_valid : going_empty_fwft = rd_en &amp; ram_empty_i;
1364                             default      : going_empty_fwft = 1'b0;
1365                           endcase
1366                         end
1367                    
1368                         always @ (posedge rd_clk) begin
1369                           if (rd_rst_i) begin
1370                              ram_empty_i_d1  &lt;= 1'b1;
1371                           end else begin
1372                              ram_empty_i_d1  &lt;= ram_empty_i;
1373                           end
1374                         end
1375                         assign fe_of_empty = ram_empty_i_d1 &amp; !ram_empty_i;
1376                    
1377                         always @(curr_fwft_state or fe_of_empty) begin
1378                           case (curr_fwft_state)
1379                             invalid      : leaving_empty_fwft = fe_of_empty;
1380                             stage1_valid : leaving_empty_fwft = 1'b1;
1381                             default      : leaving_empty_fwft = 1'b0;
1382                           endcase
1383                         end
1384                         end : gen_fwft_ge_ll
1385                    
1386                         // fwft empty signal generation 
1387                         always @ (posedge rd_clk) begin
1388                           if (rd_rst_i) begin
1389                             empty_fwft_i     &lt;= 1'b1;
1390                             empty_fwft_fb    &lt;= 1'b1;
1391                           end else begin
1392                             empty_fwft_i     &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1393                             empty_fwft_fb    &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1394                           end
1395                         end
1396                    
1397                         if (EN_AE == 1) begin : gae_fwft
1398                           reg going_aempty_fwft;
1399                           reg leaving_aempty_fwft;
1400                    
1401                           if (READ_MODE == 1) begin : gen_fwft_ae
1402                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1403                               case (curr_fwft_state)
1404                                 both_stages_valid : going_aempty_fwft = rd_en &amp; ram_empty_i;
1405                                 default      : going_aempty_fwft = 1'b0;
1406                               endcase
1407                             end
1408                           end : gen_fwft_ae
1409                           if (READ_MODE == 2) begin : gen_fwft_ae_ll
1410                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1411                               case (curr_fwft_state)
1412                                 stage1_valid : going_aempty_fwft = !rd_en &amp; ram_empty_i;
1413                                 default      : going_aempty_fwft = 1'b0;
1414                               endcase
1415                             end
1416                           end : gen_fwft_ae_ll
1417                    
1418                           always @(curr_fwft_state or rd_en or ram_empty_i) begin
1419                             case (curr_fwft_state)
1420                               stage1_valid : leaving_aempty_fwft = ~ram_empty_i;
1421                               stage2_valid : leaving_aempty_fwft = ~(rd_en | ram_empty_i);
1422                               default      : leaving_aempty_fwft = 1'b0;
1423                             endcase
1424                           end
1425                    
1426                           always @ (posedge rd_clk) begin
1427                             if (rd_rst_i) begin
1428                               aempty_fwft_i    &lt;= 1'b1;
1429                             end else begin
1430                               aempty_fwft_i    &lt;= going_aempty_fwft | (~ leaving_aempty_fwft &amp; aempty_fwft_i);
1431                             end
1432                           end
1433                         end : gae_fwft
1434                    
1435                         if (EN_DVLD == 1) begin : gdvld_fwft
1436                           always @ (posedge rd_clk) begin
1437                             if (rd_rst_i) begin
1438                               data_valid_fwft  &lt;= 1'b0;
1439                             end else begin
1440                               data_valid_fwft  &lt;= ~(going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb));
1441                             end
1442                           end
1443                         end : gdvld_fwft
1444                    
1445                        xpm_fifo_reg_bit #(0)
1446                          empty_fwft_d1_inst (1'b0, rd_clk, leaving_empty_fwft, empty_fwft_d1);
1447                    
1448                        wire ge_fwft_d1;
1449                        xpm_fifo_reg_bit #(0)
1450                          ge_fwft_d1_inst (1'b0, rd_clk, going_empty_fwft, ge_fwft_d1);
1451                    
1452                        wire count_up  ;
1453                        wire count_down;
1454                        wire count_en  ;
1455                        wire count_rst ;
1456                        assign count_up   = (next_fwft_state == 2'b10 &amp;&amp; ~|curr_fwft_state) | (curr_fwft_state == 2'b10 &amp;&amp; &amp;next_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; &amp;next_fwft_state);
1457                        assign count_down = (next_fwft_state == 2'b01 &amp;&amp; &amp;curr_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; ~|next_fwft_state);
1458                        assign count_en   = count_up | count_down;
1459                        assign count_rst  = (rd_rst_i | (~|curr_fwft_state &amp; ~|next_fwft_state));
1460                    
1461                        xpm_counter_updn # (2, 0)
1462                          rdpp1_inst (count_rst, rd_clk, count_en, count_up, count_down, extra_words_fwft);
1463                    
1464                     
1465                      end : gen_fwft
1466                    
1467                      if (READ_MODE == 0) begin : ngen_fwft
1468                        assign le_fwft_re       = 1'b0;
1469                        assign le_fwft_fe       = 1'b0;
1470                        assign extra_words_fwft = 2'h0;
1471                      end : ngen_fwft
1472                    
1473                      // output data bus assignment
1474                      if (FG_EQ_ASYM_DOUT == 0) begin : nfg_eq_asym_dout
1475                        assign dout  = dout_i;
1476                      end : nfg_eq_asym_dout
1477                    
1478                      // Overflow and Underflow flag generation
1479                      if (EN_UF == 1) begin : guf
1480                        always @ (posedge rd_clk) begin
1481       1/1                underflow_i &lt;=  (rd_rst_i | empty_i) &amp; rd_en;
1482                        end
1483                        assign underflow   = underflow_i;
1484                      end : guf
1485                      if (EN_UF == 0) begin : gnuf
1486                        assign underflow   = 1'b0;
1487                      end : gnuf
1488                    
1489                      if (EN_OF == 1) begin : gof
1490                        always @ (posedge wr_clk) begin
1491       1/1               overflow_i  &lt;=  (wrst_busy | rst_d1 | ram_full_i) &amp; wr_en;
1492                        end
1493                        assign overflow    = overflow_i;
1494                      end : gof
1495                      if (EN_OF == 0) begin : gnof
1496                        assign overflow    = 1'b0;
1497                      end : gnof
1498                    
1499                      // -------------------------------------------------------------------------------------------------------------------
1500                      // Write Data Count for Independent Clocks FIFO
1501                      // -------------------------------------------------------------------------------------------------------------------
1502                      if (EN_WDC == 1) begin : gwdc
1503                        reg  [WR_DC_WIDTH_EXT-1:0] wr_data_count_i;
1504                        wire [WR_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr;
1505                        assign diff_wr_rd_pntr = wr_pntr_ext-rd_pntr_wr_adj_dc;
1506                        always @ (posedge wr_clk) begin
1507       1/1                if (wrst_busy)
1508       1/1                   wr_data_count_i   &lt;= {WR_DC_WIDTH_EXT{1'b0}};
1509                          else
1510       1/1                   wr_data_count_i  &lt;= diff_wr_rd_pntr;
1511                        end
1512                        assign wr_data_count = wr_data_count_i[WR_DC_WIDTH_EXT-1:WR_DC_WIDTH_EXT-WR_DATA_COUNT_WIDTH];
1513                      end : gwdc
1514                      if (EN_WDC == 0) begin : gnwdc
1515                        assign wr_data_count = {WR_DC_WIDTH_EXT{1'b0}};
1516                      end : gnwdc
1517                    
1518                      // -------------------------------------------------------------------------------------------------------------------
1519                      // Read Data Count for Independent Clocks FIFO
1520                      // -------------------------------------------------------------------------------------------------------------------
1521                      if (EN_RDC == 1) begin : grdc
1522                        reg  [RD_DC_WIDTH_EXT-1:0] rd_data_count_i;
1523                        wire [RD_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr_rdc;
1524                        assign diff_wr_rd_pntr_rdc = wr_pntr_rd_adj_dc-rd_pntr_ext+extra_words_fwft;
1525                        always @ (posedge rd_clk) begin
1526       1/1                if (rd_rst_i | invalid_state)
1527       1/1                   rd_data_count_i   &lt;= {RD_DC_WIDTH_EXT{1'b0}};
1528                          else
1529       1/1                   rd_data_count_i  &lt;= diff_wr_rd_pntr_rdc;
1530                        end
1531                        assign rd_data_count = rd_data_count_i[RD_DC_WIDTH_EXT-1:RD_DC_WIDTH_EXT-RD_DATA_COUNT_WIDTH];
1532                      end : grdc
1533                      if (EN_RDC == 0) begin : gnrdc
1534                        assign rd_data_count = {RD_DC_WIDTH_EXT{1'b0}};
1535                      end : gnrdc
1536                    
1537                      endgenerate
1538                    
1539                      // -------------------------------------------------------------------------------------------------------------------
1540                      // Simulation constructs
1541                      // -------------------------------------------------------------------------------------------------------------------
1542                      // synthesis translate_off
1543                    
1544                     `ifndef DISABLE_XPM_ASSERTIONS  
1545                      initial begin
1546       2/2            #1;
1547       1/1              if (SIM_ASSERT_CHK == 1)
1548                        `ifdef OBSOLETE
1549                          $warning(&quot;Vivado Simulator does not currently support the SystemVerilog Assertion syntax used within XPM_FIFO.  \
1550                    Messages related to potential misuse will not be reported.&quot;);
1551                        `else
1552       <font color = "red">0/1     ==>        $warning(&quot;SIM_ASSERT_CHK (%0d) specifies simulation message reporting, messages related to potential misuse \</font>
                        MISSING_ELSE
</pre>
<hr>
<a name="Cond"></a>
Cond Coverage for Module : <a href="mod18.html" >\XPM.xpm_fifo_base </a><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">Conditions</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="s6"><td class="lf">Logical</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1084
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; read_only_q)
             ---------------1---------------    -----2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1086
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; write_only_q)
             ---------------1---------------    ------2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="Toggle"></a>
Toggle Coverage for Module : <a href="mod18.html" >\XPM.xpm_fifo_base </a><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s4">
<td>Totals</td>
<td class="rt">129</td>
<td class="rt">53</td>
<td class="rt">41.09 </td>
</tr><tr class="s7">
<td>Total Bits</td>
<td class="rt">864</td>
<td class="rt">614</td>
<td class="rt">71.06 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 0->1</td>
<td class="rt">432</td>
<td class="rt">307</td>
<td class="rt">71.06 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 1->0</td>
<td class="rt">432</td>
<td class="rt">307</td>
<td class="rt">71.06 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s3">
<td>Ports</td>
<td class="rt">27</td>
<td class="rt">9</td>
<td class="rt">33.33 </td>
</tr><tr class="s8">
<td>Port Bits</td>
<td class="rt">178</td>
<td class="rt">147</td>
<td class="rt">82.58 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 0->1</td>
<td class="rt">89</td>
<td class="rt">72</td>
<td class="rt">80.90 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 1->0</td>
<td class="rt">89</td>
<td class="rt">75</td>
<td class="rt">84.27 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s4">
<td>Signals</td>
<td class="rt">102</td>
<td class="rt">44</td>
<td class="rt">43.14 </td>
</tr><tr class="s6">
<td>Signal Bits</td>
<td class="rt">686</td>
<td class="rt">467</td>
<td class="rt">68.08 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">343</td>
<td class="rt">235</td>
<td class="rt">68.51 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">343</td>
<td class="rt">232</td>
<td class="rt">67.64 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>sleep</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>rst</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>wr_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>wr_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>din[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_data_count</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_ack</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rd_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>dout[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>empty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_empty</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_data_count</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>data_valid</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>injectsbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>injectdbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>dbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>curr_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>next_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus2[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus3[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_plus1_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_inv_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pf_q[6:1]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>invalid_state</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>going_aempty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_aempty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_empty_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_aempty_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>going_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>prog_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_afull_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_ack_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_en_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce_pipe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dout_i[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>aempty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_fwft_fb</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>overflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>underflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_vld_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_gt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_lt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_wr_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe_reg1[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe_reg2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>prog_empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_empty_i_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>fe_of_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_en_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_d2</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rst_d1</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rst_d2</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>clr_full</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extra_words_fwft[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gen_sdpram.rst_int</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.rd_data_count_i[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.rd_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_275'>
<a name="inst_tag_275_Line"></a>
<b>Line Coverage for Instance : <a href="mod18.html#inst_tag_275" >AdaptedSharpener.fifo.lineBuffer_4.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">TOTAL</td><td></td><td>142</td><td>86</td><td>60.56</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>126</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">ROUTINE</td><td>304</td><td>5</td><td>4</td><td>80.00</td></tr>
<tr class="s3"><td class="lf">INITIAL</td><td>314</td><td>81</td><td>29</td><td>35.80</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>958</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>994</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1026</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1041</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1049</td><td>9</td><td>8</td><td>88.89</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1064</td><td>9</td><td>9</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1081</td><td>7</td><td>6</td><td>85.71</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1481</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1491</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1507</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1526</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">INITIAL</td><td>1546</td><td>4</td><td>3</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
125                       begin 
126        1/1              value = value-1;
127        1/1              for (clog2=0; value&gt;0; clog2=clog2+1)
128        1/1                value = value&gt;&gt;1;
129                         end 
130                       endfunction
131                       // Function to convert ASCII value to binary 
132                       function [3:0] str2bin;
133                         input [7:0] str_val_ascii;
134                           if((str_val_ascii == 8'h30) || (str_val_ascii == 8'h31) || 
135                              (str_val_ascii == 8'h32) || (str_val_ascii == 8'h33) || 
136                              (str_val_ascii == 8'h34) || (str_val_ascii == 8'h35) || 
137                              (str_val_ascii == 8'h36) || (str_val_ascii == 8'h37) || 
138                              (str_val_ascii == 8'h38) || (str_val_ascii == 8'h39) || 
139                              (str_val_ascii == 8'h41) || (str_val_ascii == 8'h42) || 
140                              (str_val_ascii == 8'h43) || (str_val_ascii == 8'h44) || 
141                              (str_val_ascii == 8'h45) || (str_val_ascii == 8'h46) || 
142                              (str_val_ascii == 8'h61) || (str_val_ascii == 8'h62) || 
143                              (str_val_ascii == 8'h63) || (str_val_ascii == 8'h64) || 
144                              (str_val_ascii == 8'h65) || (str_val_ascii == 8'h66) || 
145                              (str_val_ascii == 8'h00)) begin
146                              if (!str_val_ascii[6])
147                                 str2bin = str_val_ascii[3:0];
148                              else begin
149                                str2bin [3] = 1'b1;
150                                str2bin [2] = str_val_ascii[2] | (str_val_ascii[1] &amp; str_val_ascii[0]);
151                                str2bin [1] = str_val_ascii[0] ^ str_val_ascii[1];
152                                str2bin [0] = !str_val_ascii[0];
153                              end
154                           end
155                           else
156                             $error(&quot;Found Invalid character while parsing the string, please cross check the value specified for either READ_RESET_VALUE_A|B or MEMORY_INIT_PARAM (if initialization of memory through parameter is used). XPM_MEMORY supports strings (hex) that contains characters 0-9, A-F and a-f.&quot;);
157                       endfunction
158                       // Function that parses the complete reset value string
159                       function logic [15:0] hstr2bin;
160                         input [16*8-1 : 0] hstr_val;
161                         integer rst_loop_a;
162                         localparam integer  rsta_loop_iter  =  16;
163                         logic [rsta_loop_iter-1 : 0] rst_val_conv_a_i;
164                         for (rst_loop_a=1; rst_loop_a &lt;= rsta_loop_iter/4; rst_loop_a = rst_loop_a+1) begin
165                           rst_val_conv_a_i[(rst_loop_a*4)-1 -: 4] =  str2bin(hstr_val[(rst_loop_a*8)-1 -: 8]);
166                         end
167                         return rst_val_conv_a_i[15:0];
168                       endfunction
169                     
170                     
171                       localparam invalid             = 0;
172                       localparam stage1_valid        = 2;
173                       localparam stage2_valid        = 1;
174                       localparam both_stages_valid   = 3;
175                     
176                       reg  [1:0] curr_fwft_state = invalid;
177                       reg  [1:0] next_fwft_state;// = invalid;
178                     
179                     
180                     
181                       localparam FIFO_MEM_TYPE   = FIFO_MEMORY_TYPE;
182                       localparam RD_MODE         = READ_MODE;
183                       localparam ENABLE_ECC      = (ECC_MODE == 1) ? 3 : 0;
184                       localparam FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH;
185                       localparam FIFO_SIZE       = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH;
186                       localparam WR_WIDTH_LOG    = clog2(WRITE_DATA_WIDTH);
187                       localparam WR_DEPTH_LOG    = clog2(FIFO_WRITE_DEPTH);
188                       localparam WR_PNTR_WIDTH   = clog2(FIFO_WRITE_DEPTH);
189                       localparam RD_PNTR_WIDTH   = clog2(FIFO_READ_DEPTH);
190                       localparam FULL_RST_VAL    = FULL_RESET_VALUE == 0 ? 1'b0 : 1'b1;
191                       localparam WR_RD_RATIO     = (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) ? (WR_PNTR_WIDTH-RD_PNTR_WIDTH) : 0;
192                       localparam READ_MODE_LL    = (READ_MODE == 0) ? 0 : 1;
193                       localparam PF_THRESH_ADJ   = (READ_MODE == 0) ? PROG_FULL_THRESH :
194                                                    PROG_FULL_THRESH - (2*(2**WR_RD_RATIO));
195                       localparam PE_THRESH_ADJ   = (READ_MODE_LL == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) ? PROG_EMPTY_THRESH - 2'h2 : PROG_EMPTY_THRESH;
196                     
197                       localparam PF_THRESH_MIN   = 3+(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1))+(COMMON_CLOCK?0:CDC_DEST_SYNC_FF);
198                       localparam PF_THRESH_MAX   = (FIFO_WRITE_DEPTH-3)-(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1));
199                       localparam PE_THRESH_MIN   = 3+(READ_MODE_LL*2);
200                       localparam PE_THRESH_MAX   = (FIFO_READ_DEPTH-3)-(READ_MODE_LL*2);
201                       localparam WR_DC_WIDTH_EXT = clog2(FIFO_WRITE_DEPTH)+1;
202                       localparam RD_DC_WIDTH_EXT = clog2(FIFO_READ_DEPTH)+1;
203                       localparam RD_LATENCY      = (READ_MODE == 2) ? 1 : (READ_MODE == 1) ? 2 : FIFO_READ_LATENCY;
204                       localparam WIDTH_RATIO     = (READ_DATA_WIDTH &gt; WRITE_DATA_WIDTH) ? (READ_DATA_WIDTH/WRITE_DATA_WIDTH) : (WRITE_DATA_WIDTH/READ_DATA_WIDTH);
205                     
206                       localparam [15:0] EN_ADV_FEATURE = hstr2bin(USE_ADV_FEATURES);
207                     
208                       localparam EN_OF           = EN_ADV_FEATURE[0];  //EN_ADV_FLAGS_WR[0] ? 1 : 0;
209                       localparam EN_PF           = EN_ADV_FEATURE[1];  //EN_ADV_FLAGS_WR[1] ? 1 : 0;
210                       localparam EN_WDC          = EN_ADV_FEATURE[2];  //EN_ADV_FLAGS_WR[2] ? 1 : 0;
211                       localparam EN_AF           = EN_ADV_FEATURE[3];  //EN_ADV_FLAGS_WR[3] ? 1 : 0;
212                       localparam EN_WACK         = EN_ADV_FEATURE[4];  //EN_ADV_FLAGS_WR[4] ? 1 : 0;
213                       localparam FG_EQ_ASYM_DOUT = EN_ADV_FEATURE[5];  //EN_ADV_FLAGS_WR[5] ? 1 : 0;
214                       localparam EN_UF           = EN_ADV_FEATURE[8];  //EN_ADV_FLAGS_RD[0] ? 1 : 0;
215                       localparam EN_PE           = EN_ADV_FEATURE[9];  //EN_ADV_FLAGS_RD[1] ? 1 : 0;
216                       localparam EN_RDC          = EN_ADV_FEATURE[10]; //EN_ADV_FLAGS_RD[2] ? 1 : 0;
217                       localparam EN_AE           = EN_ADV_FEATURE[11]; //EN_ADV_FLAGS_RD[3] ? 1 : 0;
218                       localparam EN_DVLD         = EN_ADV_FEATURE[12]; //EN_ADV_FLAGS_RD[4] ? 1 : 0;
219                     
220                       wire                       wrst_busy;
221                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr;
222                       wire [WR_PNTR_WIDTH:0]     wr_pntr_ext;
223                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd_cdc;
224                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_cdc_dc;
225                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd;
226                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_dc;
227                       wire [WR_PNTR_WIDTH-1:0]   rd_pntr_wr_adj;
228                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_dc;
229                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus1;
230                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus2;
231                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus3;
232                       wire [WR_PNTR_WIDTH:0]     wr_pntr_plus1_pf;
233                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_inv_pf;
234                       reg  [WR_PNTR_WIDTH:0]     diff_pntr_pf_q = {WR_PNTR_WIDTH{1'b0}};
235                       wire [WR_PNTR_WIDTH-1:0]   diff_pntr_pf;
236                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr;
237                       wire [RD_PNTR_WIDTH:0]     rd_pntr_ext;
238                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr_cdc;
239                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr;
240                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_cdc_dc;
241                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_dc;
242                       wire [RD_PNTR_WIDTH-1:0]   wr_pntr_rd_adj;
243                       wire [RD_PNTR_WIDTH:0]     wr_pntr_rd_adj_dc;
244                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus1;
245                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus2;
246                       wire                       invalid_state;
247                       wire                       valid_fwft;
248                       wire                       ram_valid_fwft;
249                       wire                       going_empty;
250                       wire                       leaving_empty;
251                       wire                       going_aempty;
252                       wire                       leaving_aempty;
253                       reg                        ram_empty_i  = 1'b1;
254                       reg                        ram_aempty_i = 1'b1;
255                       wire                       empty_i;
256                       wire                       going_full;
257                       wire                       leaving_full;
258                       wire                       going_afull;
259                       wire                       leaving_afull;
260                       reg                        prog_full_i = FULL_RST_VAL;
261                       reg                        ram_full_i  = FULL_RST_VAL;
262                       reg                        ram_afull_i = FULL_RST_VAL;
263                       reg                        ram_full_n  = ~FULL_RST_VAL;
264                       wire                       ram_wr_en_i;
265                       wire                       ram_rd_en_i;
266                       reg                        wr_ack_i = 1'b0;
267                       wire                       rd_en_i;
268                       reg                        rd_en_fwft;
269                       wire                       ram_regce;
270                       wire                       ram_regce_pipe;
271                       wire [READ_DATA_WIDTH-1:0] dout_i;
272                       reg                        empty_fwft_i     = 1'b1;
273                       reg                        aempty_fwft_i    = 1'b1;
274                       reg                        empty_fwft_fb    = 1'b1;
275                       reg                        overflow_i       = 1'b0;
276                       reg                        underflow_i      = 1'b0;
277                       reg                        data_valid_fwft  = 1'b0;
278                       reg                        data_valid_std   = 1'b0;
279                       wire                       data_vld_std;
280                       wire                       wrp_gt_rdp_and_red;
281                       wire                       wrp_lt_rdp_and_red;
282                       reg                        ram_wr_en_pf_q = 1'b0;
283                       reg                        ram_rd_en_pf_q = 1'b0;
284                       wire                       ram_wr_en_pf;
285                       wire                       ram_rd_en_pf;
286                       wire                       wr_pntr_plus1_pf_carry;
287                       wire                       rd_pntr_wr_adj_pf_carry;
288                       wire                       write_allow;
289                       wire                       read_allow;
290                       wire                       read_only;
291                       wire                       write_only;
292                       reg                        write_only_q;
293                       reg                        read_only_q;
294                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg1;
295                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg2;
296                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe = 'b0;
297                       reg                        prog_empty_i = 1'b1;
298                       reg                        ram_empty_i_d1 = 1'b1;
299                       wire                       fe_of_empty;
300                       // function to validate the write depth value
301                       function logic dpth_pwr_2;
302                         input integer fifo_depth;
303                         integer log2_of_depth; // correcponding to the default value of 2k depth
304        1/1              log2_of_depth = clog2(fifo_depth);
305        1/1              if (fifo_depth == 2 ** log2_of_depth)
306        1/1                dpth_pwr_2 = 1;
307                         else
308        <font color = "red">0/1     ==>        dpth_pwr_2 = 0;</font>
309        1/1              return dpth_pwr_2;
310                       endfunction
311                       
312                       initial begin : config_drc
313                         reg drc_err_flag;
314        1/1              drc_err_flag = 0;
315        2/2              #1;
316                     
317        1/1              if (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEM_TYPE == 3) begin
318        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] UltraRAM cannot be used as asynchronous FIFO because it has only one clock support %m&quot;, &quot;XPM_FIFO&quot;, 1, 1);</font>
319        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
320                         end
                        MISSING_ELSE
321                     
322        1/1              if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 1) begin
323        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Related Clocks cannot be used in synchronous FIFO because it is applicable only for asynchronous FIFO %m&quot;, &quot;XPM_FIFO&quot;, 1, 2);</font>
324        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
325                         end
                        MISSING_ELSE
326                     
327        1/1              if(!(FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
328        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is not within the supported ranges. Miniumum supported depth is 16, and the maximum supported depth is 4*1024*1024 locations. %m&quot;, &quot;XPM_FIFO&quot;, 1, 3, FIFO_WRITE_DEPTH);</font>
329        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
330                         end
                        MISSING_ELSE
331                     
332        1/1              if(!dpth_pwr_2(FIFO_WRITE_DEPTH) &amp;&amp; (FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
333        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is non-power of 2, but this release of XPM_FIFO supports configurations having the fifo write depth set to power of 2. %m&quot;, &quot;XPM_FIFO&quot;, 1, 4, FIFO_WRITE_DEPTH);</font>
334        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
335                         end
                        MISSING_ELSE
336                     
337        1/1              if (CDC_DEST_SYNC_FF &lt; 2 || CDC_DEST_SYNC_FF &gt; 8) begin
338        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but this beta release of XPM_FIFO supports CDC_DEST_SYNC_FF values in between 2 and 8. %m&quot;, &quot;XPM_FIFO&quot;, 1, 5,CDC_DEST_SYNC_FF);</font>
339        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
340                         end
                        MISSING_ELSE
341        1/1              if (CDC_DEST_SYNC_FF != 2 &amp;&amp; RELATED_CLOCKS == 1) begin
342        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but CDC_DEST_SYNC_FF value can not be modified from default value when RELATED_CLOCKS parameter is set to 1. %m&quot;, &quot;XPM_FIFO&quot;, 1, 6,CDC_DEST_SYNC_FF);</font>
343        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
344                         end
                        MISSING_ELSE
345        1/1              if (FIFO_WRITE_DEPTH == 16 &amp;&amp; CDC_DEST_SYNC_FF &gt; 4) begin
346        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF = %0d and FIFO_WRITE_DEPTH = %0d. This is invalid combination. Either FIFO_WRITE_DEPTH should be increased or CDC_DEST_SYNC_FF should be reduced. %m&quot;, &quot;XPM_FIFO&quot;, 1, 7,CDC_DEST_SYNC_FF, FIFO_WRITE_DEPTH);</font>
347        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
348                         end
                        MISSING_ELSE
349        1/1              if (EN_ADV_FEATURE[7:5] != 3'h0) begin
350        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[7:5] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 8, EN_ADV_FEATURE[7:5]);</font>
351        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
352                         end
                        MISSING_ELSE
353        1/1              if (EN_ADV_FEATURE[15:14] != 3'h0) begin
354        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[15:13] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 9, EN_ADV_FEATURE[15:13]);</font>
355        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
356                         end
                        MISSING_ELSE
357                     //    if(WIDTH_RATIO &gt; 32) begin
358                     //      $error(&quot;[%s %0d-%0d] The ratio between WRITE_DATA_WIDTH (%0d) and READ_DATA_WIDTH (%0d) is greater than 32, but this release of XPM_FIFO supports configurations having the ratio between data widths must be less than 32. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH, READ_DATA_WIDTH);
359                     //      drc_err_flag = 1;
360                     //    end
361        1/1              if (WR_WIDTH_LOG+WR_DEPTH_LOG &gt; 30) begin
362        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The specified Width(%0d) and Depth(%0d) exceeds the maximum supported FIFO SIZE. Please reduce either FIFO Width or Depth. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH,FIFO_WRITE_DEPTH);</font>
363        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
364                         end
                        MISSING_ELSE
365        1/1              if(FIFO_READ_DEPTH &lt; 16) begin
366        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Width is %0d Read Width is %0d and Write Depth is %0d, this results in the Read Depth(%0d) less than 16. This is an invalid combination, Ensure the depth on both sides is minimum 16. %m&quot;, &quot;XPM_FIFO&quot;, 1, 11, WRITE_DATA_WIDTH, READ_DATA_WIDTH, FIFO_WRITE_DEPTH, FIFO_READ_DEPTH);</font>
367        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
368                         end
                        MISSING_ELSE
369                     
370                         // Range Checks
371        1/1              if (COMMON_CLOCK &gt; 1) begin
372        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] COMMON_CLOCK (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 1, COMMON_CLOCK);</font>
373        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
374                         end
                        MISSING_ELSE
375        1/1              if (FIFO_MEMORY_TYPE &gt; 3) begin
376        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_MEMORY_TYPE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 2, FIFO_MEMORY_TYPE);</font>
377        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
378                         end
                        MISSING_ELSE
379        1/1          	if (READ_MODE &gt; 2) begin
380        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 3, READ_MODE);</font>
381        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
382                         end
                        MISSING_ELSE
383                     
384        1/1              if (ECC_MODE &gt; 1) begin
385        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] ECC_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 4, ECC_MODE);</font>
386        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
387                         end
                        MISSING_ELSE
388        1/1          	if (!(WAKEUP_TIME == 0 || WAKEUP_TIME == 2)) begin
389        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WAKEUP_TIME (%0d) value is outside of legal range. WAKEUP_TIME should be either 0 or 2. %m&quot;, &quot;XPM_FIFO&quot;, 10, 5, WAKEUP_TIME);</font>
390        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
391                         end
                        MISSING_ELSE
392        1/1              if (!(VERSION == 0)) begin
393        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] VERSION (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 6, VERSION);</font>
394        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
395                         end
                        MISSING_ELSE
396                     
397        1/1              if (!(WRITE_DATA_WIDTH &gt; 0)) begin
398        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 2, WRITE_DATA_WIDTH);</font>
399        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
400                         end
                        MISSING_ELSE
401        1/1              if (!(READ_DATA_WIDTH &gt; 0)) begin
402        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 3, READ_DATA_WIDTH);</font>
403        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
404                         end
                        MISSING_ELSE
405                     
406        1/1              if (EN_PF == 1 &amp;&amp; ((PROG_FULL_THRESH &lt; PF_THRESH_MIN) || (PROG_FULL_THRESH &gt; PF_THRESH_MAX))) begin
407        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Full flag is enabled, but PROG_FULL_THRESH (%0d) value is outside of legal range. PROG_FULL_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 4, PROG_FULL_THRESH, PF_THRESH_MIN, PF_THRESH_MAX);</font>
408        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
409                         end
                        MISSING_ELSE
410                     
411        1/1              if (EN_PE == 1 &amp;&amp; (WIDTH_RATIO &lt;= 32) &amp;&amp; ((PROG_EMPTY_THRESH &lt; PE_THRESH_MIN) || (PROG_EMPTY_THRESH &gt; PE_THRESH_MAX))) begin
412        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Empty flag is enabled, but PROG_EMPTY_THRESH (%0d) value is outside of legal range. PROG_EMPTY_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 5, PROG_EMPTY_THRESH, PE_THRESH_MIN, PE_THRESH_MAX);</font>
413        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
414                         end
                        MISSING_ELSE
415                     
416        1/1              if (EN_WDC == 1 &amp;&amp; ((WR_DATA_COUNT_WIDTH &lt; 0) || (WR_DATA_COUNT_WIDTH &gt; WR_DC_WIDTH_EXT))) begin
417        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Data Count is enabled, but WR_DATA_COUNT_WIDTH (%0d) value is outside of legal range. WR_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 6, WR_DATA_COUNT_WIDTH, 0, WR_DC_WIDTH_EXT);</font>
418        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
419                         end
                        MISSING_ELSE
420                     
421                     
422        1/1              if (EN_RDC == 1 &amp;&amp; ((RD_DATA_COUNT_WIDTH &lt; 0) || (RD_DATA_COUNT_WIDTH &gt; RD_DC_WIDTH_EXT))) begin
423        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Read Data Count is enabled, but RD_DATA_COUNT_WIDTH (%0d) value is outside of legal range. RD_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 7, RD_DATA_COUNT_WIDTH, 0, RD_DC_WIDTH_EXT);</font>
424        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
425                         end
                        MISSING_ELSE
426                     
427                         //DRCs on Low Latency FWFT mode
428        1/1              if (READ_MODE == 2 &amp;&amp; FIFO_MEMORY_TYPE != 1) begin
429        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] XPM_FIFO does not support Read Mode (Low Latency FWFT) for FIFO_MEMORY_TYPE other than lutram/distributed. %m&quot;, &quot;XPM_FIFO&quot;, 16, 2);</font>
430        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
431                         end
                        MISSING_ELSE
432        1/1              if (READ_MODE == 2 &amp;&amp; EN_ADV_FEATURE != 16'h0) begin
433        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES = %0h. XPM_FIFO does not support Advanced Features in Low Latency FWFT mode. %m&quot;, &quot;XPM_FIFO&quot;, 16, 3, EN_ADV_FEATURE);</font>
434        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
435                         end
                        MISSING_ELSE
436                     
437                         // Infos
438                     
439                         // Warnings
440        1/1              if (drc_err_flag == 1)
441        <font color = "red">0/2     ==>        #1 $finish;</font>
                        MISSING_ELSE
442                       end : config_drc
443                     
444                       wire wr_en_i;
445                       wire wr_rst_i;
446                       wire rd_rst_i;
447                       reg  rd_rst_d2 = 1'b0;
448                       wire rst_d1;
449                       wire rst_d2;
450                       wire clr_full;
451                       wire empty_fwft_d1;
452                       wire leaving_empty_fwft_fe;
453                       wire leaving_empty_fwft_re;
454                       wire le_fwft_re;
455                       wire le_fwft_fe;
456                       wire [1:0] extra_words_fwft;
457                       wire le_fwft_re_wr;
458                       wire le_fwft_fe_wr;
459                     
460                       generate
461                     
462                       xpm_fifo_rst # (COMMON_CLOCK, CDC_DEST_SYNC_FF, SIM_ASSERT_CHK)
463                         xpm_fifo_rst_inst (rst, wr_clk, rd_clk, wr_rst_i, rd_rst_i, wrst_busy, rd_rst_busy);
464                       assign wr_rst_busy = wrst_busy | rst_d1;
465                     
466                       xpm_fifo_reg_bit #(0)
467                         rst_d1_inst (1'b0, wr_clk, wrst_busy, rst_d1);
468                       xpm_fifo_reg_bit #(0)
469                         rst_d2_inst (1'b0, wr_clk, rst_d1, rst_d2);
470                     
471                       assign clr_full = ~wrst_busy &amp; rst_d1 &amp; ~rst;
472                       assign rd_en_i = (RD_MODE == 0) ? rd_en : rd_en_fwft;
473                     
474                       if (REMOVE_WR_RD_PROT_LOGIC == 1) begin : ngen_wr_rd_prot
475                         assign ram_wr_en_i = wr_en;
476                         assign ram_rd_en_i = rd_en_i;
477                       end : ngen_wr_rd_prot
478                       else begin : gen_wr_rd_prot
479                         assign ram_wr_en_i = wr_en &amp; ~ram_full_i &amp; ~(wrst_busy|rst_d1);
480                         assign ram_rd_en_i = rd_en_i &amp; ~ram_empty_i;
481                       end : gen_wr_rd_prot
482                     
483                       // Write pointer generation
484                       xpm_counter_updn # (WR_PNTR_WIDTH+1, 0)
485                         wrp_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_ext);
486                       assign wr_pntr = wr_pntr_ext[WR_PNTR_WIDTH-1:0];
487                     
488                       xpm_counter_updn # (WR_PNTR_WIDTH, 1)
489                         wrpp1_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus1);
490                     
491                       xpm_counter_updn # (WR_PNTR_WIDTH, 2)
492                         wrpp2_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus2);
493                     
494                       if (EN_AF == 1) begin : gaf_wptr_p3
495                         xpm_counter_updn # (WR_PNTR_WIDTH, 3)
496                           wrpp3_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus3);
497                       end : gaf_wptr_p3
498                     
499                       // Read pointer generation
500                       xpm_counter_updn # (RD_PNTR_WIDTH+1, 0)
501                         rdp_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_ext);
502                       assign rd_pntr = rd_pntr_ext[RD_PNTR_WIDTH-1:0];
503                     
504                       xpm_counter_updn # (RD_PNTR_WIDTH, 1)
505                         rdpp1_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus1);
506                     
507                       if (EN_AE == 1) begin : gae_rptr_p2
508                         xpm_counter_updn # (RD_PNTR_WIDTH, 2)
509                           rdpp2_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus2);
510                       end : gae_rptr_p2
511                     
512                       assign full        = ram_full_i;
513                       assign full_n      = ram_full_n;
514                       assign almost_full = EN_AF == 1 ? ram_afull_i : 1'b0;
515                       assign wr_ack      = EN_WACK == 1 ? wr_ack_i : 1'b0;
516                       if (EN_WACK == 1) begin : gwack
517                         always @ (posedge wr_clk) begin
518                           if (rst | wr_rst_i | wrst_busy)
519                             wr_ack_i  &lt;= 1'b0;
520                           else
521                             wr_ack_i  &lt;= ram_wr_en_i;
522                         end
523                       end : gwack
524                     
525                       assign prog_full  = EN_PF == 1 ? (PROG_FULL_THRESH &gt; 0)  ? prog_full_i  : 1'b0 : 1'b0;
526                       assign prog_empty = EN_PE == 1 ? (PROG_EMPTY_THRESH &gt; 0) ? prog_empty_i : 1'b1 : 1'b0;
527                       
528                       assign empty_i = (RD_MODE == 0)? ram_empty_i : empty_fwft_i;
529                       assign empty   = empty_i;
530                       assign almost_empty = EN_AE == 1 ? (RD_MODE == 0) ? ram_aempty_i : aempty_fwft_i : 1'b0;
531                       
532                       assign data_valid   = EN_DVLD == 1 ? (RD_MODE == 0) ? data_valid_std : data_valid_fwft : 1'b0;
533                       if (EN_DVLD == 1) begin : gdvld
534                         assign data_vld_std = (RD_MODE == 0) ? (FIFO_READ_LATENCY == 1) ? ram_rd_en_i: ram_regce_pipe : ram_regce;
535                         always @ (posedge rd_clk) begin
536                           if (rd_rst_i)
537                             data_valid_std  &lt;= 1'b0;
538                           else
539                             data_valid_std  &lt;= data_vld_std;
540                         end
541                       end : gdvld
542                     
543                       // Simple dual port RAM instantiation for non-Built-in FIFO
544                       if (FIFO_MEMORY_TYPE &lt; 4) begin : gen_sdpram
545                     
546                       // Reset is not supported when ECC is enabled by the BRAM/URAM primitives
547                         wire rst_int;
548                         if(ECC_MODE !=0) begin : gnd_rst
549                           assign rst_int = 0;
550                         end : gnd_rst
551                         else begin : rst_gen
552                           assign rst_int = rd_rst_i;
553                         end : rst_gen
554                       // ----------------------------------------------------------------------
555                       // Base module instantiation with simple dual port RAM configuration
556                       // ----------------------------------------------------------------------
557                       localparam USE_DRAM_CONSTRAINT = (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEMORY_TYPE == 1) ? 1 : 0;
558                       localparam WR_MODE_B           = (FIFO_MEMORY_TYPE == 1 || FIFO_MEMORY_TYPE == 3) ? 1 : 2;
559                       xpm_memory_base # (
560                     
561                         // Common module parameters
562                         .MEMORY_TYPE              (1                    ),
563                         .MEMORY_SIZE              (FIFO_SIZE            ),
564                         .MEMORY_PRIMITIVE         (FIFO_MEMORY_TYPE     ),
565                         .CLOCKING_MODE            (COMMON_CLOCK ? 0 : 1 ),
566                         .ECC_MODE                 (ENABLE_ECC           ),
567                         .USE_MEM_INIT             (0                    ),
568                         .MEMORY_INIT_FILE         (&quot;none&quot;               ),
569                         .MEMORY_INIT_PARAM        (&quot;&quot;                   ),
570                         .WAKEUP_TIME              (WAKEUP_TIME          ),
571                         .MESSAGE_CONTROL          (0                    ),
572                         .VERSION                  (0                    ),
573                         .MEMORY_OPTIMIZATION      (&quot;true&quot;               ),
574                         .AUTO_SLEEP_TIME          (0                    ),
575                         .USE_EMBEDDED_CONSTRAINT  (USE_DRAM_CONSTRAINT  ),
576                         .CASCADE_HEIGHT           (CASCADE_HEIGHT       ),
577                     
578                         // Port A module parameters
579                         .WRITE_DATA_WIDTH_A       (WRITE_DATA_WIDTH     ),
580                         .READ_DATA_WIDTH_A        (WRITE_DATA_WIDTH     ),
581                         .BYTE_WRITE_WIDTH_A       (WRITE_DATA_WIDTH     ),
582                         .ADDR_WIDTH_A             (WR_PNTR_WIDTH        ),
583                         .READ_RESET_VALUE_A       (&quot;0&quot;                  ),
584                         .READ_LATENCY_A           (2                    ),
585                         .WRITE_MODE_A             (2                    ),
586                     
587                         // Port B module parameters
588                         .WRITE_DATA_WIDTH_B       (READ_DATA_WIDTH      ),
589                         .READ_DATA_WIDTH_B        (READ_DATA_WIDTH      ),
590                         .BYTE_WRITE_WIDTH_B       (READ_DATA_WIDTH      ),
591                         .ADDR_WIDTH_B             (RD_PNTR_WIDTH        ),
592                         .READ_RESET_VALUE_B       (DOUT_RESET_VALUE     ),
593                         .READ_LATENCY_B           (RD_LATENCY           ),
594                         .WRITE_MODE_B             (WR_MODE_B            )
595                       ) xpm_memory_base_inst (
596                     
597                         // Common module ports
598                         .sleep          (sleep                    ),
599                     
600                         // Port A module ports
601                         .clka           (wr_clk                   ),
602                         .rsta           (1'b0                     ),
603                         .ena            (ram_wr_en_i              ),
604                         .regcea         (1'b0                     ),
605                         .wea            (ram_wr_en_i              ),
606                         .addra          (wr_pntr                  ),
607                         .dina           (din                      ),
608                         .injectsbiterra (injectsbiterr            ),
609                         .injectdbiterra (injectdbiterr            ),
610                         .douta          (                         ),
611                         .sbiterra       (                         ),
612                         .dbiterra       (                         ),
613                     
614                         // Port B module ports
615                         .clkb           (rd_clk                   ),
616                         .rstb           (rst_int                  ),
617                         .enb            (ram_rd_en_i              ),
618                         .regceb         (READ_MODE == 0 ? ram_regce_pipe: ram_regce),
619                         .web            (1'b0                     ),
620                         .addrb          (rd_pntr                  ),
621                         .dinb           ({READ_DATA_WIDTH{1'b0}}  ),
622                         .injectsbiterrb (1'b0                     ),
623                         .injectdbiterrb (1'b0                     ),
624                         .doutb          (dout_i                   ),
625                         .sbiterrb       (sbiterr                  ),
626                         .dbiterrb       (dbiterr                  )
627                       );
628                       end : gen_sdpram
629                     
630                       if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
631                         assign wr_pntr_rd_adj    = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
632                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
633                         assign rd_pntr_wr_adj    = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
634                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
635                       end : wrp_eq_rdp
636                     
637                       if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
638                         assign wr_pntr_rd_adj = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
639                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
640                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr;
641                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
642                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr_dc;
643                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
644                       end : wrp_gt_rdp
645                     
646                       if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
647                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd;
648                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
649                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd_dc;
650                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
651                         assign rd_pntr_wr_adj = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
652                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
653                       end : wrp_lt_rdp
654                     
655                       if (COMMON_CLOCK == 0 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_cdc_pntr
656                         // Synchronize the write pointer in rd_clk domain
657                         xpm_cdc_gray #(
658                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
659                           .INIT_SYNC_FF          (1),
660                           .WIDTH                 (WR_PNTR_WIDTH))
661                           
662                           wr_pntr_cdc_inst (
663                             .src_clk             (wr_clk),
664                             .src_in_bin          (wr_pntr),
665                             .dest_clk            (rd_clk),
666                             .dest_out_bin        (wr_pntr_rd_cdc));
667                     
668                         // Register the output of XPM_CDC_GRAY on read side
669                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
670                           wpr_gray_reg (rd_rst_i, rd_clk, wr_pntr_rd_cdc, wr_pntr_rd);
671                     
672                         // Synchronize the extended write pointer in rd_clk domain
673                         xpm_cdc_gray #(
674                           .DEST_SYNC_FF          (READ_MODE == 0 ? CDC_DEST_SYNC_FF : CDC_DEST_SYNC_FF+2),
675                           .INIT_SYNC_FF          (1),
676                           .WIDTH                 (WR_PNTR_WIDTH+1))
677                           wr_pntr_cdc_dc_inst (
678                             .src_clk             (wr_clk),
679                             .src_in_bin          (wr_pntr_ext),
680                             .dest_clk            (rd_clk),
681                             .dest_out_bin        (wr_pntr_rd_cdc_dc));
682                     
683                         // Register the output of XPM_CDC_GRAY on read side
684                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
685                           wpr_gray_reg_dc (rd_rst_i, rd_clk, wr_pntr_rd_cdc_dc, wr_pntr_rd_dc);
686                     
687                         // Synchronize the read pointer in wr_clk domain
688                         xpm_cdc_gray #(
689                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
690                           .INIT_SYNC_FF          (1),
691                           .WIDTH                 (RD_PNTR_WIDTH))
692                           rd_pntr_cdc_inst (
693                             .src_clk             (rd_clk),
694                             .src_in_bin          (rd_pntr),
695                             .dest_clk            (wr_clk),
696                             .dest_out_bin        (rd_pntr_wr_cdc));
697                     
698                         // Register the output of XPM_CDC_GRAY on write side
699                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
700                           rpw_gray_reg (wrst_busy, wr_clk, rd_pntr_wr_cdc, rd_pntr_wr);
701                     
702                         // Synchronize the read pointer, subtracted by the extra word read for FWFT, in wr_clk domain
703                         xpm_cdc_gray #(
704                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
705                           .INIT_SYNC_FF          (1),
706                           .WIDTH                 (RD_PNTR_WIDTH+1))
707                           rd_pntr_cdc_dc_inst (
708                             .src_clk             (rd_clk),
709                             .src_in_bin          (rd_pntr_ext-extra_words_fwft),
710                             .dest_clk            (wr_clk),
711                             .dest_out_bin        (rd_pntr_wr_cdc_dc));
712                     
713                         // Register the output of XPM_CDC_GRAY on write side
714                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
715                           rpw_gray_reg_dc (wrst_busy, wr_clk, rd_pntr_wr_cdc_dc, rd_pntr_wr_dc);
716                     
717                       end : gen_cdc_pntr
718                     
719                       if (RELATED_CLOCKS == 1) begin : gen_pntr_pf_rc
720                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
721                           rpw_rc_reg (wrst_busy, wr_clk, rd_pntr, rd_pntr_wr);
722                     
723                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
724                           wpr_rc_reg (rd_rst_i, rd_clk, wr_pntr, wr_pntr_rd);
725                     
726                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
727                           wpr_rc_reg_dc (rd_rst_i, rd_clk, wr_pntr_ext, wr_pntr_rd_dc);
728                     
729                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
730                           rpw_rc_reg_dc (wrst_busy, wr_clk, (rd_pntr_ext-extra_words_fwft), rd_pntr_wr_dc);
731                       end : gen_pntr_pf_rc
732                     
733                       if (COMMON_CLOCK == 0 || RELATED_CLOCKS == 1) begin : gen_pf_ic_rc
734                       
735                         assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_rd_en_i);
736                         assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr));
737                         assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ram_rd_en_i);
738                         assign leaving_aempty  = ((wr_pntr_rd_adj == rd_pntr_plus1));
739                       
740                         assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i);
741                         assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr_plus1));
742                         assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus3) &amp; ram_wr_en_i);
743                         assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus2));
744                       
745                         // Empty flag generation
746                         always @ (posedge rd_clk) begin
747                           if (rd_rst_i) begin
748                              ram_empty_i  &lt;= 1'b1;
749                           end else begin
750                              ram_empty_i  &lt;= going_empty | leaving_empty;
751                           end
752                         end
753                     
754                         if (EN_AE == 1) begin : gae_ic_std
755                           always @ (posedge rd_clk) begin
756                             if (rd_rst_i) begin
757                               ram_aempty_i &lt;= 1'b1;
758                             end else if (~ram_empty_i) begin
759                               ram_aempty_i &lt;= going_aempty | leaving_aempty;
760                             end
761                           end
762                         end : gae_ic_std
763                       
764                         // Full flag generation
765                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
766                           always @ (posedge wr_clk) begin
767                     	if (wrst_busy) begin
768                               ram_full_i      &lt;= FULL_RST_VAL;
769                               ram_full_n      &lt;= ~FULL_RST_VAL;
770                             end else begin
771                     	  if (clr_full) begin
772                                 ram_full_i    &lt;= 1'b0;
773                                 ram_full_n    &lt;= 1'b1;
774                     	  end else begin
775                                 ram_full_i    &lt;= going_full | leaving_full;
776                                 ram_full_n    &lt;= ~(going_full | leaving_full);
777                               end
778                             end
779                           end
780                         end : gen_full_rst_val
781                         else begin : ngen_full_rst_val
782                           always @ (posedge wr_clk) begin
783                     	if (wrst_busy) begin
784                               ram_full_i   &lt;= 1'b0;
785                               ram_full_n   &lt;= 1'b1;
786                     	end else begin
787                               ram_full_i   &lt;= going_full | leaving_full;
788                               ram_full_n   &lt;= ~(going_full | leaving_full);
789                     	end
790                           end
791                         end : ngen_full_rst_val
792                     
793                         if (EN_AF == 1) begin : gaf_ic
794                           always @ (posedge wr_clk) begin
795                     	if (wrst_busy) begin
796                               ram_afull_i  &lt;= FULL_RST_VAL;
797                             end else if (~rst) begin
798                     	  if (clr_full) begin
799                                 ram_afull_i  &lt;= 1'b0;
800                     	  end else if (~ram_full_i) begin
801                                 ram_afull_i  &lt;= going_afull | leaving_afull;
802                               end
803                             end
804                           end
805                         end : gaf_ic
806                     
807                       // synthesis translate_off
808                         `ifndef DISABLE_XPM_ASSERTIONS
809                         if (SIM_ASSERT_CHK == 1) begin: assert_wr_rd_en
810                           always @ (posedge rd_clk) begin
811                             assert (!$isunknown(rd_en)) else $warning (&quot;Input port 'rd_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'rd_en' has a valid value ('0' or '1')&quot;,$time);
812                           end
813                     
814                           always @ (posedge wr_clk) begin
815                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
816                           end
817                     
818                           always @ (posedge wr_clk) begin
819                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
820                           end
821                     
822                         end : assert_wr_rd_en
823                         `endif
824                       // synthesis translate_on
825                     
826                         // Programmable Full flag generation
827                         if (EN_PF == 1) begin : gpf_ic
828                           assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
829                           assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
830                       
831                           // PF carry generation
832                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i;
833                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i;
834                       
835                           // PF diff pointer generation
836                           always @ (posedge wr_clk) begin
837                             if (wrst_busy)
838                                diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
839                             else
840                                diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
841                           end
842                           assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
843                       
844                           always @ (posedge wr_clk) begin
845                             if (wrst_busy)
846                                prog_full_i  &lt;= FULL_RST_VAL;
847                             else if (clr_full)
848                                prog_full_i  &lt;= 1'b0;
849                             else if (~ram_full_i) begin
850                               if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
851                                 prog_full_i  &lt;= 1'b1;
852                               else
853                                 prog_full_i  &lt;= 1'b0;
854                             end else
855                               prog_full_i  &lt;= prog_full_i;
856                           end
857                         end : gpf_ic
858                     
859                         /*********************************************************
860                          * Programmable EMPTY flags
861                          *********************************************************/
862                         //Determine the Assert and Negate thresholds for Programmable Empty
863                         if (EN_PE == 1) begin : gpe_ic
864                      
865                           always @(posedge rd_clk) begin
866                             if (rd_rst_i) begin
867                               diff_pntr_pe      &lt;= 0;
868                               prog_empty_i       &lt;= 1'b1;
869                             end else begin
870                               if (ram_rd_en_i)
871                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr) - 1'h1;
872                               else
873                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr);
874                          
875                               if (~empty_i) begin
876                                 if (diff_pntr_pe &lt;= PE_THRESH_ADJ)
877                                   prog_empty_i &lt;= 1'b1;
878                                 else
879                                   prog_empty_i &lt;= 1'b0;
880                               end else
881                                 prog_empty_i   &lt;= prog_empty_i;
882                             end
883                           end
884                         end : gpe_ic
885                       end : gen_pf_ic_rc
886                     
887                       if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_pntr_flags_cc
888                         assign wr_pntr_rd = wr_pntr;
889                         assign rd_pntr_wr = rd_pntr;
890                         assign wr_pntr_rd_dc = wr_pntr_ext;
891                         assign rd_pntr_wr_dc = rd_pntr_ext-extra_words_fwft;
892                         assign write_allow  = ram_wr_en_i &amp; ~ram_full_i;
893                         assign read_allow   = ram_rd_en_i &amp; ~empty_i;
894                     
895                         if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
896                           assign ram_wr_en_pf  = ram_wr_en_i;
897                           assign ram_rd_en_pf  = ram_rd_en_i;
898                       
899                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
900                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
901                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
902                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
903                       
904                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
905                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
906                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
907                           assign leaving_afull  = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_rd_en_i &amp; ~ram_wr_en_i);
908                     
909                           assign write_only    = write_allow &amp; ~read_allow;
910                           assign read_only     = read_allow &amp; ~write_allow;
911                     
912                         end : wrp_eq_rdp
913                       
914                         if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
915                           assign wrp_gt_rdp_and_red = &amp;wr_pntr_rd[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0];
916                       
917                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
918                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red));
919                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
920                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ~ram_rd_en_i);
921                       
922                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
923                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
924                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
925                           assign leaving_afull  = (((rd_pntr_wr_adj == wr_pntr) | (rd_pntr_wr_adj == wr_pntr_plus1) | (rd_pntr_wr_adj == wr_pntr_plus2)) &amp; ram_rd_en_i);
926                       
927                           assign ram_wr_en_pf  = ram_wr_en_i &amp; wrp_gt_rdp_and_red;
928                           assign ram_rd_en_pf  = ram_rd_en_i;
929                     
930                           assign read_only     = read_allow &amp; (~(write_allow  &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0])));
931                           assign write_only    = write_allow &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0]) &amp; ~read_allow;
932                     
933                     
934                         end : wrp_gt_rdp
935                       
936                         if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
937                           assign wrp_lt_rdp_and_red = &amp;rd_pntr_wr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0];
938                       
939                           assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
940                           assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
941                           assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
942                           assign leaving_aempty  = (((wr_pntr_rd_adj == rd_pntr) | (wr_pntr_rd_adj == rd_pntr_plus1) | (wr_pntr_rd_adj == rd_pntr_plus2)) &amp; ram_wr_en_i);
943                       
944                           assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
945                           assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr) &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
946                           assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
947                           assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~ram_wr_en_i &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
948                       
949                           assign ram_wr_en_pf = ram_wr_en_i;
950                           assign ram_rd_en_pf = ram_rd_en_i &amp; wrp_lt_rdp_and_red;
951                     
952                           assign read_only   = read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0]) &amp; ~write_allow;
953                           assign write_only    = write_allow    &amp; (~(read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0])));
954                         end : wrp_lt_rdp
955                       
956                         // Empty flag generation
957                         always @ (posedge rd_clk) begin
958        1/1                if (rd_rst_i) begin
959        1/1                   ram_empty_i  &lt;= 1'b1;
960                           end else begin
961        1/1                   ram_empty_i  &lt;= going_empty | (~leaving_empty &amp; ram_empty_i);
962                           end
963                         end
964                     
965                         if (EN_AE == 1) begin : gae_cc_std
966                           always @ (posedge rd_clk) begin
967                             if (rd_rst_i) begin
968                               ram_aempty_i &lt;= 1'b1;
969                             end else begin
970                               ram_aempty_i &lt;= going_aempty | (~leaving_aempty &amp; ram_aempty_i);
971                             end
972                           end
973                         end : gae_cc_std
974                     
975                         // Full flag generation
976                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
977                           always @ (posedge wr_clk) begin
978                     	if (wrst_busy) begin
979                               ram_full_i   &lt;= FULL_RST_VAL;
980                               ram_full_n   &lt;= ~FULL_RST_VAL;
981                             end else begin
982                     	  if (clr_full) begin
983                                 ram_full_i   &lt;= 1'b0;
984                                 ram_full_n   &lt;= 1'b1;
985                     	  end else begin
986                                 ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
987                                 ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
988                               end
989                             end
990                           end
991                         end : gen_full_rst_val
992                         else begin : ngen_full_rst_val
993                           always @ (posedge wr_clk) begin
994        1/1          	if (wrst_busy) begin
995        1/1                    ram_full_i   &lt;= 1'b0;
996        1/1                    ram_full_n   &lt;= 1'b1;
997                     	end else begin
998        1/1                    ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
999        1/1                    ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
1000                    	end
1001                          end
1002                        end : ngen_full_rst_val
1003                    
1004                        if (EN_AF == 1) begin : gaf_cc
1005                          always @ (posedge wr_clk) begin
1006                    	if (wrst_busy) begin
1007                              ram_afull_i  &lt;= FULL_RST_VAL;
1008                            end else if (~rst) begin
1009                    	  if (clr_full) begin
1010                                ram_afull_i  &lt;= 1'b0;
1011                    	  end else begin
1012                                ram_afull_i  &lt;= going_afull | (~leaving_afull &amp; ram_afull_i);
1013                              end
1014                            end
1015                          end
1016                        end : gaf_cc
1017                        // Programmable Full flag generation
1018                        if ((WR_PNTR_WIDTH == RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_eq_rdp_pf_cc
1019                          if (EN_PF == 1) begin : gpf_cc_sym
1020                    
1021                            assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
1022                            assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
1023                      
1024                            // Delayed write/read enable for PF generation
1025                            always @ (posedge wr_clk) begin
1026       1/1                    if (wrst_busy) begin
1027       1/1                       ram_wr_en_pf_q   &lt;= 1'b0;
1028       1/1                       ram_rd_en_pf_q   &lt;= 1'b0;
1029                              end else begin
1030       1/1                       ram_wr_en_pf_q   &lt;= ram_wr_en_pf;
1031       1/1                       ram_rd_en_pf_q   &lt;= ram_rd_en_pf;
1032                              end
1033                            end
1034                      
1035                            // PF carry generation
1036                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i &amp; ~ram_rd_en_pf;
1037                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i &amp; ~ram_rd_en_pf;
1038                      
1039                            // PF diff pointer generation
1040                            always @ (posedge wr_clk) begin
1041       1/1                    if (wrst_busy)
1042       1/1                       diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1043                              else
1044       1/1                       diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
1045                            end
1046                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1047                      
1048                            always @ (posedge wr_clk) begin
1049       1/1                    if (wrst_busy)
1050       1/1                       prog_full_i  &lt;= FULL_RST_VAL;
1051       1/1                    else if (clr_full)
1052       1/1                       prog_full_i  &lt;= 1'b0;
1053       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ram_wr_en_pf_q &amp; ~ram_rd_en_pf_q)
1054       1/1                       prog_full_i  &lt;= 1'b1;
1055       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ~ram_wr_en_pf_q &amp; ram_rd_en_pf_q)
1056       <font color = "red">0/1     ==>               prog_full_i  &lt;= 1'b0;</font>
1057                              else
1058       1/1                       prog_full_i  &lt;= prog_full_i;
1059                            end
1060                          end : gpf_cc_sym
1061                    
1062                          if (EN_PE == 1) begin : gpe_cc_sym
1063                            always @(posedge rd_clk) begin
1064       1/1                    if (rd_rst_i) begin
1065       1/1                      read_only_q    &lt;= 1'b0;
1066       1/1                      write_only_q   &lt;= 1'b0;
1067       1/1                      diff_pntr_pe   &lt;= 0;
1068                              end 
1069                              else begin
1070       1/1                      read_only_q  &lt;= read_only;
1071       1/1                      write_only_q &lt;= write_only;
1072                                // Add 1 to the difference pointer value when write or both write &amp; read or no write &amp; read happen.
1073       1/1                      if (read_only)
1074       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr - 1;
1075                                else
1076       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr;
1077                              end
1078                            end
1079                      
1080                            always @(posedge rd_clk) begin
1081       1/1                    if (rd_rst_i)
1082       1/1                      prog_empty_i  &lt;= 1'b1;
1083                              else begin
1084       1/1                      if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; read_only_q)
1085       <font color = "red">0/1     ==>                prog_empty_i &lt;= 1'b1;</font>
1086       1/1                      else if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; write_only_q)
1087       1/1                        prog_empty_i &lt;= 1'b0;
1088                                else
1089       1/1                        prog_empty_i &lt;= prog_empty_i;
1090                              end
1091                            end
1092                          end : gpe_cc_sym
1093                        end : wrp_eq_rdp_pf_cc
1094                    
1095                        if ((WR_PNTR_WIDTH != RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_neq_rdp_pf_cc
1096                          if (EN_PF == 1) begin : gpf_cc_asym
1097                            // PF diff pointer generation
1098                            always @ (posedge wr_clk) begin
1099                              if (wrst_busy)
1100                                 diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1101                              else if (~ram_full_i)
1102                                 diff_pntr_pf_q[WR_PNTR_WIDTH:1]  &lt;= wr_pntr + ~rd_pntr_wr_adj + 1;
1103                            end
1104                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1105                            always @ (posedge wr_clk) begin
1106                              if (wrst_busy)
1107                                 prog_full_i  &lt;= FULL_RST_VAL;
1108                              else if (clr_full)
1109                                 prog_full_i  &lt;= 1'b0;
1110                              else if (~ram_full_i) begin
1111                                if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
1112                                   prog_full_i  &lt;= 1'b1;
1113                                else if (diff_pntr_pf &lt; PF_THRESH_ADJ)
1114                                   prog_full_i  &lt;= 1'b0;
1115                                else
1116                                   prog_full_i  &lt;= prog_full_i;
1117                              end
1118                            end
1119                          end : gpf_cc_asym
1120                          if (EN_PE == 1) begin : gpe_cc_asym
1121                            // Programmanble Empty flag Generation
1122                            // Diff pointer Generation
1123                            localparam [RD_PNTR_WIDTH-1 : 0] DIFF_MAX_RD = {RD_PNTR_WIDTH{1'b1}};
1124                            wire [RD_PNTR_WIDTH-1:0] diff_pntr_pe_max;
1125                            wire                     carry;
1126                            reg  [RD_PNTR_WIDTH : 0] diff_pntr_pe_asym = 'b0;
1127                            wire [RD_PNTR_WIDTH : 0] wr_pntr_rd_adj_asym;
1128                            wire [RD_PNTR_WIDTH : 0] rd_pntr_asym;
1129                            reg                      full_reg;
1130                            reg                      rst_full_ff_reg1;
1131                            reg                      rst_full_ff_reg2;
1132                      
1133                            assign diff_pntr_pe_max = DIFF_MAX_RD;
1134                            assign wr_pntr_rd_adj_asym[RD_PNTR_WIDTH:0] = {wr_pntr_rd_adj,1'b1};
1135                            assign rd_pntr_asym[RD_PNTR_WIDTH:0] = {~rd_pntr,1'b1};
1136                      
1137                            always @(posedge rd_clk ) begin
1138                              if (rd_rst_i) begin
1139                                diff_pntr_pe_asym    &lt;= 0;
1140                                full_reg             &lt;= 0;
1141                                rst_full_ff_reg1     &lt;= 1;
1142                                rst_full_ff_reg2     &lt;= 1;
1143                                diff_pntr_pe_reg1    &lt;= 0;
1144                              end else begin
1145                                diff_pntr_pe_asym &lt;= wr_pntr_rd_adj_asym + rd_pntr_asym;
1146                                full_reg          &lt;= ram_full_i;
1147                                rst_full_ff_reg1  &lt;= FULL_RST_VAL;
1148                                rst_full_ff_reg2  &lt;= rst_full_ff_reg1;
1149                              end
1150                            end
1151                            wire [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_i;
1152                            assign carry = (~(|(diff_pntr_pe_asym [RD_PNTR_WIDTH : 1])));
1153                            assign diff_pntr_pe_i = (full_reg &amp;&amp; ~rst_d2 &amp;&amp; carry ) ? diff_pntr_pe_max : diff_pntr_pe_asym[RD_PNTR_WIDTH:1];
1154                        
1155                            always @(posedge rd_clk) begin
1156                              if (rd_rst_i)
1157                                prog_empty_i  &lt;= 1'b1;
1158                              else begin
1159                                if (diff_pntr_pe_i &lt;= PE_THRESH_ADJ)
1160                                  prog_empty_i &lt;= 1'b1;
1161                                else if (diff_pntr_pe_i &gt; PE_THRESH_ADJ)
1162                                  prog_empty_i &lt;= 1'b0;
1163                                else
1164                                  prog_empty_i &lt;= prog_empty_i;
1165                              end
1166                            end
1167                          end : gpe_cc_asym
1168                        end : wrp_neq_rdp_pf_cc
1169                    
1170                      end : gen_pntr_flags_cc
1171                    
1172                      if (READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1) begin : gen_regce_std
1173                        xpm_reg_pipe_bit #(FIFO_READ_LATENCY-1, 0)
1174                          regce_pipe_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_regce_pipe);
1175                      end : gen_regce_std
1176                      if (!(READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1)) begin : gnen_regce_std
1177                        assign ram_regce_pipe = 1'b0;
1178                      end : gnen_regce_std
1179                    
1180                      if (!((READ_MODE == 1 || READ_MODE == 2)&amp;&amp; FIFO_MEMORY_TYPE != 4)) begin : gn_fwft
1181                       assign invalid_state = 1'b0;
1182                      end : gn_fwft
1183                      //if (READ_MODE == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1184                      if (READ_MODE != 0 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1185                      // First word fall through logic
1186                    
1187                       //localparam invalid             = 0;
1188                       //localparam stage1_valid        = 2;
1189                       //localparam stage2_valid        = 1;
1190                       //localparam both_stages_valid   = 3;
1191                    
1192                       //reg  [1:0] curr_fwft_state = invalid;
1193                       //reg  [1:0] next_fwft_state;// = invalid;
1194                       wire next_fwft_state_d1;
1195                       assign invalid_state = ~|curr_fwft_state;
1196                       assign valid_fwft = next_fwft_state_d1;
1197                       assign ram_valid_fwft = curr_fwft_state[1];
1198                    
1199                        xpm_fifo_reg_bit #(0)
1200                          next_state_d1_inst (1'b0, rd_clk, next_fwft_state[0], next_fwft_state_d1);
1201                       //FSM : To generate the enable, clock enable for xpm_memory and to generate
1202                       //empty signal
1203                       //FSM : Next state Assignment
1204                         if (READ_MODE == 1) begin : gen_fwft_ns
1205                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1206                           case (curr_fwft_state)
1207                             invalid: begin
1208                               if (~ram_empty_i)
1209                                  next_fwft_state     = stage1_valid;
1210                               else
1211                                  next_fwft_state     = invalid;
1212                               end
1213                             stage1_valid: begin
1214                               if (ram_empty_i)
1215                                  next_fwft_state     = stage2_valid;
1216                               else
1217                                  next_fwft_state     = both_stages_valid;
1218                               end
1219                             stage2_valid: begin
1220                               if (ram_empty_i &amp;&amp; rd_en)
1221                                  next_fwft_state     = invalid;
1222                               else if (~ram_empty_i &amp;&amp; rd_en)
1223                                  next_fwft_state     = stage1_valid;
1224                               else if (~ram_empty_i &amp;&amp; ~rd_en)
1225                                  next_fwft_state     = both_stages_valid;
1226                               else
1227                                  next_fwft_state     = stage2_valid;
1228                               end
1229                             both_stages_valid: begin
1230                               if (ram_empty_i &amp;&amp; rd_en)
1231                                  next_fwft_state     = stage2_valid;
1232                               else if (~ram_empty_i &amp;&amp; rd_en)
1233                                  next_fwft_state     = both_stages_valid;
1234                               else
1235                                  next_fwft_state     = both_stages_valid;
1236                               end
1237                             default: next_fwft_state    = invalid;
1238                           endcase
1239                         end
1240                         end : gen_fwft_ns
1241                         if (READ_MODE == 2) begin : gen_fwft_ns_ll
1242                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1243                           case (curr_fwft_state)
1244                             invalid: begin
1245                               if (~ram_empty_i)
1246                                  next_fwft_state     = stage1_valid;
1247                               else
1248                                  next_fwft_state     = invalid;
1249                               end
1250                             stage1_valid: begin
1251                               if (ram_empty_i &amp;&amp; rd_en)
1252                                  next_fwft_state     = invalid;
1253                               else
1254                                  next_fwft_state     = stage1_valid;
1255                               end
1256                             default: next_fwft_state    = invalid;
1257                           endcase
1258                         end
1259                         end : gen_fwft_ns_ll
1260                         // FSM : current state assignment
1261                         always @ (posedge rd_clk) begin
1262                           if (rd_rst_i)
1263                              curr_fwft_state  &lt;= invalid;
1264                           else
1265                              curr_fwft_state  &lt;= next_fwft_state;
1266                         end
1267                     
1268                         reg ram_regout_en;
1269                    
1270                         // FSM(output assignments) : clock enable generation for xpm_memory
1271                         if (READ_MODE == 1) begin : gen_fwft_ro
1272                         always @(curr_fwft_state or rd_en) begin
1273                           case (curr_fwft_state)
1274                             invalid:           ram_regout_en = 1'b0;
1275                             stage1_valid:      ram_regout_en = 1'b1;
1276                             stage2_valid:      ram_regout_en = 1'b0;
1277                             both_stages_valid: ram_regout_en = rd_en;
1278                             default:           ram_regout_en = 1'b0;
1279                           endcase
1280                         end
1281                         end : gen_fwft_ro
1282                         if (READ_MODE == 2) begin : gen_fwft_ro_ll
1283                         always @(curr_fwft_state or rd_en or ram_empty_i or fe_of_empty) begin
1284                           case (curr_fwft_state)
1285                             invalid:           ram_regout_en = fe_of_empty;
1286                             stage1_valid:      ram_regout_en = rd_en &amp; !ram_empty_i;
1287                             default:           ram_regout_en = 1'b0;
1288                           endcase
1289                         end
1290                         end : gen_fwft_ro_ll
1291                    
1292                         // FSM(output assignments) : rd_en (enable) signal generation for xpm_memory
1293                         if (READ_MODE == 1) begin : gen_fwft_re
1294                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1295                           case (curr_fwft_state)
1296                             invalid :
1297                               if (~ram_empty_i)
1298                                 rd_en_fwft = 1'b1;
1299                               else
1300                                 rd_en_fwft = 1'b0;
1301                             stage1_valid :
1302                               if (~ram_empty_i)
1303                                 rd_en_fwft = 1'b1;
1304                               else
1305                                 rd_en_fwft = 1'b0;
1306                             stage2_valid :
1307                               if (~ram_empty_i)
1308                                 rd_en_fwft = 1'b1;
1309                               else
1310                                 rd_en_fwft = 1'b0;
1311                             both_stages_valid :
1312                               if (~ram_empty_i &amp;&amp; rd_en)
1313                                 rd_en_fwft = 1'b1;
1314                               else
1315                                 rd_en_fwft = 1'b0;
1316                             default :
1317                               rd_en_fwft = 1'b0;
1318                           endcase
1319                         end
1320                         end : gen_fwft_re
1321                         if (READ_MODE == 2) begin : gen_fwft_re_ll
1322                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1323                           case (curr_fwft_state)
1324                             invalid :
1325                               if (~ram_empty_i)
1326                                 rd_en_fwft = 1'b1;
1327                               else
1328                                 rd_en_fwft = 1'b0;
1329                             stage1_valid :
1330                               if (~ram_empty_i &amp;&amp; rd_en)
1331                                 rd_en_fwft = 1'b1;
1332                               else
1333                                 rd_en_fwft = 1'b0;
1334                             default :
1335                               rd_en_fwft = 1'b0;
1336                           endcase
1337                         end
1338                         end : gen_fwft_re_ll
1339                         // assingment to control regce xpm_memory
1340                         assign ram_regce = ram_regout_en;
1341                    
1342                         reg going_empty_fwft;
1343                         reg leaving_empty_fwft;
1344                    
1345                         if (READ_MODE == 1) begin : gen_fwft_ge
1346                         always @(curr_fwft_state or rd_en) begin
1347                           case (curr_fwft_state)
1348                             stage2_valid : going_empty_fwft = rd_en;
1349                             default      : going_empty_fwft = 1'b0;
1350                           endcase
1351                         end
1352                    
1353                         always @(curr_fwft_state or rd_en) begin
1354                           case (curr_fwft_state)
1355                             stage1_valid : leaving_empty_fwft = 1'b1;
1356                             default      : leaving_empty_fwft = 1'b0;
1357                           endcase
1358                         end
1359                         end : gen_fwft_ge
1360                         if (READ_MODE == 2) begin : gen_fwft_ge_ll
1361                         always @(curr_fwft_state or rd_en or ram_empty_i) begin
1362                           case (curr_fwft_state)
1363                             stage1_valid : going_empty_fwft = rd_en &amp; ram_empty_i;
1364                             default      : going_empty_fwft = 1'b0;
1365                           endcase
1366                         end
1367                    
1368                         always @ (posedge rd_clk) begin
1369                           if (rd_rst_i) begin
1370                              ram_empty_i_d1  &lt;= 1'b1;
1371                           end else begin
1372                              ram_empty_i_d1  &lt;= ram_empty_i;
1373                           end
1374                         end
1375                         assign fe_of_empty = ram_empty_i_d1 &amp; !ram_empty_i;
1376                    
1377                         always @(curr_fwft_state or fe_of_empty) begin
1378                           case (curr_fwft_state)
1379                             invalid      : leaving_empty_fwft = fe_of_empty;
1380                             stage1_valid : leaving_empty_fwft = 1'b1;
1381                             default      : leaving_empty_fwft = 1'b0;
1382                           endcase
1383                         end
1384                         end : gen_fwft_ge_ll
1385                    
1386                         // fwft empty signal generation 
1387                         always @ (posedge rd_clk) begin
1388                           if (rd_rst_i) begin
1389                             empty_fwft_i     &lt;= 1'b1;
1390                             empty_fwft_fb    &lt;= 1'b1;
1391                           end else begin
1392                             empty_fwft_i     &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1393                             empty_fwft_fb    &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1394                           end
1395                         end
1396                    
1397                         if (EN_AE == 1) begin : gae_fwft
1398                           reg going_aempty_fwft;
1399                           reg leaving_aempty_fwft;
1400                    
1401                           if (READ_MODE == 1) begin : gen_fwft_ae
1402                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1403                               case (curr_fwft_state)
1404                                 both_stages_valid : going_aempty_fwft = rd_en &amp; ram_empty_i;
1405                                 default      : going_aempty_fwft = 1'b0;
1406                               endcase
1407                             end
1408                           end : gen_fwft_ae
1409                           if (READ_MODE == 2) begin : gen_fwft_ae_ll
1410                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1411                               case (curr_fwft_state)
1412                                 stage1_valid : going_aempty_fwft = !rd_en &amp; ram_empty_i;
1413                                 default      : going_aempty_fwft = 1'b0;
1414                               endcase
1415                             end
1416                           end : gen_fwft_ae_ll
1417                    
1418                           always @(curr_fwft_state or rd_en or ram_empty_i) begin
1419                             case (curr_fwft_state)
1420                               stage1_valid : leaving_aempty_fwft = ~ram_empty_i;
1421                               stage2_valid : leaving_aempty_fwft = ~(rd_en | ram_empty_i);
1422                               default      : leaving_aempty_fwft = 1'b0;
1423                             endcase
1424                           end
1425                    
1426                           always @ (posedge rd_clk) begin
1427                             if (rd_rst_i) begin
1428                               aempty_fwft_i    &lt;= 1'b1;
1429                             end else begin
1430                               aempty_fwft_i    &lt;= going_aempty_fwft | (~ leaving_aempty_fwft &amp; aempty_fwft_i);
1431                             end
1432                           end
1433                         end : gae_fwft
1434                    
1435                         if (EN_DVLD == 1) begin : gdvld_fwft
1436                           always @ (posedge rd_clk) begin
1437                             if (rd_rst_i) begin
1438                               data_valid_fwft  &lt;= 1'b0;
1439                             end else begin
1440                               data_valid_fwft  &lt;= ~(going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb));
1441                             end
1442                           end
1443                         end : gdvld_fwft
1444                    
1445                        xpm_fifo_reg_bit #(0)
1446                          empty_fwft_d1_inst (1'b0, rd_clk, leaving_empty_fwft, empty_fwft_d1);
1447                    
1448                        wire ge_fwft_d1;
1449                        xpm_fifo_reg_bit #(0)
1450                          ge_fwft_d1_inst (1'b0, rd_clk, going_empty_fwft, ge_fwft_d1);
1451                    
1452                        wire count_up  ;
1453                        wire count_down;
1454                        wire count_en  ;
1455                        wire count_rst ;
1456                        assign count_up   = (next_fwft_state == 2'b10 &amp;&amp; ~|curr_fwft_state) | (curr_fwft_state == 2'b10 &amp;&amp; &amp;next_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; &amp;next_fwft_state);
1457                        assign count_down = (next_fwft_state == 2'b01 &amp;&amp; &amp;curr_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; ~|next_fwft_state);
1458                        assign count_en   = count_up | count_down;
1459                        assign count_rst  = (rd_rst_i | (~|curr_fwft_state &amp; ~|next_fwft_state));
1460                    
1461                        xpm_counter_updn # (2, 0)
1462                          rdpp1_inst (count_rst, rd_clk, count_en, count_up, count_down, extra_words_fwft);
1463                    
1464                     
1465                      end : gen_fwft
1466                    
1467                      if (READ_MODE == 0) begin : ngen_fwft
1468                        assign le_fwft_re       = 1'b0;
1469                        assign le_fwft_fe       = 1'b0;
1470                        assign extra_words_fwft = 2'h0;
1471                      end : ngen_fwft
1472                    
1473                      // output data bus assignment
1474                      if (FG_EQ_ASYM_DOUT == 0) begin : nfg_eq_asym_dout
1475                        assign dout  = dout_i;
1476                      end : nfg_eq_asym_dout
1477                    
1478                      // Overflow and Underflow flag generation
1479                      if (EN_UF == 1) begin : guf
1480                        always @ (posedge rd_clk) begin
1481       1/1                underflow_i &lt;=  (rd_rst_i | empty_i) &amp; rd_en;
1482                        end
1483                        assign underflow   = underflow_i;
1484                      end : guf
1485                      if (EN_UF == 0) begin : gnuf
1486                        assign underflow   = 1'b0;
1487                      end : gnuf
1488                    
1489                      if (EN_OF == 1) begin : gof
1490                        always @ (posedge wr_clk) begin
1491       1/1               overflow_i  &lt;=  (wrst_busy | rst_d1 | ram_full_i) &amp; wr_en;
1492                        end
1493                        assign overflow    = overflow_i;
1494                      end : gof
1495                      if (EN_OF == 0) begin : gnof
1496                        assign overflow    = 1'b0;
1497                      end : gnof
1498                    
1499                      // -------------------------------------------------------------------------------------------------------------------
1500                      // Write Data Count for Independent Clocks FIFO
1501                      // -------------------------------------------------------------------------------------------------------------------
1502                      if (EN_WDC == 1) begin : gwdc
1503                        reg  [WR_DC_WIDTH_EXT-1:0] wr_data_count_i;
1504                        wire [WR_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr;
1505                        assign diff_wr_rd_pntr = wr_pntr_ext-rd_pntr_wr_adj_dc;
1506                        always @ (posedge wr_clk) begin
1507       1/1                if (wrst_busy)
1508       1/1                   wr_data_count_i   &lt;= {WR_DC_WIDTH_EXT{1'b0}};
1509                          else
1510       1/1                   wr_data_count_i  &lt;= diff_wr_rd_pntr;
1511                        end
1512                        assign wr_data_count = wr_data_count_i[WR_DC_WIDTH_EXT-1:WR_DC_WIDTH_EXT-WR_DATA_COUNT_WIDTH];
1513                      end : gwdc
1514                      if (EN_WDC == 0) begin : gnwdc
1515                        assign wr_data_count = {WR_DC_WIDTH_EXT{1'b0}};
1516                      end : gnwdc
1517                    
1518                      // -------------------------------------------------------------------------------------------------------------------
1519                      // Read Data Count for Independent Clocks FIFO
1520                      // -------------------------------------------------------------------------------------------------------------------
1521                      if (EN_RDC == 1) begin : grdc
1522                        reg  [RD_DC_WIDTH_EXT-1:0] rd_data_count_i;
1523                        wire [RD_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr_rdc;
1524                        assign diff_wr_rd_pntr_rdc = wr_pntr_rd_adj_dc-rd_pntr_ext+extra_words_fwft;
1525                        always @ (posedge rd_clk) begin
1526       1/1                if (rd_rst_i | invalid_state)
1527       1/1                   rd_data_count_i   &lt;= {RD_DC_WIDTH_EXT{1'b0}};
1528                          else
1529       1/1                   rd_data_count_i  &lt;= diff_wr_rd_pntr_rdc;
1530                        end
1531                        assign rd_data_count = rd_data_count_i[RD_DC_WIDTH_EXT-1:RD_DC_WIDTH_EXT-RD_DATA_COUNT_WIDTH];
1532                      end : grdc
1533                      if (EN_RDC == 0) begin : gnrdc
1534                        assign rd_data_count = {RD_DC_WIDTH_EXT{1'b0}};
1535                      end : gnrdc
1536                    
1537                      endgenerate
1538                    
1539                      // -------------------------------------------------------------------------------------------------------------------
1540                      // Simulation constructs
1541                      // -------------------------------------------------------------------------------------------------------------------
1542                      // synthesis translate_off
1543                    
1544                     `ifndef DISABLE_XPM_ASSERTIONS  
1545                      initial begin
1546       2/2            #1;
1547       1/1              if (SIM_ASSERT_CHK == 1)
1548                        `ifdef OBSOLETE
1549                          $warning(&quot;Vivado Simulator does not currently support the SystemVerilog Assertion syntax used within XPM_FIFO.  \
1550                    Messages related to potential misuse will not be reported.&quot;);
1551                        `else
1552       <font color = "red">0/1     ==>        $warning(&quot;SIM_ASSERT_CHK (%0d) specifies simulation message reporting, messages related to potential misuse \</font>
                        MISSING_ELSE
</pre>
<hr>
<a name="inst_tag_275_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod18.html#inst_tag_275" >AdaptedSharpener.fifo.lineBuffer_4.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">Conditions</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="s6"><td class="lf">Logical</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1084
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; read_only_q)
             ---------------1---------------    -----2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1086
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; write_only_q)
             ---------------1---------------    ------2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_275_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod18.html#inst_tag_275" >AdaptedSharpener.fifo.lineBuffer_4.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s3">
<td>Totals</td>
<td class="rt">129</td>
<td class="rt">50</td>
<td class="rt">38.76 </td>
</tr><tr class="s7">
<td>Total Bits</td>
<td class="rt">864</td>
<td class="rt">605</td>
<td class="rt">70.02 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 0->1</td>
<td class="rt">432</td>
<td class="rt">304</td>
<td class="rt">70.37 </td>
</tr><tr class="s6">
<td nowrap>Total Bits 1->0</td>
<td class="rt">432</td>
<td class="rt">301</td>
<td class="rt">69.68 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s2">
<td>Ports</td>
<td class="rt">27</td>
<td class="rt">8</td>
<td class="rt">29.63 </td>
</tr><tr class="s8">
<td>Port Bits</td>
<td class="rt">178</td>
<td class="rt">144</td>
<td class="rt">80.90 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 0->1</td>
<td class="rt">89</td>
<td class="rt">71</td>
<td class="rt">79.78 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 1->0</td>
<td class="rt">89</td>
<td class="rt">73</td>
<td class="rt">82.02 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s4">
<td>Signals</td>
<td class="rt">102</td>
<td class="rt">42</td>
<td class="rt">41.18 </td>
</tr><tr class="s6">
<td>Signal Bits</td>
<td class="rt">686</td>
<td class="rt">461</td>
<td class="rt">67.20 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">343</td>
<td class="rt">233</td>
<td class="rt">67.93 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">343</td>
<td class="rt">228</td>
<td class="rt">66.47 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>sleep</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>rst</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>wr_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>wr_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>din[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_data_count</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_ack</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rd_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>dout[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>empty</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_empty</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_data_count</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>data_valid</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>injectsbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>injectdbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>dbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>curr_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>next_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus2[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus3[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_plus1_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_inv_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pf_q[6:1]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>invalid_state</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>going_aempty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_aempty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_aempty_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>prog_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_afull_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_ack_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_en_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce_pipe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dout_i[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>aempty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_fwft_fb</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>overflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>underflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_vld_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_gt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_lt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_wr_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe_reg1[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe_reg2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>prog_empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_empty_i_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>fe_of_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_en_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_d2</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rst_d1</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rst_d2</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>clr_full</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extra_words_fwft[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gen_sdpram.rst_int</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.rd_data_count_i[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.rd_data_count_i[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.rd_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_274'>
<a name="inst_tag_274_Line"></a>
<b>Line Coverage for Instance : <a href="mod18.html#inst_tag_274" >AdaptedSharpener.fifo.lineBuffer_3.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">TOTAL</td><td></td><td>142</td><td>86</td><td>60.56</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>126</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">ROUTINE</td><td>304</td><td>5</td><td>4</td><td>80.00</td></tr>
<tr class="s3"><td class="lf">INITIAL</td><td>314</td><td>81</td><td>29</td><td>35.80</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>958</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>994</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1026</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1041</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1049</td><td>9</td><td>8</td><td>88.89</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1064</td><td>9</td><td>9</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1081</td><td>7</td><td>6</td><td>85.71</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1481</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1491</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1507</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1526</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">INITIAL</td><td>1546</td><td>4</td><td>3</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
125                       begin 
126        1/1              value = value-1;
127        1/1              for (clog2=0; value&gt;0; clog2=clog2+1)
128        1/1                value = value&gt;&gt;1;
129                         end 
130                       endfunction
131                       // Function to convert ASCII value to binary 
132                       function [3:0] str2bin;
133                         input [7:0] str_val_ascii;
134                           if((str_val_ascii == 8'h30) || (str_val_ascii == 8'h31) || 
135                              (str_val_ascii == 8'h32) || (str_val_ascii == 8'h33) || 
136                              (str_val_ascii == 8'h34) || (str_val_ascii == 8'h35) || 
137                              (str_val_ascii == 8'h36) || (str_val_ascii == 8'h37) || 
138                              (str_val_ascii == 8'h38) || (str_val_ascii == 8'h39) || 
139                              (str_val_ascii == 8'h41) || (str_val_ascii == 8'h42) || 
140                              (str_val_ascii == 8'h43) || (str_val_ascii == 8'h44) || 
141                              (str_val_ascii == 8'h45) || (str_val_ascii == 8'h46) || 
142                              (str_val_ascii == 8'h61) || (str_val_ascii == 8'h62) || 
143                              (str_val_ascii == 8'h63) || (str_val_ascii == 8'h64) || 
144                              (str_val_ascii == 8'h65) || (str_val_ascii == 8'h66) || 
145                              (str_val_ascii == 8'h00)) begin
146                              if (!str_val_ascii[6])
147                                 str2bin = str_val_ascii[3:0];
148                              else begin
149                                str2bin [3] = 1'b1;
150                                str2bin [2] = str_val_ascii[2] | (str_val_ascii[1] &amp; str_val_ascii[0]);
151                                str2bin [1] = str_val_ascii[0] ^ str_val_ascii[1];
152                                str2bin [0] = !str_val_ascii[0];
153                              end
154                           end
155                           else
156                             $error(&quot;Found Invalid character while parsing the string, please cross check the value specified for either READ_RESET_VALUE_A|B or MEMORY_INIT_PARAM (if initialization of memory through parameter is used). XPM_MEMORY supports strings (hex) that contains characters 0-9, A-F and a-f.&quot;);
157                       endfunction
158                       // Function that parses the complete reset value string
159                       function logic [15:0] hstr2bin;
160                         input [16*8-1 : 0] hstr_val;
161                         integer rst_loop_a;
162                         localparam integer  rsta_loop_iter  =  16;
163                         logic [rsta_loop_iter-1 : 0] rst_val_conv_a_i;
164                         for (rst_loop_a=1; rst_loop_a &lt;= rsta_loop_iter/4; rst_loop_a = rst_loop_a+1) begin
165                           rst_val_conv_a_i[(rst_loop_a*4)-1 -: 4] =  str2bin(hstr_val[(rst_loop_a*8)-1 -: 8]);
166                         end
167                         return rst_val_conv_a_i[15:0];
168                       endfunction
169                     
170                     
171                       localparam invalid             = 0;
172                       localparam stage1_valid        = 2;
173                       localparam stage2_valid        = 1;
174                       localparam both_stages_valid   = 3;
175                     
176                       reg  [1:0] curr_fwft_state = invalid;
177                       reg  [1:0] next_fwft_state;// = invalid;
178                     
179                     
180                     
181                       localparam FIFO_MEM_TYPE   = FIFO_MEMORY_TYPE;
182                       localparam RD_MODE         = READ_MODE;
183                       localparam ENABLE_ECC      = (ECC_MODE == 1) ? 3 : 0;
184                       localparam FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH;
185                       localparam FIFO_SIZE       = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH;
186                       localparam WR_WIDTH_LOG    = clog2(WRITE_DATA_WIDTH);
187                       localparam WR_DEPTH_LOG    = clog2(FIFO_WRITE_DEPTH);
188                       localparam WR_PNTR_WIDTH   = clog2(FIFO_WRITE_DEPTH);
189                       localparam RD_PNTR_WIDTH   = clog2(FIFO_READ_DEPTH);
190                       localparam FULL_RST_VAL    = FULL_RESET_VALUE == 0 ? 1'b0 : 1'b1;
191                       localparam WR_RD_RATIO     = (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) ? (WR_PNTR_WIDTH-RD_PNTR_WIDTH) : 0;
192                       localparam READ_MODE_LL    = (READ_MODE == 0) ? 0 : 1;
193                       localparam PF_THRESH_ADJ   = (READ_MODE == 0) ? PROG_FULL_THRESH :
194                                                    PROG_FULL_THRESH - (2*(2**WR_RD_RATIO));
195                       localparam PE_THRESH_ADJ   = (READ_MODE_LL == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) ? PROG_EMPTY_THRESH - 2'h2 : PROG_EMPTY_THRESH;
196                     
197                       localparam PF_THRESH_MIN   = 3+(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1))+(COMMON_CLOCK?0:CDC_DEST_SYNC_FF);
198                       localparam PF_THRESH_MAX   = (FIFO_WRITE_DEPTH-3)-(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1));
199                       localparam PE_THRESH_MIN   = 3+(READ_MODE_LL*2);
200                       localparam PE_THRESH_MAX   = (FIFO_READ_DEPTH-3)-(READ_MODE_LL*2);
201                       localparam WR_DC_WIDTH_EXT = clog2(FIFO_WRITE_DEPTH)+1;
202                       localparam RD_DC_WIDTH_EXT = clog2(FIFO_READ_DEPTH)+1;
203                       localparam RD_LATENCY      = (READ_MODE == 2) ? 1 : (READ_MODE == 1) ? 2 : FIFO_READ_LATENCY;
204                       localparam WIDTH_RATIO     = (READ_DATA_WIDTH &gt; WRITE_DATA_WIDTH) ? (READ_DATA_WIDTH/WRITE_DATA_WIDTH) : (WRITE_DATA_WIDTH/READ_DATA_WIDTH);
205                     
206                       localparam [15:0] EN_ADV_FEATURE = hstr2bin(USE_ADV_FEATURES);
207                     
208                       localparam EN_OF           = EN_ADV_FEATURE[0];  //EN_ADV_FLAGS_WR[0] ? 1 : 0;
209                       localparam EN_PF           = EN_ADV_FEATURE[1];  //EN_ADV_FLAGS_WR[1] ? 1 : 0;
210                       localparam EN_WDC          = EN_ADV_FEATURE[2];  //EN_ADV_FLAGS_WR[2] ? 1 : 0;
211                       localparam EN_AF           = EN_ADV_FEATURE[3];  //EN_ADV_FLAGS_WR[3] ? 1 : 0;
212                       localparam EN_WACK         = EN_ADV_FEATURE[4];  //EN_ADV_FLAGS_WR[4] ? 1 : 0;
213                       localparam FG_EQ_ASYM_DOUT = EN_ADV_FEATURE[5];  //EN_ADV_FLAGS_WR[5] ? 1 : 0;
214                       localparam EN_UF           = EN_ADV_FEATURE[8];  //EN_ADV_FLAGS_RD[0] ? 1 : 0;
215                       localparam EN_PE           = EN_ADV_FEATURE[9];  //EN_ADV_FLAGS_RD[1] ? 1 : 0;
216                       localparam EN_RDC          = EN_ADV_FEATURE[10]; //EN_ADV_FLAGS_RD[2] ? 1 : 0;
217                       localparam EN_AE           = EN_ADV_FEATURE[11]; //EN_ADV_FLAGS_RD[3] ? 1 : 0;
218                       localparam EN_DVLD         = EN_ADV_FEATURE[12]; //EN_ADV_FLAGS_RD[4] ? 1 : 0;
219                     
220                       wire                       wrst_busy;
221                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr;
222                       wire [WR_PNTR_WIDTH:0]     wr_pntr_ext;
223                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd_cdc;
224                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_cdc_dc;
225                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd;
226                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_dc;
227                       wire [WR_PNTR_WIDTH-1:0]   rd_pntr_wr_adj;
228                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_dc;
229                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus1;
230                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus2;
231                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus3;
232                       wire [WR_PNTR_WIDTH:0]     wr_pntr_plus1_pf;
233                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_inv_pf;
234                       reg  [WR_PNTR_WIDTH:0]     diff_pntr_pf_q = {WR_PNTR_WIDTH{1'b0}};
235                       wire [WR_PNTR_WIDTH-1:0]   diff_pntr_pf;
236                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr;
237                       wire [RD_PNTR_WIDTH:0]     rd_pntr_ext;
238                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr_cdc;
239                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr;
240                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_cdc_dc;
241                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_dc;
242                       wire [RD_PNTR_WIDTH-1:0]   wr_pntr_rd_adj;
243                       wire [RD_PNTR_WIDTH:0]     wr_pntr_rd_adj_dc;
244                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus1;
245                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus2;
246                       wire                       invalid_state;
247                       wire                       valid_fwft;
248                       wire                       ram_valid_fwft;
249                       wire                       going_empty;
250                       wire                       leaving_empty;
251                       wire                       going_aempty;
252                       wire                       leaving_aempty;
253                       reg                        ram_empty_i  = 1'b1;
254                       reg                        ram_aempty_i = 1'b1;
255                       wire                       empty_i;
256                       wire                       going_full;
257                       wire                       leaving_full;
258                       wire                       going_afull;
259                       wire                       leaving_afull;
260                       reg                        prog_full_i = FULL_RST_VAL;
261                       reg                        ram_full_i  = FULL_RST_VAL;
262                       reg                        ram_afull_i = FULL_RST_VAL;
263                       reg                        ram_full_n  = ~FULL_RST_VAL;
264                       wire                       ram_wr_en_i;
265                       wire                       ram_rd_en_i;
266                       reg                        wr_ack_i = 1'b0;
267                       wire                       rd_en_i;
268                       reg                        rd_en_fwft;
269                       wire                       ram_regce;
270                       wire                       ram_regce_pipe;
271                       wire [READ_DATA_WIDTH-1:0] dout_i;
272                       reg                        empty_fwft_i     = 1'b1;
273                       reg                        aempty_fwft_i    = 1'b1;
274                       reg                        empty_fwft_fb    = 1'b1;
275                       reg                        overflow_i       = 1'b0;
276                       reg                        underflow_i      = 1'b0;
277                       reg                        data_valid_fwft  = 1'b0;
278                       reg                        data_valid_std   = 1'b0;
279                       wire                       data_vld_std;
280                       wire                       wrp_gt_rdp_and_red;
281                       wire                       wrp_lt_rdp_and_red;
282                       reg                        ram_wr_en_pf_q = 1'b0;
283                       reg                        ram_rd_en_pf_q = 1'b0;
284                       wire                       ram_wr_en_pf;
285                       wire                       ram_rd_en_pf;
286                       wire                       wr_pntr_plus1_pf_carry;
287                       wire                       rd_pntr_wr_adj_pf_carry;
288                       wire                       write_allow;
289                       wire                       read_allow;
290                       wire                       read_only;
291                       wire                       write_only;
292                       reg                        write_only_q;
293                       reg                        read_only_q;
294                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg1;
295                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg2;
296                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe = 'b0;
297                       reg                        prog_empty_i = 1'b1;
298                       reg                        ram_empty_i_d1 = 1'b1;
299                       wire                       fe_of_empty;
300                       // function to validate the write depth value
301                       function logic dpth_pwr_2;
302                         input integer fifo_depth;
303                         integer log2_of_depth; // correcponding to the default value of 2k depth
304        1/1              log2_of_depth = clog2(fifo_depth);
305        1/1              if (fifo_depth == 2 ** log2_of_depth)
306        1/1                dpth_pwr_2 = 1;
307                         else
308        <font color = "red">0/1     ==>        dpth_pwr_2 = 0;</font>
309        1/1              return dpth_pwr_2;
310                       endfunction
311                       
312                       initial begin : config_drc
313                         reg drc_err_flag;
314        1/1              drc_err_flag = 0;
315        2/2              #1;
316                     
317        1/1              if (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEM_TYPE == 3) begin
318        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] UltraRAM cannot be used as asynchronous FIFO because it has only one clock support %m&quot;, &quot;XPM_FIFO&quot;, 1, 1);</font>
319        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
320                         end
                        MISSING_ELSE
321                     
322        1/1              if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 1) begin
323        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Related Clocks cannot be used in synchronous FIFO because it is applicable only for asynchronous FIFO %m&quot;, &quot;XPM_FIFO&quot;, 1, 2);</font>
324        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
325                         end
                        MISSING_ELSE
326                     
327        1/1              if(!(FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
328        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is not within the supported ranges. Miniumum supported depth is 16, and the maximum supported depth is 4*1024*1024 locations. %m&quot;, &quot;XPM_FIFO&quot;, 1, 3, FIFO_WRITE_DEPTH);</font>
329        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
330                         end
                        MISSING_ELSE
331                     
332        1/1              if(!dpth_pwr_2(FIFO_WRITE_DEPTH) &amp;&amp; (FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
333        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is non-power of 2, but this release of XPM_FIFO supports configurations having the fifo write depth set to power of 2. %m&quot;, &quot;XPM_FIFO&quot;, 1, 4, FIFO_WRITE_DEPTH);</font>
334        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
335                         end
                        MISSING_ELSE
336                     
337        1/1              if (CDC_DEST_SYNC_FF &lt; 2 || CDC_DEST_SYNC_FF &gt; 8) begin
338        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but this beta release of XPM_FIFO supports CDC_DEST_SYNC_FF values in between 2 and 8. %m&quot;, &quot;XPM_FIFO&quot;, 1, 5,CDC_DEST_SYNC_FF);</font>
339        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
340                         end
                        MISSING_ELSE
341        1/1              if (CDC_DEST_SYNC_FF != 2 &amp;&amp; RELATED_CLOCKS == 1) begin
342        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but CDC_DEST_SYNC_FF value can not be modified from default value when RELATED_CLOCKS parameter is set to 1. %m&quot;, &quot;XPM_FIFO&quot;, 1, 6,CDC_DEST_SYNC_FF);</font>
343        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
344                         end
                        MISSING_ELSE
345        1/1              if (FIFO_WRITE_DEPTH == 16 &amp;&amp; CDC_DEST_SYNC_FF &gt; 4) begin
346        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF = %0d and FIFO_WRITE_DEPTH = %0d. This is invalid combination. Either FIFO_WRITE_DEPTH should be increased or CDC_DEST_SYNC_FF should be reduced. %m&quot;, &quot;XPM_FIFO&quot;, 1, 7,CDC_DEST_SYNC_FF, FIFO_WRITE_DEPTH);</font>
347        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
348                         end
                        MISSING_ELSE
349        1/1              if (EN_ADV_FEATURE[7:5] != 3'h0) begin
350        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[7:5] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 8, EN_ADV_FEATURE[7:5]);</font>
351        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
352                         end
                        MISSING_ELSE
353        1/1              if (EN_ADV_FEATURE[15:14] != 3'h0) begin
354        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[15:13] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 9, EN_ADV_FEATURE[15:13]);</font>
355        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
356                         end
                        MISSING_ELSE
357                     //    if(WIDTH_RATIO &gt; 32) begin
358                     //      $error(&quot;[%s %0d-%0d] The ratio between WRITE_DATA_WIDTH (%0d) and READ_DATA_WIDTH (%0d) is greater than 32, but this release of XPM_FIFO supports configurations having the ratio between data widths must be less than 32. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH, READ_DATA_WIDTH);
359                     //      drc_err_flag = 1;
360                     //    end
361        1/1              if (WR_WIDTH_LOG+WR_DEPTH_LOG &gt; 30) begin
362        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The specified Width(%0d) and Depth(%0d) exceeds the maximum supported FIFO SIZE. Please reduce either FIFO Width or Depth. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH,FIFO_WRITE_DEPTH);</font>
363        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
364                         end
                        MISSING_ELSE
365        1/1              if(FIFO_READ_DEPTH &lt; 16) begin
366        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Width is %0d Read Width is %0d and Write Depth is %0d, this results in the Read Depth(%0d) less than 16. This is an invalid combination, Ensure the depth on both sides is minimum 16. %m&quot;, &quot;XPM_FIFO&quot;, 1, 11, WRITE_DATA_WIDTH, READ_DATA_WIDTH, FIFO_WRITE_DEPTH, FIFO_READ_DEPTH);</font>
367        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
368                         end
                        MISSING_ELSE
369                     
370                         // Range Checks
371        1/1              if (COMMON_CLOCK &gt; 1) begin
372        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] COMMON_CLOCK (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 1, COMMON_CLOCK);</font>
373        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
374                         end
                        MISSING_ELSE
375        1/1              if (FIFO_MEMORY_TYPE &gt; 3) begin
376        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_MEMORY_TYPE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 2, FIFO_MEMORY_TYPE);</font>
377        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
378                         end
                        MISSING_ELSE
379        1/1          	if (READ_MODE &gt; 2) begin
380        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 3, READ_MODE);</font>
381        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
382                         end
                        MISSING_ELSE
383                     
384        1/1              if (ECC_MODE &gt; 1) begin
385        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] ECC_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 4, ECC_MODE);</font>
386        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
387                         end
                        MISSING_ELSE
388        1/1          	if (!(WAKEUP_TIME == 0 || WAKEUP_TIME == 2)) begin
389        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WAKEUP_TIME (%0d) value is outside of legal range. WAKEUP_TIME should be either 0 or 2. %m&quot;, &quot;XPM_FIFO&quot;, 10, 5, WAKEUP_TIME);</font>
390        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
391                         end
                        MISSING_ELSE
392        1/1              if (!(VERSION == 0)) begin
393        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] VERSION (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 6, VERSION);</font>
394        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
395                         end
                        MISSING_ELSE
396                     
397        1/1              if (!(WRITE_DATA_WIDTH &gt; 0)) begin
398        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 2, WRITE_DATA_WIDTH);</font>
399        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
400                         end
                        MISSING_ELSE
401        1/1              if (!(READ_DATA_WIDTH &gt; 0)) begin
402        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 3, READ_DATA_WIDTH);</font>
403        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
404                         end
                        MISSING_ELSE
405                     
406        1/1              if (EN_PF == 1 &amp;&amp; ((PROG_FULL_THRESH &lt; PF_THRESH_MIN) || (PROG_FULL_THRESH &gt; PF_THRESH_MAX))) begin
407        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Full flag is enabled, but PROG_FULL_THRESH (%0d) value is outside of legal range. PROG_FULL_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 4, PROG_FULL_THRESH, PF_THRESH_MIN, PF_THRESH_MAX);</font>
408        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
409                         end
                        MISSING_ELSE
410                     
411        1/1              if (EN_PE == 1 &amp;&amp; (WIDTH_RATIO &lt;= 32) &amp;&amp; ((PROG_EMPTY_THRESH &lt; PE_THRESH_MIN) || (PROG_EMPTY_THRESH &gt; PE_THRESH_MAX))) begin
412        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Empty flag is enabled, but PROG_EMPTY_THRESH (%0d) value is outside of legal range. PROG_EMPTY_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 5, PROG_EMPTY_THRESH, PE_THRESH_MIN, PE_THRESH_MAX);</font>
413        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
414                         end
                        MISSING_ELSE
415                     
416        1/1              if (EN_WDC == 1 &amp;&amp; ((WR_DATA_COUNT_WIDTH &lt; 0) || (WR_DATA_COUNT_WIDTH &gt; WR_DC_WIDTH_EXT))) begin
417        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Data Count is enabled, but WR_DATA_COUNT_WIDTH (%0d) value is outside of legal range. WR_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 6, WR_DATA_COUNT_WIDTH, 0, WR_DC_WIDTH_EXT);</font>
418        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
419                         end
                        MISSING_ELSE
420                     
421                     
422        1/1              if (EN_RDC == 1 &amp;&amp; ((RD_DATA_COUNT_WIDTH &lt; 0) || (RD_DATA_COUNT_WIDTH &gt; RD_DC_WIDTH_EXT))) begin
423        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Read Data Count is enabled, but RD_DATA_COUNT_WIDTH (%0d) value is outside of legal range. RD_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 7, RD_DATA_COUNT_WIDTH, 0, RD_DC_WIDTH_EXT);</font>
424        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
425                         end
                        MISSING_ELSE
426                     
427                         //DRCs on Low Latency FWFT mode
428        1/1              if (READ_MODE == 2 &amp;&amp; FIFO_MEMORY_TYPE != 1) begin
429        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] XPM_FIFO does not support Read Mode (Low Latency FWFT) for FIFO_MEMORY_TYPE other than lutram/distributed. %m&quot;, &quot;XPM_FIFO&quot;, 16, 2);</font>
430        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
431                         end
                        MISSING_ELSE
432        1/1              if (READ_MODE == 2 &amp;&amp; EN_ADV_FEATURE != 16'h0) begin
433        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES = %0h. XPM_FIFO does not support Advanced Features in Low Latency FWFT mode. %m&quot;, &quot;XPM_FIFO&quot;, 16, 3, EN_ADV_FEATURE);</font>
434        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
435                         end
                        MISSING_ELSE
436                     
437                         // Infos
438                     
439                         // Warnings
440        1/1              if (drc_err_flag == 1)
441        <font color = "red">0/2     ==>        #1 $finish;</font>
                        MISSING_ELSE
442                       end : config_drc
443                     
444                       wire wr_en_i;
445                       wire wr_rst_i;
446                       wire rd_rst_i;
447                       reg  rd_rst_d2 = 1'b0;
448                       wire rst_d1;
449                       wire rst_d2;
450                       wire clr_full;
451                       wire empty_fwft_d1;
452                       wire leaving_empty_fwft_fe;
453                       wire leaving_empty_fwft_re;
454                       wire le_fwft_re;
455                       wire le_fwft_fe;
456                       wire [1:0] extra_words_fwft;
457                       wire le_fwft_re_wr;
458                       wire le_fwft_fe_wr;
459                     
460                       generate
461                     
462                       xpm_fifo_rst # (COMMON_CLOCK, CDC_DEST_SYNC_FF, SIM_ASSERT_CHK)
463                         xpm_fifo_rst_inst (rst, wr_clk, rd_clk, wr_rst_i, rd_rst_i, wrst_busy, rd_rst_busy);
464                       assign wr_rst_busy = wrst_busy | rst_d1;
465                     
466                       xpm_fifo_reg_bit #(0)
467                         rst_d1_inst (1'b0, wr_clk, wrst_busy, rst_d1);
468                       xpm_fifo_reg_bit #(0)
469                         rst_d2_inst (1'b0, wr_clk, rst_d1, rst_d2);
470                     
471                       assign clr_full = ~wrst_busy &amp; rst_d1 &amp; ~rst;
472                       assign rd_en_i = (RD_MODE == 0) ? rd_en : rd_en_fwft;
473                     
474                       if (REMOVE_WR_RD_PROT_LOGIC == 1) begin : ngen_wr_rd_prot
475                         assign ram_wr_en_i = wr_en;
476                         assign ram_rd_en_i = rd_en_i;
477                       end : ngen_wr_rd_prot
478                       else begin : gen_wr_rd_prot
479                         assign ram_wr_en_i = wr_en &amp; ~ram_full_i &amp; ~(wrst_busy|rst_d1);
480                         assign ram_rd_en_i = rd_en_i &amp; ~ram_empty_i;
481                       end : gen_wr_rd_prot
482                     
483                       // Write pointer generation
484                       xpm_counter_updn # (WR_PNTR_WIDTH+1, 0)
485                         wrp_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_ext);
486                       assign wr_pntr = wr_pntr_ext[WR_PNTR_WIDTH-1:0];
487                     
488                       xpm_counter_updn # (WR_PNTR_WIDTH, 1)
489                         wrpp1_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus1);
490                     
491                       xpm_counter_updn # (WR_PNTR_WIDTH, 2)
492                         wrpp2_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus2);
493                     
494                       if (EN_AF == 1) begin : gaf_wptr_p3
495                         xpm_counter_updn # (WR_PNTR_WIDTH, 3)
496                           wrpp3_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus3);
497                       end : gaf_wptr_p3
498                     
499                       // Read pointer generation
500                       xpm_counter_updn # (RD_PNTR_WIDTH+1, 0)
501                         rdp_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_ext);
502                       assign rd_pntr = rd_pntr_ext[RD_PNTR_WIDTH-1:0];
503                     
504                       xpm_counter_updn # (RD_PNTR_WIDTH, 1)
505                         rdpp1_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus1);
506                     
507                       if (EN_AE == 1) begin : gae_rptr_p2
508                         xpm_counter_updn # (RD_PNTR_WIDTH, 2)
509                           rdpp2_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus2);
510                       end : gae_rptr_p2
511                     
512                       assign full        = ram_full_i;
513                       assign full_n      = ram_full_n;
514                       assign almost_full = EN_AF == 1 ? ram_afull_i : 1'b0;
515                       assign wr_ack      = EN_WACK == 1 ? wr_ack_i : 1'b0;
516                       if (EN_WACK == 1) begin : gwack
517                         always @ (posedge wr_clk) begin
518                           if (rst | wr_rst_i | wrst_busy)
519                             wr_ack_i  &lt;= 1'b0;
520                           else
521                             wr_ack_i  &lt;= ram_wr_en_i;
522                         end
523                       end : gwack
524                     
525                       assign prog_full  = EN_PF == 1 ? (PROG_FULL_THRESH &gt; 0)  ? prog_full_i  : 1'b0 : 1'b0;
526                       assign prog_empty = EN_PE == 1 ? (PROG_EMPTY_THRESH &gt; 0) ? prog_empty_i : 1'b1 : 1'b0;
527                       
528                       assign empty_i = (RD_MODE == 0)? ram_empty_i : empty_fwft_i;
529                       assign empty   = empty_i;
530                       assign almost_empty = EN_AE == 1 ? (RD_MODE == 0) ? ram_aempty_i : aempty_fwft_i : 1'b0;
531                       
532                       assign data_valid   = EN_DVLD == 1 ? (RD_MODE == 0) ? data_valid_std : data_valid_fwft : 1'b0;
533                       if (EN_DVLD == 1) begin : gdvld
534                         assign data_vld_std = (RD_MODE == 0) ? (FIFO_READ_LATENCY == 1) ? ram_rd_en_i: ram_regce_pipe : ram_regce;
535                         always @ (posedge rd_clk) begin
536                           if (rd_rst_i)
537                             data_valid_std  &lt;= 1'b0;
538                           else
539                             data_valid_std  &lt;= data_vld_std;
540                         end
541                       end : gdvld
542                     
543                       // Simple dual port RAM instantiation for non-Built-in FIFO
544                       if (FIFO_MEMORY_TYPE &lt; 4) begin : gen_sdpram
545                     
546                       // Reset is not supported when ECC is enabled by the BRAM/URAM primitives
547                         wire rst_int;
548                         if(ECC_MODE !=0) begin : gnd_rst
549                           assign rst_int = 0;
550                         end : gnd_rst
551                         else begin : rst_gen
552                           assign rst_int = rd_rst_i;
553                         end : rst_gen
554                       // ----------------------------------------------------------------------
555                       // Base module instantiation with simple dual port RAM configuration
556                       // ----------------------------------------------------------------------
557                       localparam USE_DRAM_CONSTRAINT = (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEMORY_TYPE == 1) ? 1 : 0;
558                       localparam WR_MODE_B           = (FIFO_MEMORY_TYPE == 1 || FIFO_MEMORY_TYPE == 3) ? 1 : 2;
559                       xpm_memory_base # (
560                     
561                         // Common module parameters
562                         .MEMORY_TYPE              (1                    ),
563                         .MEMORY_SIZE              (FIFO_SIZE            ),
564                         .MEMORY_PRIMITIVE         (FIFO_MEMORY_TYPE     ),
565                         .CLOCKING_MODE            (COMMON_CLOCK ? 0 : 1 ),
566                         .ECC_MODE                 (ENABLE_ECC           ),
567                         .USE_MEM_INIT             (0                    ),
568                         .MEMORY_INIT_FILE         (&quot;none&quot;               ),
569                         .MEMORY_INIT_PARAM        (&quot;&quot;                   ),
570                         .WAKEUP_TIME              (WAKEUP_TIME          ),
571                         .MESSAGE_CONTROL          (0                    ),
572                         .VERSION                  (0                    ),
573                         .MEMORY_OPTIMIZATION      (&quot;true&quot;               ),
574                         .AUTO_SLEEP_TIME          (0                    ),
575                         .USE_EMBEDDED_CONSTRAINT  (USE_DRAM_CONSTRAINT  ),
576                         .CASCADE_HEIGHT           (CASCADE_HEIGHT       ),
577                     
578                         // Port A module parameters
579                         .WRITE_DATA_WIDTH_A       (WRITE_DATA_WIDTH     ),
580                         .READ_DATA_WIDTH_A        (WRITE_DATA_WIDTH     ),
581                         .BYTE_WRITE_WIDTH_A       (WRITE_DATA_WIDTH     ),
582                         .ADDR_WIDTH_A             (WR_PNTR_WIDTH        ),
583                         .READ_RESET_VALUE_A       (&quot;0&quot;                  ),
584                         .READ_LATENCY_A           (2                    ),
585                         .WRITE_MODE_A             (2                    ),
586                     
587                         // Port B module parameters
588                         .WRITE_DATA_WIDTH_B       (READ_DATA_WIDTH      ),
589                         .READ_DATA_WIDTH_B        (READ_DATA_WIDTH      ),
590                         .BYTE_WRITE_WIDTH_B       (READ_DATA_WIDTH      ),
591                         .ADDR_WIDTH_B             (RD_PNTR_WIDTH        ),
592                         .READ_RESET_VALUE_B       (DOUT_RESET_VALUE     ),
593                         .READ_LATENCY_B           (RD_LATENCY           ),
594                         .WRITE_MODE_B             (WR_MODE_B            )
595                       ) xpm_memory_base_inst (
596                     
597                         // Common module ports
598                         .sleep          (sleep                    ),
599                     
600                         // Port A module ports
601                         .clka           (wr_clk                   ),
602                         .rsta           (1'b0                     ),
603                         .ena            (ram_wr_en_i              ),
604                         .regcea         (1'b0                     ),
605                         .wea            (ram_wr_en_i              ),
606                         .addra          (wr_pntr                  ),
607                         .dina           (din                      ),
608                         .injectsbiterra (injectsbiterr            ),
609                         .injectdbiterra (injectdbiterr            ),
610                         .douta          (                         ),
611                         .sbiterra       (                         ),
612                         .dbiterra       (                         ),
613                     
614                         // Port B module ports
615                         .clkb           (rd_clk                   ),
616                         .rstb           (rst_int                  ),
617                         .enb            (ram_rd_en_i              ),
618                         .regceb         (READ_MODE == 0 ? ram_regce_pipe: ram_regce),
619                         .web            (1'b0                     ),
620                         .addrb          (rd_pntr                  ),
621                         .dinb           ({READ_DATA_WIDTH{1'b0}}  ),
622                         .injectsbiterrb (1'b0                     ),
623                         .injectdbiterrb (1'b0                     ),
624                         .doutb          (dout_i                   ),
625                         .sbiterrb       (sbiterr                  ),
626                         .dbiterrb       (dbiterr                  )
627                       );
628                       end : gen_sdpram
629                     
630                       if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
631                         assign wr_pntr_rd_adj    = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
632                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
633                         assign rd_pntr_wr_adj    = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
634                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
635                       end : wrp_eq_rdp
636                     
637                       if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
638                         assign wr_pntr_rd_adj = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
639                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
640                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr;
641                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
642                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr_dc;
643                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
644                       end : wrp_gt_rdp
645                     
646                       if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
647                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd;
648                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
649                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd_dc;
650                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
651                         assign rd_pntr_wr_adj = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
652                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
653                       end : wrp_lt_rdp
654                     
655                       if (COMMON_CLOCK == 0 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_cdc_pntr
656                         // Synchronize the write pointer in rd_clk domain
657                         xpm_cdc_gray #(
658                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
659                           .INIT_SYNC_FF          (1),
660                           .WIDTH                 (WR_PNTR_WIDTH))
661                           
662                           wr_pntr_cdc_inst (
663                             .src_clk             (wr_clk),
664                             .src_in_bin          (wr_pntr),
665                             .dest_clk            (rd_clk),
666                             .dest_out_bin        (wr_pntr_rd_cdc));
667                     
668                         // Register the output of XPM_CDC_GRAY on read side
669                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
670                           wpr_gray_reg (rd_rst_i, rd_clk, wr_pntr_rd_cdc, wr_pntr_rd);
671                     
672                         // Synchronize the extended write pointer in rd_clk domain
673                         xpm_cdc_gray #(
674                           .DEST_SYNC_FF          (READ_MODE == 0 ? CDC_DEST_SYNC_FF : CDC_DEST_SYNC_FF+2),
675                           .INIT_SYNC_FF          (1),
676                           .WIDTH                 (WR_PNTR_WIDTH+1))
677                           wr_pntr_cdc_dc_inst (
678                             .src_clk             (wr_clk),
679                             .src_in_bin          (wr_pntr_ext),
680                             .dest_clk            (rd_clk),
681                             .dest_out_bin        (wr_pntr_rd_cdc_dc));
682                     
683                         // Register the output of XPM_CDC_GRAY on read side
684                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
685                           wpr_gray_reg_dc (rd_rst_i, rd_clk, wr_pntr_rd_cdc_dc, wr_pntr_rd_dc);
686                     
687                         // Synchronize the read pointer in wr_clk domain
688                         xpm_cdc_gray #(
689                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
690                           .INIT_SYNC_FF          (1),
691                           .WIDTH                 (RD_PNTR_WIDTH))
692                           rd_pntr_cdc_inst (
693                             .src_clk             (rd_clk),
694                             .src_in_bin          (rd_pntr),
695                             .dest_clk            (wr_clk),
696                             .dest_out_bin        (rd_pntr_wr_cdc));
697                     
698                         // Register the output of XPM_CDC_GRAY on write side
699                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
700                           rpw_gray_reg (wrst_busy, wr_clk, rd_pntr_wr_cdc, rd_pntr_wr);
701                     
702                         // Synchronize the read pointer, subtracted by the extra word read for FWFT, in wr_clk domain
703                         xpm_cdc_gray #(
704                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
705                           .INIT_SYNC_FF          (1),
706                           .WIDTH                 (RD_PNTR_WIDTH+1))
707                           rd_pntr_cdc_dc_inst (
708                             .src_clk             (rd_clk),
709                             .src_in_bin          (rd_pntr_ext-extra_words_fwft),
710                             .dest_clk            (wr_clk),
711                             .dest_out_bin        (rd_pntr_wr_cdc_dc));
712                     
713                         // Register the output of XPM_CDC_GRAY on write side
714                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
715                           rpw_gray_reg_dc (wrst_busy, wr_clk, rd_pntr_wr_cdc_dc, rd_pntr_wr_dc);
716                     
717                       end : gen_cdc_pntr
718                     
719                       if (RELATED_CLOCKS == 1) begin : gen_pntr_pf_rc
720                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
721                           rpw_rc_reg (wrst_busy, wr_clk, rd_pntr, rd_pntr_wr);
722                     
723                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
724                           wpr_rc_reg (rd_rst_i, rd_clk, wr_pntr, wr_pntr_rd);
725                     
726                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
727                           wpr_rc_reg_dc (rd_rst_i, rd_clk, wr_pntr_ext, wr_pntr_rd_dc);
728                     
729                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
730                           rpw_rc_reg_dc (wrst_busy, wr_clk, (rd_pntr_ext-extra_words_fwft), rd_pntr_wr_dc);
731                       end : gen_pntr_pf_rc
732                     
733                       if (COMMON_CLOCK == 0 || RELATED_CLOCKS == 1) begin : gen_pf_ic_rc
734                       
735                         assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_rd_en_i);
736                         assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr));
737                         assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ram_rd_en_i);
738                         assign leaving_aempty  = ((wr_pntr_rd_adj == rd_pntr_plus1));
739                       
740                         assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i);
741                         assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr_plus1));
742                         assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus3) &amp; ram_wr_en_i);
743                         assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus2));
744                       
745                         // Empty flag generation
746                         always @ (posedge rd_clk) begin
747                           if (rd_rst_i) begin
748                              ram_empty_i  &lt;= 1'b1;
749                           end else begin
750                              ram_empty_i  &lt;= going_empty | leaving_empty;
751                           end
752                         end
753                     
754                         if (EN_AE == 1) begin : gae_ic_std
755                           always @ (posedge rd_clk) begin
756                             if (rd_rst_i) begin
757                               ram_aempty_i &lt;= 1'b1;
758                             end else if (~ram_empty_i) begin
759                               ram_aempty_i &lt;= going_aempty | leaving_aempty;
760                             end
761                           end
762                         end : gae_ic_std
763                       
764                         // Full flag generation
765                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
766                           always @ (posedge wr_clk) begin
767                     	if (wrst_busy) begin
768                               ram_full_i      &lt;= FULL_RST_VAL;
769                               ram_full_n      &lt;= ~FULL_RST_VAL;
770                             end else begin
771                     	  if (clr_full) begin
772                                 ram_full_i    &lt;= 1'b0;
773                                 ram_full_n    &lt;= 1'b1;
774                     	  end else begin
775                                 ram_full_i    &lt;= going_full | leaving_full;
776                                 ram_full_n    &lt;= ~(going_full | leaving_full);
777                               end
778                             end
779                           end
780                         end : gen_full_rst_val
781                         else begin : ngen_full_rst_val
782                           always @ (posedge wr_clk) begin
783                     	if (wrst_busy) begin
784                               ram_full_i   &lt;= 1'b0;
785                               ram_full_n   &lt;= 1'b1;
786                     	end else begin
787                               ram_full_i   &lt;= going_full | leaving_full;
788                               ram_full_n   &lt;= ~(going_full | leaving_full);
789                     	end
790                           end
791                         end : ngen_full_rst_val
792                     
793                         if (EN_AF == 1) begin : gaf_ic
794                           always @ (posedge wr_clk) begin
795                     	if (wrst_busy) begin
796                               ram_afull_i  &lt;= FULL_RST_VAL;
797                             end else if (~rst) begin
798                     	  if (clr_full) begin
799                                 ram_afull_i  &lt;= 1'b0;
800                     	  end else if (~ram_full_i) begin
801                                 ram_afull_i  &lt;= going_afull | leaving_afull;
802                               end
803                             end
804                           end
805                         end : gaf_ic
806                     
807                       // synthesis translate_off
808                         `ifndef DISABLE_XPM_ASSERTIONS
809                         if (SIM_ASSERT_CHK == 1) begin: assert_wr_rd_en
810                           always @ (posedge rd_clk) begin
811                             assert (!$isunknown(rd_en)) else $warning (&quot;Input port 'rd_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'rd_en' has a valid value ('0' or '1')&quot;,$time);
812                           end
813                     
814                           always @ (posedge wr_clk) begin
815                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
816                           end
817                     
818                           always @ (posedge wr_clk) begin
819                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
820                           end
821                     
822                         end : assert_wr_rd_en
823                         `endif
824                       // synthesis translate_on
825                     
826                         // Programmable Full flag generation
827                         if (EN_PF == 1) begin : gpf_ic
828                           assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
829                           assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
830                       
831                           // PF carry generation
832                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i;
833                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i;
834                       
835                           // PF diff pointer generation
836                           always @ (posedge wr_clk) begin
837                             if (wrst_busy)
838                                diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
839                             else
840                                diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
841                           end
842                           assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
843                       
844                           always @ (posedge wr_clk) begin
845                             if (wrst_busy)
846                                prog_full_i  &lt;= FULL_RST_VAL;
847                             else if (clr_full)
848                                prog_full_i  &lt;= 1'b0;
849                             else if (~ram_full_i) begin
850                               if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
851                                 prog_full_i  &lt;= 1'b1;
852                               else
853                                 prog_full_i  &lt;= 1'b0;
854                             end else
855                               prog_full_i  &lt;= prog_full_i;
856                           end
857                         end : gpf_ic
858                     
859                         /*********************************************************
860                          * Programmable EMPTY flags
861                          *********************************************************/
862                         //Determine the Assert and Negate thresholds for Programmable Empty
863                         if (EN_PE == 1) begin : gpe_ic
864                      
865                           always @(posedge rd_clk) begin
866                             if (rd_rst_i) begin
867                               diff_pntr_pe      &lt;= 0;
868                               prog_empty_i       &lt;= 1'b1;
869                             end else begin
870                               if (ram_rd_en_i)
871                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr) - 1'h1;
872                               else
873                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr);
874                          
875                               if (~empty_i) begin
876                                 if (diff_pntr_pe &lt;= PE_THRESH_ADJ)
877                                   prog_empty_i &lt;= 1'b1;
878                                 else
879                                   prog_empty_i &lt;= 1'b0;
880                               end else
881                                 prog_empty_i   &lt;= prog_empty_i;
882                             end
883                           end
884                         end : gpe_ic
885                       end : gen_pf_ic_rc
886                     
887                       if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_pntr_flags_cc
888                         assign wr_pntr_rd = wr_pntr;
889                         assign rd_pntr_wr = rd_pntr;
890                         assign wr_pntr_rd_dc = wr_pntr_ext;
891                         assign rd_pntr_wr_dc = rd_pntr_ext-extra_words_fwft;
892                         assign write_allow  = ram_wr_en_i &amp; ~ram_full_i;
893                         assign read_allow   = ram_rd_en_i &amp; ~empty_i;
894                     
895                         if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
896                           assign ram_wr_en_pf  = ram_wr_en_i;
897                           assign ram_rd_en_pf  = ram_rd_en_i;
898                       
899                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
900                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
901                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
902                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
903                       
904                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
905                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
906                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
907                           assign leaving_afull  = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_rd_en_i &amp; ~ram_wr_en_i);
908                     
909                           assign write_only    = write_allow &amp; ~read_allow;
910                           assign read_only     = read_allow &amp; ~write_allow;
911                     
912                         end : wrp_eq_rdp
913                       
914                         if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
915                           assign wrp_gt_rdp_and_red = &amp;wr_pntr_rd[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0];
916                       
917                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
918                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red));
919                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
920                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ~ram_rd_en_i);
921                       
922                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
923                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
924                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
925                           assign leaving_afull  = (((rd_pntr_wr_adj == wr_pntr) | (rd_pntr_wr_adj == wr_pntr_plus1) | (rd_pntr_wr_adj == wr_pntr_plus2)) &amp; ram_rd_en_i);
926                       
927                           assign ram_wr_en_pf  = ram_wr_en_i &amp; wrp_gt_rdp_and_red;
928                           assign ram_rd_en_pf  = ram_rd_en_i;
929                     
930                           assign read_only     = read_allow &amp; (~(write_allow  &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0])));
931                           assign write_only    = write_allow &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0]) &amp; ~read_allow;
932                     
933                     
934                         end : wrp_gt_rdp
935                       
936                         if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
937                           assign wrp_lt_rdp_and_red = &amp;rd_pntr_wr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0];
938                       
939                           assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
940                           assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
941                           assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
942                           assign leaving_aempty  = (((wr_pntr_rd_adj == rd_pntr) | (wr_pntr_rd_adj == rd_pntr_plus1) | (wr_pntr_rd_adj == rd_pntr_plus2)) &amp; ram_wr_en_i);
943                       
944                           assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
945                           assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr) &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
946                           assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
947                           assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~ram_wr_en_i &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
948                       
949                           assign ram_wr_en_pf = ram_wr_en_i;
950                           assign ram_rd_en_pf = ram_rd_en_i &amp; wrp_lt_rdp_and_red;
951                     
952                           assign read_only   = read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0]) &amp; ~write_allow;
953                           assign write_only    = write_allow    &amp; (~(read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0])));
954                         end : wrp_lt_rdp
955                       
956                         // Empty flag generation
957                         always @ (posedge rd_clk) begin
958        1/1                if (rd_rst_i) begin
959        1/1                   ram_empty_i  &lt;= 1'b1;
960                           end else begin
961        1/1                   ram_empty_i  &lt;= going_empty | (~leaving_empty &amp; ram_empty_i);
962                           end
963                         end
964                     
965                         if (EN_AE == 1) begin : gae_cc_std
966                           always @ (posedge rd_clk) begin
967                             if (rd_rst_i) begin
968                               ram_aempty_i &lt;= 1'b1;
969                             end else begin
970                               ram_aempty_i &lt;= going_aempty | (~leaving_aempty &amp; ram_aempty_i);
971                             end
972                           end
973                         end : gae_cc_std
974                     
975                         // Full flag generation
976                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
977                           always @ (posedge wr_clk) begin
978                     	if (wrst_busy) begin
979                               ram_full_i   &lt;= FULL_RST_VAL;
980                               ram_full_n   &lt;= ~FULL_RST_VAL;
981                             end else begin
982                     	  if (clr_full) begin
983                                 ram_full_i   &lt;= 1'b0;
984                                 ram_full_n   &lt;= 1'b1;
985                     	  end else begin
986                                 ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
987                                 ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
988                               end
989                             end
990                           end
991                         end : gen_full_rst_val
992                         else begin : ngen_full_rst_val
993                           always @ (posedge wr_clk) begin
994        1/1          	if (wrst_busy) begin
995        1/1                    ram_full_i   &lt;= 1'b0;
996        1/1                    ram_full_n   &lt;= 1'b1;
997                     	end else begin
998        1/1                    ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
999        1/1                    ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
1000                    	end
1001                          end
1002                        end : ngen_full_rst_val
1003                    
1004                        if (EN_AF == 1) begin : gaf_cc
1005                          always @ (posedge wr_clk) begin
1006                    	if (wrst_busy) begin
1007                              ram_afull_i  &lt;= FULL_RST_VAL;
1008                            end else if (~rst) begin
1009                    	  if (clr_full) begin
1010                                ram_afull_i  &lt;= 1'b0;
1011                    	  end else begin
1012                                ram_afull_i  &lt;= going_afull | (~leaving_afull &amp; ram_afull_i);
1013                              end
1014                            end
1015                          end
1016                        end : gaf_cc
1017                        // Programmable Full flag generation
1018                        if ((WR_PNTR_WIDTH == RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_eq_rdp_pf_cc
1019                          if (EN_PF == 1) begin : gpf_cc_sym
1020                    
1021                            assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
1022                            assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
1023                      
1024                            // Delayed write/read enable for PF generation
1025                            always @ (posedge wr_clk) begin
1026       1/1                    if (wrst_busy) begin
1027       1/1                       ram_wr_en_pf_q   &lt;= 1'b0;
1028       1/1                       ram_rd_en_pf_q   &lt;= 1'b0;
1029                              end else begin
1030       1/1                       ram_wr_en_pf_q   &lt;= ram_wr_en_pf;
1031       1/1                       ram_rd_en_pf_q   &lt;= ram_rd_en_pf;
1032                              end
1033                            end
1034                      
1035                            // PF carry generation
1036                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i &amp; ~ram_rd_en_pf;
1037                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i &amp; ~ram_rd_en_pf;
1038                      
1039                            // PF diff pointer generation
1040                            always @ (posedge wr_clk) begin
1041       1/1                    if (wrst_busy)
1042       1/1                       diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1043                              else
1044       1/1                       diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
1045                            end
1046                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1047                      
1048                            always @ (posedge wr_clk) begin
1049       1/1                    if (wrst_busy)
1050       1/1                       prog_full_i  &lt;= FULL_RST_VAL;
1051       1/1                    else if (clr_full)
1052       1/1                       prog_full_i  &lt;= 1'b0;
1053       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ram_wr_en_pf_q &amp; ~ram_rd_en_pf_q)
1054       1/1                       prog_full_i  &lt;= 1'b1;
1055       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ~ram_wr_en_pf_q &amp; ram_rd_en_pf_q)
1056       <font color = "red">0/1     ==>               prog_full_i  &lt;= 1'b0;</font>
1057                              else
1058       1/1                       prog_full_i  &lt;= prog_full_i;
1059                            end
1060                          end : gpf_cc_sym
1061                    
1062                          if (EN_PE == 1) begin : gpe_cc_sym
1063                            always @(posedge rd_clk) begin
1064       1/1                    if (rd_rst_i) begin
1065       1/1                      read_only_q    &lt;= 1'b0;
1066       1/1                      write_only_q   &lt;= 1'b0;
1067       1/1                      diff_pntr_pe   &lt;= 0;
1068                              end 
1069                              else begin
1070       1/1                      read_only_q  &lt;= read_only;
1071       1/1                      write_only_q &lt;= write_only;
1072                                // Add 1 to the difference pointer value when write or both write &amp; read or no write &amp; read happen.
1073       1/1                      if (read_only)
1074       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr - 1;
1075                                else
1076       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr;
1077                              end
1078                            end
1079                      
1080                            always @(posedge rd_clk) begin
1081       1/1                    if (rd_rst_i)
1082       1/1                      prog_empty_i  &lt;= 1'b1;
1083                              else begin
1084       1/1                      if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; read_only_q)
1085       <font color = "red">0/1     ==>                prog_empty_i &lt;= 1'b1;</font>
1086       1/1                      else if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; write_only_q)
1087       1/1                        prog_empty_i &lt;= 1'b0;
1088                                else
1089       1/1                        prog_empty_i &lt;= prog_empty_i;
1090                              end
1091                            end
1092                          end : gpe_cc_sym
1093                        end : wrp_eq_rdp_pf_cc
1094                    
1095                        if ((WR_PNTR_WIDTH != RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_neq_rdp_pf_cc
1096                          if (EN_PF == 1) begin : gpf_cc_asym
1097                            // PF diff pointer generation
1098                            always @ (posedge wr_clk) begin
1099                              if (wrst_busy)
1100                                 diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1101                              else if (~ram_full_i)
1102                                 diff_pntr_pf_q[WR_PNTR_WIDTH:1]  &lt;= wr_pntr + ~rd_pntr_wr_adj + 1;
1103                            end
1104                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1105                            always @ (posedge wr_clk) begin
1106                              if (wrst_busy)
1107                                 prog_full_i  &lt;= FULL_RST_VAL;
1108                              else if (clr_full)
1109                                 prog_full_i  &lt;= 1'b0;
1110                              else if (~ram_full_i) begin
1111                                if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
1112                                   prog_full_i  &lt;= 1'b1;
1113                                else if (diff_pntr_pf &lt; PF_THRESH_ADJ)
1114                                   prog_full_i  &lt;= 1'b0;
1115                                else
1116                                   prog_full_i  &lt;= prog_full_i;
1117                              end
1118                            end
1119                          end : gpf_cc_asym
1120                          if (EN_PE == 1) begin : gpe_cc_asym
1121                            // Programmanble Empty flag Generation
1122                            // Diff pointer Generation
1123                            localparam [RD_PNTR_WIDTH-1 : 0] DIFF_MAX_RD = {RD_PNTR_WIDTH{1'b1}};
1124                            wire [RD_PNTR_WIDTH-1:0] diff_pntr_pe_max;
1125                            wire                     carry;
1126                            reg  [RD_PNTR_WIDTH : 0] diff_pntr_pe_asym = 'b0;
1127                            wire [RD_PNTR_WIDTH : 0] wr_pntr_rd_adj_asym;
1128                            wire [RD_PNTR_WIDTH : 0] rd_pntr_asym;
1129                            reg                      full_reg;
1130                            reg                      rst_full_ff_reg1;
1131                            reg                      rst_full_ff_reg2;
1132                      
1133                            assign diff_pntr_pe_max = DIFF_MAX_RD;
1134                            assign wr_pntr_rd_adj_asym[RD_PNTR_WIDTH:0] = {wr_pntr_rd_adj,1'b1};
1135                            assign rd_pntr_asym[RD_PNTR_WIDTH:0] = {~rd_pntr,1'b1};
1136                      
1137                            always @(posedge rd_clk ) begin
1138                              if (rd_rst_i) begin
1139                                diff_pntr_pe_asym    &lt;= 0;
1140                                full_reg             &lt;= 0;
1141                                rst_full_ff_reg1     &lt;= 1;
1142                                rst_full_ff_reg2     &lt;= 1;
1143                                diff_pntr_pe_reg1    &lt;= 0;
1144                              end else begin
1145                                diff_pntr_pe_asym &lt;= wr_pntr_rd_adj_asym + rd_pntr_asym;
1146                                full_reg          &lt;= ram_full_i;
1147                                rst_full_ff_reg1  &lt;= FULL_RST_VAL;
1148                                rst_full_ff_reg2  &lt;= rst_full_ff_reg1;
1149                              end
1150                            end
1151                            wire [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_i;
1152                            assign carry = (~(|(diff_pntr_pe_asym [RD_PNTR_WIDTH : 1])));
1153                            assign diff_pntr_pe_i = (full_reg &amp;&amp; ~rst_d2 &amp;&amp; carry ) ? diff_pntr_pe_max : diff_pntr_pe_asym[RD_PNTR_WIDTH:1];
1154                        
1155                            always @(posedge rd_clk) begin
1156                              if (rd_rst_i)
1157                                prog_empty_i  &lt;= 1'b1;
1158                              else begin
1159                                if (diff_pntr_pe_i &lt;= PE_THRESH_ADJ)
1160                                  prog_empty_i &lt;= 1'b1;
1161                                else if (diff_pntr_pe_i &gt; PE_THRESH_ADJ)
1162                                  prog_empty_i &lt;= 1'b0;
1163                                else
1164                                  prog_empty_i &lt;= prog_empty_i;
1165                              end
1166                            end
1167                          end : gpe_cc_asym
1168                        end : wrp_neq_rdp_pf_cc
1169                    
1170                      end : gen_pntr_flags_cc
1171                    
1172                      if (READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1) begin : gen_regce_std
1173                        xpm_reg_pipe_bit #(FIFO_READ_LATENCY-1, 0)
1174                          regce_pipe_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_regce_pipe);
1175                      end : gen_regce_std
1176                      if (!(READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1)) begin : gnen_regce_std
1177                        assign ram_regce_pipe = 1'b0;
1178                      end : gnen_regce_std
1179                    
1180                      if (!((READ_MODE == 1 || READ_MODE == 2)&amp;&amp; FIFO_MEMORY_TYPE != 4)) begin : gn_fwft
1181                       assign invalid_state = 1'b0;
1182                      end : gn_fwft
1183                      //if (READ_MODE == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1184                      if (READ_MODE != 0 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1185                      // First word fall through logic
1186                    
1187                       //localparam invalid             = 0;
1188                       //localparam stage1_valid        = 2;
1189                       //localparam stage2_valid        = 1;
1190                       //localparam both_stages_valid   = 3;
1191                    
1192                       //reg  [1:0] curr_fwft_state = invalid;
1193                       //reg  [1:0] next_fwft_state;// = invalid;
1194                       wire next_fwft_state_d1;
1195                       assign invalid_state = ~|curr_fwft_state;
1196                       assign valid_fwft = next_fwft_state_d1;
1197                       assign ram_valid_fwft = curr_fwft_state[1];
1198                    
1199                        xpm_fifo_reg_bit #(0)
1200                          next_state_d1_inst (1'b0, rd_clk, next_fwft_state[0], next_fwft_state_d1);
1201                       //FSM : To generate the enable, clock enable for xpm_memory and to generate
1202                       //empty signal
1203                       //FSM : Next state Assignment
1204                         if (READ_MODE == 1) begin : gen_fwft_ns
1205                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1206                           case (curr_fwft_state)
1207                             invalid: begin
1208                               if (~ram_empty_i)
1209                                  next_fwft_state     = stage1_valid;
1210                               else
1211                                  next_fwft_state     = invalid;
1212                               end
1213                             stage1_valid: begin
1214                               if (ram_empty_i)
1215                                  next_fwft_state     = stage2_valid;
1216                               else
1217                                  next_fwft_state     = both_stages_valid;
1218                               end
1219                             stage2_valid: begin
1220                               if (ram_empty_i &amp;&amp; rd_en)
1221                                  next_fwft_state     = invalid;
1222                               else if (~ram_empty_i &amp;&amp; rd_en)
1223                                  next_fwft_state     = stage1_valid;
1224                               else if (~ram_empty_i &amp;&amp; ~rd_en)
1225                                  next_fwft_state     = both_stages_valid;
1226                               else
1227                                  next_fwft_state     = stage2_valid;
1228                               end
1229                             both_stages_valid: begin
1230                               if (ram_empty_i &amp;&amp; rd_en)
1231                                  next_fwft_state     = stage2_valid;
1232                               else if (~ram_empty_i &amp;&amp; rd_en)
1233                                  next_fwft_state     = both_stages_valid;
1234                               else
1235                                  next_fwft_state     = both_stages_valid;
1236                               end
1237                             default: next_fwft_state    = invalid;
1238                           endcase
1239                         end
1240                         end : gen_fwft_ns
1241                         if (READ_MODE == 2) begin : gen_fwft_ns_ll
1242                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1243                           case (curr_fwft_state)
1244                             invalid: begin
1245                               if (~ram_empty_i)
1246                                  next_fwft_state     = stage1_valid;
1247                               else
1248                                  next_fwft_state     = invalid;
1249                               end
1250                             stage1_valid: begin
1251                               if (ram_empty_i &amp;&amp; rd_en)
1252                                  next_fwft_state     = invalid;
1253                               else
1254                                  next_fwft_state     = stage1_valid;
1255                               end
1256                             default: next_fwft_state    = invalid;
1257                           endcase
1258                         end
1259                         end : gen_fwft_ns_ll
1260                         // FSM : current state assignment
1261                         always @ (posedge rd_clk) begin
1262                           if (rd_rst_i)
1263                              curr_fwft_state  &lt;= invalid;
1264                           else
1265                              curr_fwft_state  &lt;= next_fwft_state;
1266                         end
1267                     
1268                         reg ram_regout_en;
1269                    
1270                         // FSM(output assignments) : clock enable generation for xpm_memory
1271                         if (READ_MODE == 1) begin : gen_fwft_ro
1272                         always @(curr_fwft_state or rd_en) begin
1273                           case (curr_fwft_state)
1274                             invalid:           ram_regout_en = 1'b0;
1275                             stage1_valid:      ram_regout_en = 1'b1;
1276                             stage2_valid:      ram_regout_en = 1'b0;
1277                             both_stages_valid: ram_regout_en = rd_en;
1278                             default:           ram_regout_en = 1'b0;
1279                           endcase
1280                         end
1281                         end : gen_fwft_ro
1282                         if (READ_MODE == 2) begin : gen_fwft_ro_ll
1283                         always @(curr_fwft_state or rd_en or ram_empty_i or fe_of_empty) begin
1284                           case (curr_fwft_state)
1285                             invalid:           ram_regout_en = fe_of_empty;
1286                             stage1_valid:      ram_regout_en = rd_en &amp; !ram_empty_i;
1287                             default:           ram_regout_en = 1'b0;
1288                           endcase
1289                         end
1290                         end : gen_fwft_ro_ll
1291                    
1292                         // FSM(output assignments) : rd_en (enable) signal generation for xpm_memory
1293                         if (READ_MODE == 1) begin : gen_fwft_re
1294                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1295                           case (curr_fwft_state)
1296                             invalid :
1297                               if (~ram_empty_i)
1298                                 rd_en_fwft = 1'b1;
1299                               else
1300                                 rd_en_fwft = 1'b0;
1301                             stage1_valid :
1302                               if (~ram_empty_i)
1303                                 rd_en_fwft = 1'b1;
1304                               else
1305                                 rd_en_fwft = 1'b0;
1306                             stage2_valid :
1307                               if (~ram_empty_i)
1308                                 rd_en_fwft = 1'b1;
1309                               else
1310                                 rd_en_fwft = 1'b0;
1311                             both_stages_valid :
1312                               if (~ram_empty_i &amp;&amp; rd_en)
1313                                 rd_en_fwft = 1'b1;
1314                               else
1315                                 rd_en_fwft = 1'b0;
1316                             default :
1317                               rd_en_fwft = 1'b0;
1318                           endcase
1319                         end
1320                         end : gen_fwft_re
1321                         if (READ_MODE == 2) begin : gen_fwft_re_ll
1322                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1323                           case (curr_fwft_state)
1324                             invalid :
1325                               if (~ram_empty_i)
1326                                 rd_en_fwft = 1'b1;
1327                               else
1328                                 rd_en_fwft = 1'b0;
1329                             stage1_valid :
1330                               if (~ram_empty_i &amp;&amp; rd_en)
1331                                 rd_en_fwft = 1'b1;
1332                               else
1333                                 rd_en_fwft = 1'b0;
1334                             default :
1335                               rd_en_fwft = 1'b0;
1336                           endcase
1337                         end
1338                         end : gen_fwft_re_ll
1339                         // assingment to control regce xpm_memory
1340                         assign ram_regce = ram_regout_en;
1341                    
1342                         reg going_empty_fwft;
1343                         reg leaving_empty_fwft;
1344                    
1345                         if (READ_MODE == 1) begin : gen_fwft_ge
1346                         always @(curr_fwft_state or rd_en) begin
1347                           case (curr_fwft_state)
1348                             stage2_valid : going_empty_fwft = rd_en;
1349                             default      : going_empty_fwft = 1'b0;
1350                           endcase
1351                         end
1352                    
1353                         always @(curr_fwft_state or rd_en) begin
1354                           case (curr_fwft_state)
1355                             stage1_valid : leaving_empty_fwft = 1'b1;
1356                             default      : leaving_empty_fwft = 1'b0;
1357                           endcase
1358                         end
1359                         end : gen_fwft_ge
1360                         if (READ_MODE == 2) begin : gen_fwft_ge_ll
1361                         always @(curr_fwft_state or rd_en or ram_empty_i) begin
1362                           case (curr_fwft_state)
1363                             stage1_valid : going_empty_fwft = rd_en &amp; ram_empty_i;
1364                             default      : going_empty_fwft = 1'b0;
1365                           endcase
1366                         end
1367                    
1368                         always @ (posedge rd_clk) begin
1369                           if (rd_rst_i) begin
1370                              ram_empty_i_d1  &lt;= 1'b1;
1371                           end else begin
1372                              ram_empty_i_d1  &lt;= ram_empty_i;
1373                           end
1374                         end
1375                         assign fe_of_empty = ram_empty_i_d1 &amp; !ram_empty_i;
1376                    
1377                         always @(curr_fwft_state or fe_of_empty) begin
1378                           case (curr_fwft_state)
1379                             invalid      : leaving_empty_fwft = fe_of_empty;
1380                             stage1_valid : leaving_empty_fwft = 1'b1;
1381                             default      : leaving_empty_fwft = 1'b0;
1382                           endcase
1383                         end
1384                         end : gen_fwft_ge_ll
1385                    
1386                         // fwft empty signal generation 
1387                         always @ (posedge rd_clk) begin
1388                           if (rd_rst_i) begin
1389                             empty_fwft_i     &lt;= 1'b1;
1390                             empty_fwft_fb    &lt;= 1'b1;
1391                           end else begin
1392                             empty_fwft_i     &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1393                             empty_fwft_fb    &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1394                           end
1395                         end
1396                    
1397                         if (EN_AE == 1) begin : gae_fwft
1398                           reg going_aempty_fwft;
1399                           reg leaving_aempty_fwft;
1400                    
1401                           if (READ_MODE == 1) begin : gen_fwft_ae
1402                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1403                               case (curr_fwft_state)
1404                                 both_stages_valid : going_aempty_fwft = rd_en &amp; ram_empty_i;
1405                                 default      : going_aempty_fwft = 1'b0;
1406                               endcase
1407                             end
1408                           end : gen_fwft_ae
1409                           if (READ_MODE == 2) begin : gen_fwft_ae_ll
1410                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1411                               case (curr_fwft_state)
1412                                 stage1_valid : going_aempty_fwft = !rd_en &amp; ram_empty_i;
1413                                 default      : going_aempty_fwft = 1'b0;
1414                               endcase
1415                             end
1416                           end : gen_fwft_ae_ll
1417                    
1418                           always @(curr_fwft_state or rd_en or ram_empty_i) begin
1419                             case (curr_fwft_state)
1420                               stage1_valid : leaving_aempty_fwft = ~ram_empty_i;
1421                               stage2_valid : leaving_aempty_fwft = ~(rd_en | ram_empty_i);
1422                               default      : leaving_aempty_fwft = 1'b0;
1423                             endcase
1424                           end
1425                    
1426                           always @ (posedge rd_clk) begin
1427                             if (rd_rst_i) begin
1428                               aempty_fwft_i    &lt;= 1'b1;
1429                             end else begin
1430                               aempty_fwft_i    &lt;= going_aempty_fwft | (~ leaving_aempty_fwft &amp; aempty_fwft_i);
1431                             end
1432                           end
1433                         end : gae_fwft
1434                    
1435                         if (EN_DVLD == 1) begin : gdvld_fwft
1436                           always @ (posedge rd_clk) begin
1437                             if (rd_rst_i) begin
1438                               data_valid_fwft  &lt;= 1'b0;
1439                             end else begin
1440                               data_valid_fwft  &lt;= ~(going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb));
1441                             end
1442                           end
1443                         end : gdvld_fwft
1444                    
1445                        xpm_fifo_reg_bit #(0)
1446                          empty_fwft_d1_inst (1'b0, rd_clk, leaving_empty_fwft, empty_fwft_d1);
1447                    
1448                        wire ge_fwft_d1;
1449                        xpm_fifo_reg_bit #(0)
1450                          ge_fwft_d1_inst (1'b0, rd_clk, going_empty_fwft, ge_fwft_d1);
1451                    
1452                        wire count_up  ;
1453                        wire count_down;
1454                        wire count_en  ;
1455                        wire count_rst ;
1456                        assign count_up   = (next_fwft_state == 2'b10 &amp;&amp; ~|curr_fwft_state) | (curr_fwft_state == 2'b10 &amp;&amp; &amp;next_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; &amp;next_fwft_state);
1457                        assign count_down = (next_fwft_state == 2'b01 &amp;&amp; &amp;curr_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; ~|next_fwft_state);
1458                        assign count_en   = count_up | count_down;
1459                        assign count_rst  = (rd_rst_i | (~|curr_fwft_state &amp; ~|next_fwft_state));
1460                    
1461                        xpm_counter_updn # (2, 0)
1462                          rdpp1_inst (count_rst, rd_clk, count_en, count_up, count_down, extra_words_fwft);
1463                    
1464                     
1465                      end : gen_fwft
1466                    
1467                      if (READ_MODE == 0) begin : ngen_fwft
1468                        assign le_fwft_re       = 1'b0;
1469                        assign le_fwft_fe       = 1'b0;
1470                        assign extra_words_fwft = 2'h0;
1471                      end : ngen_fwft
1472                    
1473                      // output data bus assignment
1474                      if (FG_EQ_ASYM_DOUT == 0) begin : nfg_eq_asym_dout
1475                        assign dout  = dout_i;
1476                      end : nfg_eq_asym_dout
1477                    
1478                      // Overflow and Underflow flag generation
1479                      if (EN_UF == 1) begin : guf
1480                        always @ (posedge rd_clk) begin
1481       1/1                underflow_i &lt;=  (rd_rst_i | empty_i) &amp; rd_en;
1482                        end
1483                        assign underflow   = underflow_i;
1484                      end : guf
1485                      if (EN_UF == 0) begin : gnuf
1486                        assign underflow   = 1'b0;
1487                      end : gnuf
1488                    
1489                      if (EN_OF == 1) begin : gof
1490                        always @ (posedge wr_clk) begin
1491       1/1               overflow_i  &lt;=  (wrst_busy | rst_d1 | ram_full_i) &amp; wr_en;
1492                        end
1493                        assign overflow    = overflow_i;
1494                      end : gof
1495                      if (EN_OF == 0) begin : gnof
1496                        assign overflow    = 1'b0;
1497                      end : gnof
1498                    
1499                      // -------------------------------------------------------------------------------------------------------------------
1500                      // Write Data Count for Independent Clocks FIFO
1501                      // -------------------------------------------------------------------------------------------------------------------
1502                      if (EN_WDC == 1) begin : gwdc
1503                        reg  [WR_DC_WIDTH_EXT-1:0] wr_data_count_i;
1504                        wire [WR_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr;
1505                        assign diff_wr_rd_pntr = wr_pntr_ext-rd_pntr_wr_adj_dc;
1506                        always @ (posedge wr_clk) begin
1507       1/1                if (wrst_busy)
1508       1/1                   wr_data_count_i   &lt;= {WR_DC_WIDTH_EXT{1'b0}};
1509                          else
1510       1/1                   wr_data_count_i  &lt;= diff_wr_rd_pntr;
1511                        end
1512                        assign wr_data_count = wr_data_count_i[WR_DC_WIDTH_EXT-1:WR_DC_WIDTH_EXT-WR_DATA_COUNT_WIDTH];
1513                      end : gwdc
1514                      if (EN_WDC == 0) begin : gnwdc
1515                        assign wr_data_count = {WR_DC_WIDTH_EXT{1'b0}};
1516                      end : gnwdc
1517                    
1518                      // -------------------------------------------------------------------------------------------------------------------
1519                      // Read Data Count for Independent Clocks FIFO
1520                      // -------------------------------------------------------------------------------------------------------------------
1521                      if (EN_RDC == 1) begin : grdc
1522                        reg  [RD_DC_WIDTH_EXT-1:0] rd_data_count_i;
1523                        wire [RD_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr_rdc;
1524                        assign diff_wr_rd_pntr_rdc = wr_pntr_rd_adj_dc-rd_pntr_ext+extra_words_fwft;
1525                        always @ (posedge rd_clk) begin
1526       1/1                if (rd_rst_i | invalid_state)
1527       1/1                   rd_data_count_i   &lt;= {RD_DC_WIDTH_EXT{1'b0}};
1528                          else
1529       1/1                   rd_data_count_i  &lt;= diff_wr_rd_pntr_rdc;
1530                        end
1531                        assign rd_data_count = rd_data_count_i[RD_DC_WIDTH_EXT-1:RD_DC_WIDTH_EXT-RD_DATA_COUNT_WIDTH];
1532                      end : grdc
1533                      if (EN_RDC == 0) begin : gnrdc
1534                        assign rd_data_count = {RD_DC_WIDTH_EXT{1'b0}};
1535                      end : gnrdc
1536                    
1537                      endgenerate
1538                    
1539                      // -------------------------------------------------------------------------------------------------------------------
1540                      // Simulation constructs
1541                      // -------------------------------------------------------------------------------------------------------------------
1542                      // synthesis translate_off
1543                    
1544                     `ifndef DISABLE_XPM_ASSERTIONS  
1545                      initial begin
1546       2/2            #1;
1547       1/1              if (SIM_ASSERT_CHK == 1)
1548                        `ifdef OBSOLETE
1549                          $warning(&quot;Vivado Simulator does not currently support the SystemVerilog Assertion syntax used within XPM_FIFO.  \
1550                    Messages related to potential misuse will not be reported.&quot;);
1551                        `else
1552       <font color = "red">0/1     ==>        $warning(&quot;SIM_ASSERT_CHK (%0d) specifies simulation message reporting, messages related to potential misuse \</font>
                        MISSING_ELSE
</pre>
<hr>
<a name="inst_tag_274_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod18.html#inst_tag_274" >AdaptedSharpener.fifo.lineBuffer_3.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">Conditions</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="s6"><td class="lf">Logical</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1084
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; read_only_q)
             ---------------1---------------    -----2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1086
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; write_only_q)
             ---------------1---------------    ------2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_274_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod18.html#inst_tag_274" >AdaptedSharpener.fifo.lineBuffer_3.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s3">
<td>Totals</td>
<td class="rt">129</td>
<td class="rt">50</td>
<td class="rt">38.76 </td>
</tr><tr class="s7">
<td>Total Bits</td>
<td class="rt">864</td>
<td class="rt">606</td>
<td class="rt">70.14 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 0->1</td>
<td class="rt">432</td>
<td class="rt">304</td>
<td class="rt">70.37 </td>
</tr><tr class="s6">
<td nowrap>Total Bits 1->0</td>
<td class="rt">432</td>
<td class="rt">302</td>
<td class="rt">69.91 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s2">
<td>Ports</td>
<td class="rt">27</td>
<td class="rt">8</td>
<td class="rt">29.63 </td>
</tr><tr class="s8">
<td>Port Bits</td>
<td class="rt">178</td>
<td class="rt">144</td>
<td class="rt">80.90 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 0->1</td>
<td class="rt">89</td>
<td class="rt">71</td>
<td class="rt">79.78 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 1->0</td>
<td class="rt">89</td>
<td class="rt">73</td>
<td class="rt">82.02 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s4">
<td>Signals</td>
<td class="rt">102</td>
<td class="rt">42</td>
<td class="rt">41.18 </td>
</tr><tr class="s6">
<td>Signal Bits</td>
<td class="rt">686</td>
<td class="rt">462</td>
<td class="rt">67.35 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">343</td>
<td class="rt">233</td>
<td class="rt">67.93 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">343</td>
<td class="rt">229</td>
<td class="rt">66.76 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>sleep</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>rst</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>wr_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>wr_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>din[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_data_count</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_ack</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rd_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>dout[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>empty</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_empty</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_data_count</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>data_valid</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>injectsbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>injectdbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>dbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>curr_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>next_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus2[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus3[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_plus1_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_inv_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pf_q[6:1]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>invalid_state</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>going_aempty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_aempty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_aempty_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>prog_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_afull_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_ack_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_en_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce_pipe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dout_i[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>aempty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_fwft_fb</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>overflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>underflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_vld_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_gt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_lt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_wr_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe_reg1[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe_reg2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>prog_empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_empty_i_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>fe_of_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_en_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_d2</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rst_d1</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rst_d2</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>clr_full</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extra_words_fwft[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gen_sdpram.rst_int</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.rd_data_count_i[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.rd_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_271'>
<a name="inst_tag_271_Line"></a>
<b>Line Coverage for Instance : <a href="mod18.html#inst_tag_271" >AdaptedSharpener.fifo.lineBuffer_0.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">TOTAL</td><td></td><td>142</td><td>86</td><td>60.56</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>126</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">ROUTINE</td><td>304</td><td>5</td><td>4</td><td>80.00</td></tr>
<tr class="s3"><td class="lf">INITIAL</td><td>314</td><td>81</td><td>29</td><td>35.80</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>958</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>994</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1026</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1041</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1049</td><td>9</td><td>8</td><td>88.89</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1064</td><td>9</td><td>9</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1081</td><td>7</td><td>6</td><td>85.71</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1481</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1491</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1507</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1526</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">INITIAL</td><td>1546</td><td>4</td><td>3</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
125                       begin 
126        1/1              value = value-1;
127        1/1              for (clog2=0; value&gt;0; clog2=clog2+1)
128        1/1                value = value&gt;&gt;1;
129                         end 
130                       endfunction
131                       // Function to convert ASCII value to binary 
132                       function [3:0] str2bin;
133                         input [7:0] str_val_ascii;
134                           if((str_val_ascii == 8'h30) || (str_val_ascii == 8'h31) || 
135                              (str_val_ascii == 8'h32) || (str_val_ascii == 8'h33) || 
136                              (str_val_ascii == 8'h34) || (str_val_ascii == 8'h35) || 
137                              (str_val_ascii == 8'h36) || (str_val_ascii == 8'h37) || 
138                              (str_val_ascii == 8'h38) || (str_val_ascii == 8'h39) || 
139                              (str_val_ascii == 8'h41) || (str_val_ascii == 8'h42) || 
140                              (str_val_ascii == 8'h43) || (str_val_ascii == 8'h44) || 
141                              (str_val_ascii == 8'h45) || (str_val_ascii == 8'h46) || 
142                              (str_val_ascii == 8'h61) || (str_val_ascii == 8'h62) || 
143                              (str_val_ascii == 8'h63) || (str_val_ascii == 8'h64) || 
144                              (str_val_ascii == 8'h65) || (str_val_ascii == 8'h66) || 
145                              (str_val_ascii == 8'h00)) begin
146                              if (!str_val_ascii[6])
147                                 str2bin = str_val_ascii[3:0];
148                              else begin
149                                str2bin [3] = 1'b1;
150                                str2bin [2] = str_val_ascii[2] | (str_val_ascii[1] &amp; str_val_ascii[0]);
151                                str2bin [1] = str_val_ascii[0] ^ str_val_ascii[1];
152                                str2bin [0] = !str_val_ascii[0];
153                              end
154                           end
155                           else
156                             $error(&quot;Found Invalid character while parsing the string, please cross check the value specified for either READ_RESET_VALUE_A|B or MEMORY_INIT_PARAM (if initialization of memory through parameter is used). XPM_MEMORY supports strings (hex) that contains characters 0-9, A-F and a-f.&quot;);
157                       endfunction
158                       // Function that parses the complete reset value string
159                       function logic [15:0] hstr2bin;
160                         input [16*8-1 : 0] hstr_val;
161                         integer rst_loop_a;
162                         localparam integer  rsta_loop_iter  =  16;
163                         logic [rsta_loop_iter-1 : 0] rst_val_conv_a_i;
164                         for (rst_loop_a=1; rst_loop_a &lt;= rsta_loop_iter/4; rst_loop_a = rst_loop_a+1) begin
165                           rst_val_conv_a_i[(rst_loop_a*4)-1 -: 4] =  str2bin(hstr_val[(rst_loop_a*8)-1 -: 8]);
166                         end
167                         return rst_val_conv_a_i[15:0];
168                       endfunction
169                     
170                     
171                       localparam invalid             = 0;
172                       localparam stage1_valid        = 2;
173                       localparam stage2_valid        = 1;
174                       localparam both_stages_valid   = 3;
175                     
176                       reg  [1:0] curr_fwft_state = invalid;
177                       reg  [1:0] next_fwft_state;// = invalid;
178                     
179                     
180                     
181                       localparam FIFO_MEM_TYPE   = FIFO_MEMORY_TYPE;
182                       localparam RD_MODE         = READ_MODE;
183                       localparam ENABLE_ECC      = (ECC_MODE == 1) ? 3 : 0;
184                       localparam FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH;
185                       localparam FIFO_SIZE       = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH;
186                       localparam WR_WIDTH_LOG    = clog2(WRITE_DATA_WIDTH);
187                       localparam WR_DEPTH_LOG    = clog2(FIFO_WRITE_DEPTH);
188                       localparam WR_PNTR_WIDTH   = clog2(FIFO_WRITE_DEPTH);
189                       localparam RD_PNTR_WIDTH   = clog2(FIFO_READ_DEPTH);
190                       localparam FULL_RST_VAL    = FULL_RESET_VALUE == 0 ? 1'b0 : 1'b1;
191                       localparam WR_RD_RATIO     = (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) ? (WR_PNTR_WIDTH-RD_PNTR_WIDTH) : 0;
192                       localparam READ_MODE_LL    = (READ_MODE == 0) ? 0 : 1;
193                       localparam PF_THRESH_ADJ   = (READ_MODE == 0) ? PROG_FULL_THRESH :
194                                                    PROG_FULL_THRESH - (2*(2**WR_RD_RATIO));
195                       localparam PE_THRESH_ADJ   = (READ_MODE_LL == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) ? PROG_EMPTY_THRESH - 2'h2 : PROG_EMPTY_THRESH;
196                     
197                       localparam PF_THRESH_MIN   = 3+(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1))+(COMMON_CLOCK?0:CDC_DEST_SYNC_FF);
198                       localparam PF_THRESH_MAX   = (FIFO_WRITE_DEPTH-3)-(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1));
199                       localparam PE_THRESH_MIN   = 3+(READ_MODE_LL*2);
200                       localparam PE_THRESH_MAX   = (FIFO_READ_DEPTH-3)-(READ_MODE_LL*2);
201                       localparam WR_DC_WIDTH_EXT = clog2(FIFO_WRITE_DEPTH)+1;
202                       localparam RD_DC_WIDTH_EXT = clog2(FIFO_READ_DEPTH)+1;
203                       localparam RD_LATENCY      = (READ_MODE == 2) ? 1 : (READ_MODE == 1) ? 2 : FIFO_READ_LATENCY;
204                       localparam WIDTH_RATIO     = (READ_DATA_WIDTH &gt; WRITE_DATA_WIDTH) ? (READ_DATA_WIDTH/WRITE_DATA_WIDTH) : (WRITE_DATA_WIDTH/READ_DATA_WIDTH);
205                     
206                       localparam [15:0] EN_ADV_FEATURE = hstr2bin(USE_ADV_FEATURES);
207                     
208                       localparam EN_OF           = EN_ADV_FEATURE[0];  //EN_ADV_FLAGS_WR[0] ? 1 : 0;
209                       localparam EN_PF           = EN_ADV_FEATURE[1];  //EN_ADV_FLAGS_WR[1] ? 1 : 0;
210                       localparam EN_WDC          = EN_ADV_FEATURE[2];  //EN_ADV_FLAGS_WR[2] ? 1 : 0;
211                       localparam EN_AF           = EN_ADV_FEATURE[3];  //EN_ADV_FLAGS_WR[3] ? 1 : 0;
212                       localparam EN_WACK         = EN_ADV_FEATURE[4];  //EN_ADV_FLAGS_WR[4] ? 1 : 0;
213                       localparam FG_EQ_ASYM_DOUT = EN_ADV_FEATURE[5];  //EN_ADV_FLAGS_WR[5] ? 1 : 0;
214                       localparam EN_UF           = EN_ADV_FEATURE[8];  //EN_ADV_FLAGS_RD[0] ? 1 : 0;
215                       localparam EN_PE           = EN_ADV_FEATURE[9];  //EN_ADV_FLAGS_RD[1] ? 1 : 0;
216                       localparam EN_RDC          = EN_ADV_FEATURE[10]; //EN_ADV_FLAGS_RD[2] ? 1 : 0;
217                       localparam EN_AE           = EN_ADV_FEATURE[11]; //EN_ADV_FLAGS_RD[3] ? 1 : 0;
218                       localparam EN_DVLD         = EN_ADV_FEATURE[12]; //EN_ADV_FLAGS_RD[4] ? 1 : 0;
219                     
220                       wire                       wrst_busy;
221                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr;
222                       wire [WR_PNTR_WIDTH:0]     wr_pntr_ext;
223                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd_cdc;
224                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_cdc_dc;
225                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd;
226                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_dc;
227                       wire [WR_PNTR_WIDTH-1:0]   rd_pntr_wr_adj;
228                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_dc;
229                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus1;
230                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus2;
231                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus3;
232                       wire [WR_PNTR_WIDTH:0]     wr_pntr_plus1_pf;
233                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_inv_pf;
234                       reg  [WR_PNTR_WIDTH:0]     diff_pntr_pf_q = {WR_PNTR_WIDTH{1'b0}};
235                       wire [WR_PNTR_WIDTH-1:0]   diff_pntr_pf;
236                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr;
237                       wire [RD_PNTR_WIDTH:0]     rd_pntr_ext;
238                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr_cdc;
239                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr;
240                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_cdc_dc;
241                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_dc;
242                       wire [RD_PNTR_WIDTH-1:0]   wr_pntr_rd_adj;
243                       wire [RD_PNTR_WIDTH:0]     wr_pntr_rd_adj_dc;
244                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus1;
245                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus2;
246                       wire                       invalid_state;
247                       wire                       valid_fwft;
248                       wire                       ram_valid_fwft;
249                       wire                       going_empty;
250                       wire                       leaving_empty;
251                       wire                       going_aempty;
252                       wire                       leaving_aempty;
253                       reg                        ram_empty_i  = 1'b1;
254                       reg                        ram_aempty_i = 1'b1;
255                       wire                       empty_i;
256                       wire                       going_full;
257                       wire                       leaving_full;
258                       wire                       going_afull;
259                       wire                       leaving_afull;
260                       reg                        prog_full_i = FULL_RST_VAL;
261                       reg                        ram_full_i  = FULL_RST_VAL;
262                       reg                        ram_afull_i = FULL_RST_VAL;
263                       reg                        ram_full_n  = ~FULL_RST_VAL;
264                       wire                       ram_wr_en_i;
265                       wire                       ram_rd_en_i;
266                       reg                        wr_ack_i = 1'b0;
267                       wire                       rd_en_i;
268                       reg                        rd_en_fwft;
269                       wire                       ram_regce;
270                       wire                       ram_regce_pipe;
271                       wire [READ_DATA_WIDTH-1:0] dout_i;
272                       reg                        empty_fwft_i     = 1'b1;
273                       reg                        aempty_fwft_i    = 1'b1;
274                       reg                        empty_fwft_fb    = 1'b1;
275                       reg                        overflow_i       = 1'b0;
276                       reg                        underflow_i      = 1'b0;
277                       reg                        data_valid_fwft  = 1'b0;
278                       reg                        data_valid_std   = 1'b0;
279                       wire                       data_vld_std;
280                       wire                       wrp_gt_rdp_and_red;
281                       wire                       wrp_lt_rdp_and_red;
282                       reg                        ram_wr_en_pf_q = 1'b0;
283                       reg                        ram_rd_en_pf_q = 1'b0;
284                       wire                       ram_wr_en_pf;
285                       wire                       ram_rd_en_pf;
286                       wire                       wr_pntr_plus1_pf_carry;
287                       wire                       rd_pntr_wr_adj_pf_carry;
288                       wire                       write_allow;
289                       wire                       read_allow;
290                       wire                       read_only;
291                       wire                       write_only;
292                       reg                        write_only_q;
293                       reg                        read_only_q;
294                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg1;
295                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg2;
296                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe = 'b0;
297                       reg                        prog_empty_i = 1'b1;
298                       reg                        ram_empty_i_d1 = 1'b1;
299                       wire                       fe_of_empty;
300                       // function to validate the write depth value
301                       function logic dpth_pwr_2;
302                         input integer fifo_depth;
303                         integer log2_of_depth; // correcponding to the default value of 2k depth
304        1/1              log2_of_depth = clog2(fifo_depth);
305        1/1              if (fifo_depth == 2 ** log2_of_depth)
306        1/1                dpth_pwr_2 = 1;
307                         else
308        <font color = "red">0/1     ==>        dpth_pwr_2 = 0;</font>
309        1/1              return dpth_pwr_2;
310                       endfunction
311                       
312                       initial begin : config_drc
313                         reg drc_err_flag;
314        1/1              drc_err_flag = 0;
315        2/2              #1;
316                     
317        1/1              if (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEM_TYPE == 3) begin
318        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] UltraRAM cannot be used as asynchronous FIFO because it has only one clock support %m&quot;, &quot;XPM_FIFO&quot;, 1, 1);</font>
319        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
320                         end
                        MISSING_ELSE
321                     
322        1/1              if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 1) begin
323        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Related Clocks cannot be used in synchronous FIFO because it is applicable only for asynchronous FIFO %m&quot;, &quot;XPM_FIFO&quot;, 1, 2);</font>
324        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
325                         end
                        MISSING_ELSE
326                     
327        1/1              if(!(FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
328        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is not within the supported ranges. Miniumum supported depth is 16, and the maximum supported depth is 4*1024*1024 locations. %m&quot;, &quot;XPM_FIFO&quot;, 1, 3, FIFO_WRITE_DEPTH);</font>
329        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
330                         end
                        MISSING_ELSE
331                     
332        1/1              if(!dpth_pwr_2(FIFO_WRITE_DEPTH) &amp;&amp; (FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
333        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is non-power of 2, but this release of XPM_FIFO supports configurations having the fifo write depth set to power of 2. %m&quot;, &quot;XPM_FIFO&quot;, 1, 4, FIFO_WRITE_DEPTH);</font>
334        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
335                         end
                        MISSING_ELSE
336                     
337        1/1              if (CDC_DEST_SYNC_FF &lt; 2 || CDC_DEST_SYNC_FF &gt; 8) begin
338        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but this beta release of XPM_FIFO supports CDC_DEST_SYNC_FF values in between 2 and 8. %m&quot;, &quot;XPM_FIFO&quot;, 1, 5,CDC_DEST_SYNC_FF);</font>
339        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
340                         end
                        MISSING_ELSE
341        1/1              if (CDC_DEST_SYNC_FF != 2 &amp;&amp; RELATED_CLOCKS == 1) begin
342        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but CDC_DEST_SYNC_FF value can not be modified from default value when RELATED_CLOCKS parameter is set to 1. %m&quot;, &quot;XPM_FIFO&quot;, 1, 6,CDC_DEST_SYNC_FF);</font>
343        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
344                         end
                        MISSING_ELSE
345        1/1              if (FIFO_WRITE_DEPTH == 16 &amp;&amp; CDC_DEST_SYNC_FF &gt; 4) begin
346        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF = %0d and FIFO_WRITE_DEPTH = %0d. This is invalid combination. Either FIFO_WRITE_DEPTH should be increased or CDC_DEST_SYNC_FF should be reduced. %m&quot;, &quot;XPM_FIFO&quot;, 1, 7,CDC_DEST_SYNC_FF, FIFO_WRITE_DEPTH);</font>
347        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
348                         end
                        MISSING_ELSE
349        1/1              if (EN_ADV_FEATURE[7:5] != 3'h0) begin
350        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[7:5] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 8, EN_ADV_FEATURE[7:5]);</font>
351        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
352                         end
                        MISSING_ELSE
353        1/1              if (EN_ADV_FEATURE[15:14] != 3'h0) begin
354        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[15:13] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 9, EN_ADV_FEATURE[15:13]);</font>
355        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
356                         end
                        MISSING_ELSE
357                     //    if(WIDTH_RATIO &gt; 32) begin
358                     //      $error(&quot;[%s %0d-%0d] The ratio between WRITE_DATA_WIDTH (%0d) and READ_DATA_WIDTH (%0d) is greater than 32, but this release of XPM_FIFO supports configurations having the ratio between data widths must be less than 32. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH, READ_DATA_WIDTH);
359                     //      drc_err_flag = 1;
360                     //    end
361        1/1              if (WR_WIDTH_LOG+WR_DEPTH_LOG &gt; 30) begin
362        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The specified Width(%0d) and Depth(%0d) exceeds the maximum supported FIFO SIZE. Please reduce either FIFO Width or Depth. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH,FIFO_WRITE_DEPTH);</font>
363        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
364                         end
                        MISSING_ELSE
365        1/1              if(FIFO_READ_DEPTH &lt; 16) begin
366        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Width is %0d Read Width is %0d and Write Depth is %0d, this results in the Read Depth(%0d) less than 16. This is an invalid combination, Ensure the depth on both sides is minimum 16. %m&quot;, &quot;XPM_FIFO&quot;, 1, 11, WRITE_DATA_WIDTH, READ_DATA_WIDTH, FIFO_WRITE_DEPTH, FIFO_READ_DEPTH);</font>
367        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
368                         end
                        MISSING_ELSE
369                     
370                         // Range Checks
371        1/1              if (COMMON_CLOCK &gt; 1) begin
372        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] COMMON_CLOCK (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 1, COMMON_CLOCK);</font>
373        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
374                         end
                        MISSING_ELSE
375        1/1              if (FIFO_MEMORY_TYPE &gt; 3) begin
376        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_MEMORY_TYPE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 2, FIFO_MEMORY_TYPE);</font>
377        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
378                         end
                        MISSING_ELSE
379        1/1          	if (READ_MODE &gt; 2) begin
380        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 3, READ_MODE);</font>
381        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
382                         end
                        MISSING_ELSE
383                     
384        1/1              if (ECC_MODE &gt; 1) begin
385        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] ECC_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 4, ECC_MODE);</font>
386        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
387                         end
                        MISSING_ELSE
388        1/1          	if (!(WAKEUP_TIME == 0 || WAKEUP_TIME == 2)) begin
389        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WAKEUP_TIME (%0d) value is outside of legal range. WAKEUP_TIME should be either 0 or 2. %m&quot;, &quot;XPM_FIFO&quot;, 10, 5, WAKEUP_TIME);</font>
390        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
391                         end
                        MISSING_ELSE
392        1/1              if (!(VERSION == 0)) begin
393        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] VERSION (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 6, VERSION);</font>
394        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
395                         end
                        MISSING_ELSE
396                     
397        1/1              if (!(WRITE_DATA_WIDTH &gt; 0)) begin
398        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 2, WRITE_DATA_WIDTH);</font>
399        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
400                         end
                        MISSING_ELSE
401        1/1              if (!(READ_DATA_WIDTH &gt; 0)) begin
402        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 3, READ_DATA_WIDTH);</font>
403        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
404                         end
                        MISSING_ELSE
405                     
406        1/1              if (EN_PF == 1 &amp;&amp; ((PROG_FULL_THRESH &lt; PF_THRESH_MIN) || (PROG_FULL_THRESH &gt; PF_THRESH_MAX))) begin
407        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Full flag is enabled, but PROG_FULL_THRESH (%0d) value is outside of legal range. PROG_FULL_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 4, PROG_FULL_THRESH, PF_THRESH_MIN, PF_THRESH_MAX);</font>
408        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
409                         end
                        MISSING_ELSE
410                     
411        1/1              if (EN_PE == 1 &amp;&amp; (WIDTH_RATIO &lt;= 32) &amp;&amp; ((PROG_EMPTY_THRESH &lt; PE_THRESH_MIN) || (PROG_EMPTY_THRESH &gt; PE_THRESH_MAX))) begin
412        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Empty flag is enabled, but PROG_EMPTY_THRESH (%0d) value is outside of legal range. PROG_EMPTY_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 5, PROG_EMPTY_THRESH, PE_THRESH_MIN, PE_THRESH_MAX);</font>
413        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
414                         end
                        MISSING_ELSE
415                     
416        1/1              if (EN_WDC == 1 &amp;&amp; ((WR_DATA_COUNT_WIDTH &lt; 0) || (WR_DATA_COUNT_WIDTH &gt; WR_DC_WIDTH_EXT))) begin
417        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Data Count is enabled, but WR_DATA_COUNT_WIDTH (%0d) value is outside of legal range. WR_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 6, WR_DATA_COUNT_WIDTH, 0, WR_DC_WIDTH_EXT);</font>
418        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
419                         end
                        MISSING_ELSE
420                     
421                     
422        1/1              if (EN_RDC == 1 &amp;&amp; ((RD_DATA_COUNT_WIDTH &lt; 0) || (RD_DATA_COUNT_WIDTH &gt; RD_DC_WIDTH_EXT))) begin
423        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Read Data Count is enabled, but RD_DATA_COUNT_WIDTH (%0d) value is outside of legal range. RD_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 7, RD_DATA_COUNT_WIDTH, 0, RD_DC_WIDTH_EXT);</font>
424        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
425                         end
                        MISSING_ELSE
426                     
427                         //DRCs on Low Latency FWFT mode
428        1/1              if (READ_MODE == 2 &amp;&amp; FIFO_MEMORY_TYPE != 1) begin
429        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] XPM_FIFO does not support Read Mode (Low Latency FWFT) for FIFO_MEMORY_TYPE other than lutram/distributed. %m&quot;, &quot;XPM_FIFO&quot;, 16, 2);</font>
430        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
431                         end
                        MISSING_ELSE
432        1/1              if (READ_MODE == 2 &amp;&amp; EN_ADV_FEATURE != 16'h0) begin
433        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES = %0h. XPM_FIFO does not support Advanced Features in Low Latency FWFT mode. %m&quot;, &quot;XPM_FIFO&quot;, 16, 3, EN_ADV_FEATURE);</font>
434        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
435                         end
                        MISSING_ELSE
436                     
437                         // Infos
438                     
439                         // Warnings
440        1/1              if (drc_err_flag == 1)
441        <font color = "red">0/2     ==>        #1 $finish;</font>
                        MISSING_ELSE
442                       end : config_drc
443                     
444                       wire wr_en_i;
445                       wire wr_rst_i;
446                       wire rd_rst_i;
447                       reg  rd_rst_d2 = 1'b0;
448                       wire rst_d1;
449                       wire rst_d2;
450                       wire clr_full;
451                       wire empty_fwft_d1;
452                       wire leaving_empty_fwft_fe;
453                       wire leaving_empty_fwft_re;
454                       wire le_fwft_re;
455                       wire le_fwft_fe;
456                       wire [1:0] extra_words_fwft;
457                       wire le_fwft_re_wr;
458                       wire le_fwft_fe_wr;
459                     
460                       generate
461                     
462                       xpm_fifo_rst # (COMMON_CLOCK, CDC_DEST_SYNC_FF, SIM_ASSERT_CHK)
463                         xpm_fifo_rst_inst (rst, wr_clk, rd_clk, wr_rst_i, rd_rst_i, wrst_busy, rd_rst_busy);
464                       assign wr_rst_busy = wrst_busy | rst_d1;
465                     
466                       xpm_fifo_reg_bit #(0)
467                         rst_d1_inst (1'b0, wr_clk, wrst_busy, rst_d1);
468                       xpm_fifo_reg_bit #(0)
469                         rst_d2_inst (1'b0, wr_clk, rst_d1, rst_d2);
470                     
471                       assign clr_full = ~wrst_busy &amp; rst_d1 &amp; ~rst;
472                       assign rd_en_i = (RD_MODE == 0) ? rd_en : rd_en_fwft;
473                     
474                       if (REMOVE_WR_RD_PROT_LOGIC == 1) begin : ngen_wr_rd_prot
475                         assign ram_wr_en_i = wr_en;
476                         assign ram_rd_en_i = rd_en_i;
477                       end : ngen_wr_rd_prot
478                       else begin : gen_wr_rd_prot
479                         assign ram_wr_en_i = wr_en &amp; ~ram_full_i &amp; ~(wrst_busy|rst_d1);
480                         assign ram_rd_en_i = rd_en_i &amp; ~ram_empty_i;
481                       end : gen_wr_rd_prot
482                     
483                       // Write pointer generation
484                       xpm_counter_updn # (WR_PNTR_WIDTH+1, 0)
485                         wrp_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_ext);
486                       assign wr_pntr = wr_pntr_ext[WR_PNTR_WIDTH-1:0];
487                     
488                       xpm_counter_updn # (WR_PNTR_WIDTH, 1)
489                         wrpp1_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus1);
490                     
491                       xpm_counter_updn # (WR_PNTR_WIDTH, 2)
492                         wrpp2_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus2);
493                     
494                       if (EN_AF == 1) begin : gaf_wptr_p3
495                         xpm_counter_updn # (WR_PNTR_WIDTH, 3)
496                           wrpp3_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus3);
497                       end : gaf_wptr_p3
498                     
499                       // Read pointer generation
500                       xpm_counter_updn # (RD_PNTR_WIDTH+1, 0)
501                         rdp_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_ext);
502                       assign rd_pntr = rd_pntr_ext[RD_PNTR_WIDTH-1:0];
503                     
504                       xpm_counter_updn # (RD_PNTR_WIDTH, 1)
505                         rdpp1_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus1);
506                     
507                       if (EN_AE == 1) begin : gae_rptr_p2
508                         xpm_counter_updn # (RD_PNTR_WIDTH, 2)
509                           rdpp2_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus2);
510                       end : gae_rptr_p2
511                     
512                       assign full        = ram_full_i;
513                       assign full_n      = ram_full_n;
514                       assign almost_full = EN_AF == 1 ? ram_afull_i : 1'b0;
515                       assign wr_ack      = EN_WACK == 1 ? wr_ack_i : 1'b0;
516                       if (EN_WACK == 1) begin : gwack
517                         always @ (posedge wr_clk) begin
518                           if (rst | wr_rst_i | wrst_busy)
519                             wr_ack_i  &lt;= 1'b0;
520                           else
521                             wr_ack_i  &lt;= ram_wr_en_i;
522                         end
523                       end : gwack
524                     
525                       assign prog_full  = EN_PF == 1 ? (PROG_FULL_THRESH &gt; 0)  ? prog_full_i  : 1'b0 : 1'b0;
526                       assign prog_empty = EN_PE == 1 ? (PROG_EMPTY_THRESH &gt; 0) ? prog_empty_i : 1'b1 : 1'b0;
527                       
528                       assign empty_i = (RD_MODE == 0)? ram_empty_i : empty_fwft_i;
529                       assign empty   = empty_i;
530                       assign almost_empty = EN_AE == 1 ? (RD_MODE == 0) ? ram_aempty_i : aempty_fwft_i : 1'b0;
531                       
532                       assign data_valid   = EN_DVLD == 1 ? (RD_MODE == 0) ? data_valid_std : data_valid_fwft : 1'b0;
533                       if (EN_DVLD == 1) begin : gdvld
534                         assign data_vld_std = (RD_MODE == 0) ? (FIFO_READ_LATENCY == 1) ? ram_rd_en_i: ram_regce_pipe : ram_regce;
535                         always @ (posedge rd_clk) begin
536                           if (rd_rst_i)
537                             data_valid_std  &lt;= 1'b0;
538                           else
539                             data_valid_std  &lt;= data_vld_std;
540                         end
541                       end : gdvld
542                     
543                       // Simple dual port RAM instantiation for non-Built-in FIFO
544                       if (FIFO_MEMORY_TYPE &lt; 4) begin : gen_sdpram
545                     
546                       // Reset is not supported when ECC is enabled by the BRAM/URAM primitives
547                         wire rst_int;
548                         if(ECC_MODE !=0) begin : gnd_rst
549                           assign rst_int = 0;
550                         end : gnd_rst
551                         else begin : rst_gen
552                           assign rst_int = rd_rst_i;
553                         end : rst_gen
554                       // ----------------------------------------------------------------------
555                       // Base module instantiation with simple dual port RAM configuration
556                       // ----------------------------------------------------------------------
557                       localparam USE_DRAM_CONSTRAINT = (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEMORY_TYPE == 1) ? 1 : 0;
558                       localparam WR_MODE_B           = (FIFO_MEMORY_TYPE == 1 || FIFO_MEMORY_TYPE == 3) ? 1 : 2;
559                       xpm_memory_base # (
560                     
561                         // Common module parameters
562                         .MEMORY_TYPE              (1                    ),
563                         .MEMORY_SIZE              (FIFO_SIZE            ),
564                         .MEMORY_PRIMITIVE         (FIFO_MEMORY_TYPE     ),
565                         .CLOCKING_MODE            (COMMON_CLOCK ? 0 : 1 ),
566                         .ECC_MODE                 (ENABLE_ECC           ),
567                         .USE_MEM_INIT             (0                    ),
568                         .MEMORY_INIT_FILE         (&quot;none&quot;               ),
569                         .MEMORY_INIT_PARAM        (&quot;&quot;                   ),
570                         .WAKEUP_TIME              (WAKEUP_TIME          ),
571                         .MESSAGE_CONTROL          (0                    ),
572                         .VERSION                  (0                    ),
573                         .MEMORY_OPTIMIZATION      (&quot;true&quot;               ),
574                         .AUTO_SLEEP_TIME          (0                    ),
575                         .USE_EMBEDDED_CONSTRAINT  (USE_DRAM_CONSTRAINT  ),
576                         .CASCADE_HEIGHT           (CASCADE_HEIGHT       ),
577                     
578                         // Port A module parameters
579                         .WRITE_DATA_WIDTH_A       (WRITE_DATA_WIDTH     ),
580                         .READ_DATA_WIDTH_A        (WRITE_DATA_WIDTH     ),
581                         .BYTE_WRITE_WIDTH_A       (WRITE_DATA_WIDTH     ),
582                         .ADDR_WIDTH_A             (WR_PNTR_WIDTH        ),
583                         .READ_RESET_VALUE_A       (&quot;0&quot;                  ),
584                         .READ_LATENCY_A           (2                    ),
585                         .WRITE_MODE_A             (2                    ),
586                     
587                         // Port B module parameters
588                         .WRITE_DATA_WIDTH_B       (READ_DATA_WIDTH      ),
589                         .READ_DATA_WIDTH_B        (READ_DATA_WIDTH      ),
590                         .BYTE_WRITE_WIDTH_B       (READ_DATA_WIDTH      ),
591                         .ADDR_WIDTH_B             (RD_PNTR_WIDTH        ),
592                         .READ_RESET_VALUE_B       (DOUT_RESET_VALUE     ),
593                         .READ_LATENCY_B           (RD_LATENCY           ),
594                         .WRITE_MODE_B             (WR_MODE_B            )
595                       ) xpm_memory_base_inst (
596                     
597                         // Common module ports
598                         .sleep          (sleep                    ),
599                     
600                         // Port A module ports
601                         .clka           (wr_clk                   ),
602                         .rsta           (1'b0                     ),
603                         .ena            (ram_wr_en_i              ),
604                         .regcea         (1'b0                     ),
605                         .wea            (ram_wr_en_i              ),
606                         .addra          (wr_pntr                  ),
607                         .dina           (din                      ),
608                         .injectsbiterra (injectsbiterr            ),
609                         .injectdbiterra (injectdbiterr            ),
610                         .douta          (                         ),
611                         .sbiterra       (                         ),
612                         .dbiterra       (                         ),
613                     
614                         // Port B module ports
615                         .clkb           (rd_clk                   ),
616                         .rstb           (rst_int                  ),
617                         .enb            (ram_rd_en_i              ),
618                         .regceb         (READ_MODE == 0 ? ram_regce_pipe: ram_regce),
619                         .web            (1'b0                     ),
620                         .addrb          (rd_pntr                  ),
621                         .dinb           ({READ_DATA_WIDTH{1'b0}}  ),
622                         .injectsbiterrb (1'b0                     ),
623                         .injectdbiterrb (1'b0                     ),
624                         .doutb          (dout_i                   ),
625                         .sbiterrb       (sbiterr                  ),
626                         .dbiterrb       (dbiterr                  )
627                       );
628                       end : gen_sdpram
629                     
630                       if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
631                         assign wr_pntr_rd_adj    = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
632                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
633                         assign rd_pntr_wr_adj    = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
634                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
635                       end : wrp_eq_rdp
636                     
637                       if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
638                         assign wr_pntr_rd_adj = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
639                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
640                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr;
641                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
642                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr_dc;
643                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
644                       end : wrp_gt_rdp
645                     
646                       if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
647                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd;
648                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
649                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd_dc;
650                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
651                         assign rd_pntr_wr_adj = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
652                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
653                       end : wrp_lt_rdp
654                     
655                       if (COMMON_CLOCK == 0 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_cdc_pntr
656                         // Synchronize the write pointer in rd_clk domain
657                         xpm_cdc_gray #(
658                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
659                           .INIT_SYNC_FF          (1),
660                           .WIDTH                 (WR_PNTR_WIDTH))
661                           
662                           wr_pntr_cdc_inst (
663                             .src_clk             (wr_clk),
664                             .src_in_bin          (wr_pntr),
665                             .dest_clk            (rd_clk),
666                             .dest_out_bin        (wr_pntr_rd_cdc));
667                     
668                         // Register the output of XPM_CDC_GRAY on read side
669                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
670                           wpr_gray_reg (rd_rst_i, rd_clk, wr_pntr_rd_cdc, wr_pntr_rd);
671                     
672                         // Synchronize the extended write pointer in rd_clk domain
673                         xpm_cdc_gray #(
674                           .DEST_SYNC_FF          (READ_MODE == 0 ? CDC_DEST_SYNC_FF : CDC_DEST_SYNC_FF+2),
675                           .INIT_SYNC_FF          (1),
676                           .WIDTH                 (WR_PNTR_WIDTH+1))
677                           wr_pntr_cdc_dc_inst (
678                             .src_clk             (wr_clk),
679                             .src_in_bin          (wr_pntr_ext),
680                             .dest_clk            (rd_clk),
681                             .dest_out_bin        (wr_pntr_rd_cdc_dc));
682                     
683                         // Register the output of XPM_CDC_GRAY on read side
684                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
685                           wpr_gray_reg_dc (rd_rst_i, rd_clk, wr_pntr_rd_cdc_dc, wr_pntr_rd_dc);
686                     
687                         // Synchronize the read pointer in wr_clk domain
688                         xpm_cdc_gray #(
689                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
690                           .INIT_SYNC_FF          (1),
691                           .WIDTH                 (RD_PNTR_WIDTH))
692                           rd_pntr_cdc_inst (
693                             .src_clk             (rd_clk),
694                             .src_in_bin          (rd_pntr),
695                             .dest_clk            (wr_clk),
696                             .dest_out_bin        (rd_pntr_wr_cdc));
697                     
698                         // Register the output of XPM_CDC_GRAY on write side
699                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
700                           rpw_gray_reg (wrst_busy, wr_clk, rd_pntr_wr_cdc, rd_pntr_wr);
701                     
702                         // Synchronize the read pointer, subtracted by the extra word read for FWFT, in wr_clk domain
703                         xpm_cdc_gray #(
704                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
705                           .INIT_SYNC_FF          (1),
706                           .WIDTH                 (RD_PNTR_WIDTH+1))
707                           rd_pntr_cdc_dc_inst (
708                             .src_clk             (rd_clk),
709                             .src_in_bin          (rd_pntr_ext-extra_words_fwft),
710                             .dest_clk            (wr_clk),
711                             .dest_out_bin        (rd_pntr_wr_cdc_dc));
712                     
713                         // Register the output of XPM_CDC_GRAY on write side
714                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
715                           rpw_gray_reg_dc (wrst_busy, wr_clk, rd_pntr_wr_cdc_dc, rd_pntr_wr_dc);
716                     
717                       end : gen_cdc_pntr
718                     
719                       if (RELATED_CLOCKS == 1) begin : gen_pntr_pf_rc
720                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
721                           rpw_rc_reg (wrst_busy, wr_clk, rd_pntr, rd_pntr_wr);
722                     
723                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
724                           wpr_rc_reg (rd_rst_i, rd_clk, wr_pntr, wr_pntr_rd);
725                     
726                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
727                           wpr_rc_reg_dc (rd_rst_i, rd_clk, wr_pntr_ext, wr_pntr_rd_dc);
728                     
729                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
730                           rpw_rc_reg_dc (wrst_busy, wr_clk, (rd_pntr_ext-extra_words_fwft), rd_pntr_wr_dc);
731                       end : gen_pntr_pf_rc
732                     
733                       if (COMMON_CLOCK == 0 || RELATED_CLOCKS == 1) begin : gen_pf_ic_rc
734                       
735                         assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_rd_en_i);
736                         assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr));
737                         assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ram_rd_en_i);
738                         assign leaving_aempty  = ((wr_pntr_rd_adj == rd_pntr_plus1));
739                       
740                         assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i);
741                         assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr_plus1));
742                         assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus3) &amp; ram_wr_en_i);
743                         assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus2));
744                       
745                         // Empty flag generation
746                         always @ (posedge rd_clk) begin
747                           if (rd_rst_i) begin
748                              ram_empty_i  &lt;= 1'b1;
749                           end else begin
750                              ram_empty_i  &lt;= going_empty | leaving_empty;
751                           end
752                         end
753                     
754                         if (EN_AE == 1) begin : gae_ic_std
755                           always @ (posedge rd_clk) begin
756                             if (rd_rst_i) begin
757                               ram_aempty_i &lt;= 1'b1;
758                             end else if (~ram_empty_i) begin
759                               ram_aempty_i &lt;= going_aempty | leaving_aempty;
760                             end
761                           end
762                         end : gae_ic_std
763                       
764                         // Full flag generation
765                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
766                           always @ (posedge wr_clk) begin
767                     	if (wrst_busy) begin
768                               ram_full_i      &lt;= FULL_RST_VAL;
769                               ram_full_n      &lt;= ~FULL_RST_VAL;
770                             end else begin
771                     	  if (clr_full) begin
772                                 ram_full_i    &lt;= 1'b0;
773                                 ram_full_n    &lt;= 1'b1;
774                     	  end else begin
775                                 ram_full_i    &lt;= going_full | leaving_full;
776                                 ram_full_n    &lt;= ~(going_full | leaving_full);
777                               end
778                             end
779                           end
780                         end : gen_full_rst_val
781                         else begin : ngen_full_rst_val
782                           always @ (posedge wr_clk) begin
783                     	if (wrst_busy) begin
784                               ram_full_i   &lt;= 1'b0;
785                               ram_full_n   &lt;= 1'b1;
786                     	end else begin
787                               ram_full_i   &lt;= going_full | leaving_full;
788                               ram_full_n   &lt;= ~(going_full | leaving_full);
789                     	end
790                           end
791                         end : ngen_full_rst_val
792                     
793                         if (EN_AF == 1) begin : gaf_ic
794                           always @ (posedge wr_clk) begin
795                     	if (wrst_busy) begin
796                               ram_afull_i  &lt;= FULL_RST_VAL;
797                             end else if (~rst) begin
798                     	  if (clr_full) begin
799                                 ram_afull_i  &lt;= 1'b0;
800                     	  end else if (~ram_full_i) begin
801                                 ram_afull_i  &lt;= going_afull | leaving_afull;
802                               end
803                             end
804                           end
805                         end : gaf_ic
806                     
807                       // synthesis translate_off
808                         `ifndef DISABLE_XPM_ASSERTIONS
809                         if (SIM_ASSERT_CHK == 1) begin: assert_wr_rd_en
810                           always @ (posedge rd_clk) begin
811                             assert (!$isunknown(rd_en)) else $warning (&quot;Input port 'rd_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'rd_en' has a valid value ('0' or '1')&quot;,$time);
812                           end
813                     
814                           always @ (posedge wr_clk) begin
815                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
816                           end
817                     
818                           always @ (posedge wr_clk) begin
819                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
820                           end
821                     
822                         end : assert_wr_rd_en
823                         `endif
824                       // synthesis translate_on
825                     
826                         // Programmable Full flag generation
827                         if (EN_PF == 1) begin : gpf_ic
828                           assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
829                           assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
830                       
831                           // PF carry generation
832                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i;
833                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i;
834                       
835                           // PF diff pointer generation
836                           always @ (posedge wr_clk) begin
837                             if (wrst_busy)
838                                diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
839                             else
840                                diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
841                           end
842                           assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
843                       
844                           always @ (posedge wr_clk) begin
845                             if (wrst_busy)
846                                prog_full_i  &lt;= FULL_RST_VAL;
847                             else if (clr_full)
848                                prog_full_i  &lt;= 1'b0;
849                             else if (~ram_full_i) begin
850                               if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
851                                 prog_full_i  &lt;= 1'b1;
852                               else
853                                 prog_full_i  &lt;= 1'b0;
854                             end else
855                               prog_full_i  &lt;= prog_full_i;
856                           end
857                         end : gpf_ic
858                     
859                         /*********************************************************
860                          * Programmable EMPTY flags
861                          *********************************************************/
862                         //Determine the Assert and Negate thresholds for Programmable Empty
863                         if (EN_PE == 1) begin : gpe_ic
864                      
865                           always @(posedge rd_clk) begin
866                             if (rd_rst_i) begin
867                               diff_pntr_pe      &lt;= 0;
868                               prog_empty_i       &lt;= 1'b1;
869                             end else begin
870                               if (ram_rd_en_i)
871                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr) - 1'h1;
872                               else
873                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr);
874                          
875                               if (~empty_i) begin
876                                 if (diff_pntr_pe &lt;= PE_THRESH_ADJ)
877                                   prog_empty_i &lt;= 1'b1;
878                                 else
879                                   prog_empty_i &lt;= 1'b0;
880                               end else
881                                 prog_empty_i   &lt;= prog_empty_i;
882                             end
883                           end
884                         end : gpe_ic
885                       end : gen_pf_ic_rc
886                     
887                       if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_pntr_flags_cc
888                         assign wr_pntr_rd = wr_pntr;
889                         assign rd_pntr_wr = rd_pntr;
890                         assign wr_pntr_rd_dc = wr_pntr_ext;
891                         assign rd_pntr_wr_dc = rd_pntr_ext-extra_words_fwft;
892                         assign write_allow  = ram_wr_en_i &amp; ~ram_full_i;
893                         assign read_allow   = ram_rd_en_i &amp; ~empty_i;
894                     
895                         if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
896                           assign ram_wr_en_pf  = ram_wr_en_i;
897                           assign ram_rd_en_pf  = ram_rd_en_i;
898                       
899                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
900                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
901                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
902                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
903                       
904                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
905                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
906                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
907                           assign leaving_afull  = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_rd_en_i &amp; ~ram_wr_en_i);
908                     
909                           assign write_only    = write_allow &amp; ~read_allow;
910                           assign read_only     = read_allow &amp; ~write_allow;
911                     
912                         end : wrp_eq_rdp
913                       
914                         if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
915                           assign wrp_gt_rdp_and_red = &amp;wr_pntr_rd[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0];
916                       
917                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
918                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red));
919                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
920                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ~ram_rd_en_i);
921                       
922                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
923                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
924                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
925                           assign leaving_afull  = (((rd_pntr_wr_adj == wr_pntr) | (rd_pntr_wr_adj == wr_pntr_plus1) | (rd_pntr_wr_adj == wr_pntr_plus2)) &amp; ram_rd_en_i);
926                       
927                           assign ram_wr_en_pf  = ram_wr_en_i &amp; wrp_gt_rdp_and_red;
928                           assign ram_rd_en_pf  = ram_rd_en_i;
929                     
930                           assign read_only     = read_allow &amp; (~(write_allow  &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0])));
931                           assign write_only    = write_allow &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0]) &amp; ~read_allow;
932                     
933                     
934                         end : wrp_gt_rdp
935                       
936                         if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
937                           assign wrp_lt_rdp_and_red = &amp;rd_pntr_wr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0];
938                       
939                           assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
940                           assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
941                           assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
942                           assign leaving_aempty  = (((wr_pntr_rd_adj == rd_pntr) | (wr_pntr_rd_adj == rd_pntr_plus1) | (wr_pntr_rd_adj == rd_pntr_plus2)) &amp; ram_wr_en_i);
943                       
944                           assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
945                           assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr) &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
946                           assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
947                           assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~ram_wr_en_i &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
948                       
949                           assign ram_wr_en_pf = ram_wr_en_i;
950                           assign ram_rd_en_pf = ram_rd_en_i &amp; wrp_lt_rdp_and_red;
951                     
952                           assign read_only   = read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0]) &amp; ~write_allow;
953                           assign write_only    = write_allow    &amp; (~(read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0])));
954                         end : wrp_lt_rdp
955                       
956                         // Empty flag generation
957                         always @ (posedge rd_clk) begin
958        1/1                if (rd_rst_i) begin
959        1/1                   ram_empty_i  &lt;= 1'b1;
960                           end else begin
961        1/1                   ram_empty_i  &lt;= going_empty | (~leaving_empty &amp; ram_empty_i);
962                           end
963                         end
964                     
965                         if (EN_AE == 1) begin : gae_cc_std
966                           always @ (posedge rd_clk) begin
967                             if (rd_rst_i) begin
968                               ram_aempty_i &lt;= 1'b1;
969                             end else begin
970                               ram_aempty_i &lt;= going_aempty | (~leaving_aempty &amp; ram_aempty_i);
971                             end
972                           end
973                         end : gae_cc_std
974                     
975                         // Full flag generation
976                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
977                           always @ (posedge wr_clk) begin
978                     	if (wrst_busy) begin
979                               ram_full_i   &lt;= FULL_RST_VAL;
980                               ram_full_n   &lt;= ~FULL_RST_VAL;
981                             end else begin
982                     	  if (clr_full) begin
983                                 ram_full_i   &lt;= 1'b0;
984                                 ram_full_n   &lt;= 1'b1;
985                     	  end else begin
986                                 ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
987                                 ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
988                               end
989                             end
990                           end
991                         end : gen_full_rst_val
992                         else begin : ngen_full_rst_val
993                           always @ (posedge wr_clk) begin
994        1/1          	if (wrst_busy) begin
995        1/1                    ram_full_i   &lt;= 1'b0;
996        1/1                    ram_full_n   &lt;= 1'b1;
997                     	end else begin
998        1/1                    ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
999        1/1                    ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
1000                    	end
1001                          end
1002                        end : ngen_full_rst_val
1003                    
1004                        if (EN_AF == 1) begin : gaf_cc
1005                          always @ (posedge wr_clk) begin
1006                    	if (wrst_busy) begin
1007                              ram_afull_i  &lt;= FULL_RST_VAL;
1008                            end else if (~rst) begin
1009                    	  if (clr_full) begin
1010                                ram_afull_i  &lt;= 1'b0;
1011                    	  end else begin
1012                                ram_afull_i  &lt;= going_afull | (~leaving_afull &amp; ram_afull_i);
1013                              end
1014                            end
1015                          end
1016                        end : gaf_cc
1017                        // Programmable Full flag generation
1018                        if ((WR_PNTR_WIDTH == RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_eq_rdp_pf_cc
1019                          if (EN_PF == 1) begin : gpf_cc_sym
1020                    
1021                            assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
1022                            assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
1023                      
1024                            // Delayed write/read enable for PF generation
1025                            always @ (posedge wr_clk) begin
1026       1/1                    if (wrst_busy) begin
1027       1/1                       ram_wr_en_pf_q   &lt;= 1'b0;
1028       1/1                       ram_rd_en_pf_q   &lt;= 1'b0;
1029                              end else begin
1030       1/1                       ram_wr_en_pf_q   &lt;= ram_wr_en_pf;
1031       1/1                       ram_rd_en_pf_q   &lt;= ram_rd_en_pf;
1032                              end
1033                            end
1034                      
1035                            // PF carry generation
1036                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i &amp; ~ram_rd_en_pf;
1037                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i &amp; ~ram_rd_en_pf;
1038                      
1039                            // PF diff pointer generation
1040                            always @ (posedge wr_clk) begin
1041       1/1                    if (wrst_busy)
1042       1/1                       diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1043                              else
1044       1/1                       diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
1045                            end
1046                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1047                      
1048                            always @ (posedge wr_clk) begin
1049       1/1                    if (wrst_busy)
1050       1/1                       prog_full_i  &lt;= FULL_RST_VAL;
1051       1/1                    else if (clr_full)
1052       1/1                       prog_full_i  &lt;= 1'b0;
1053       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ram_wr_en_pf_q &amp; ~ram_rd_en_pf_q)
1054       1/1                       prog_full_i  &lt;= 1'b1;
1055       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ~ram_wr_en_pf_q &amp; ram_rd_en_pf_q)
1056       <font color = "red">0/1     ==>               prog_full_i  &lt;= 1'b0;</font>
1057                              else
1058       1/1                       prog_full_i  &lt;= prog_full_i;
1059                            end
1060                          end : gpf_cc_sym
1061                    
1062                          if (EN_PE == 1) begin : gpe_cc_sym
1063                            always @(posedge rd_clk) begin
1064       1/1                    if (rd_rst_i) begin
1065       1/1                      read_only_q    &lt;= 1'b0;
1066       1/1                      write_only_q   &lt;= 1'b0;
1067       1/1                      diff_pntr_pe   &lt;= 0;
1068                              end 
1069                              else begin
1070       1/1                      read_only_q  &lt;= read_only;
1071       1/1                      write_only_q &lt;= write_only;
1072                                // Add 1 to the difference pointer value when write or both write &amp; read or no write &amp; read happen.
1073       1/1                      if (read_only)
1074       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr - 1;
1075                                else
1076       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr;
1077                              end
1078                            end
1079                      
1080                            always @(posedge rd_clk) begin
1081       1/1                    if (rd_rst_i)
1082       1/1                      prog_empty_i  &lt;= 1'b1;
1083                              else begin
1084       1/1                      if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; read_only_q)
1085       <font color = "red">0/1     ==>                prog_empty_i &lt;= 1'b1;</font>
1086       1/1                      else if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; write_only_q)
1087       1/1                        prog_empty_i &lt;= 1'b0;
1088                                else
1089       1/1                        prog_empty_i &lt;= prog_empty_i;
1090                              end
1091                            end
1092                          end : gpe_cc_sym
1093                        end : wrp_eq_rdp_pf_cc
1094                    
1095                        if ((WR_PNTR_WIDTH != RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_neq_rdp_pf_cc
1096                          if (EN_PF == 1) begin : gpf_cc_asym
1097                            // PF diff pointer generation
1098                            always @ (posedge wr_clk) begin
1099                              if (wrst_busy)
1100                                 diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1101                              else if (~ram_full_i)
1102                                 diff_pntr_pf_q[WR_PNTR_WIDTH:1]  &lt;= wr_pntr + ~rd_pntr_wr_adj + 1;
1103                            end
1104                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1105                            always @ (posedge wr_clk) begin
1106                              if (wrst_busy)
1107                                 prog_full_i  &lt;= FULL_RST_VAL;
1108                              else if (clr_full)
1109                                 prog_full_i  &lt;= 1'b0;
1110                              else if (~ram_full_i) begin
1111                                if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
1112                                   prog_full_i  &lt;= 1'b1;
1113                                else if (diff_pntr_pf &lt; PF_THRESH_ADJ)
1114                                   prog_full_i  &lt;= 1'b0;
1115                                else
1116                                   prog_full_i  &lt;= prog_full_i;
1117                              end
1118                            end
1119                          end : gpf_cc_asym
1120                          if (EN_PE == 1) begin : gpe_cc_asym
1121                            // Programmanble Empty flag Generation
1122                            // Diff pointer Generation
1123                            localparam [RD_PNTR_WIDTH-1 : 0] DIFF_MAX_RD = {RD_PNTR_WIDTH{1'b1}};
1124                            wire [RD_PNTR_WIDTH-1:0] diff_pntr_pe_max;
1125                            wire                     carry;
1126                            reg  [RD_PNTR_WIDTH : 0] diff_pntr_pe_asym = 'b0;
1127                            wire [RD_PNTR_WIDTH : 0] wr_pntr_rd_adj_asym;
1128                            wire [RD_PNTR_WIDTH : 0] rd_pntr_asym;
1129                            reg                      full_reg;
1130                            reg                      rst_full_ff_reg1;
1131                            reg                      rst_full_ff_reg2;
1132                      
1133                            assign diff_pntr_pe_max = DIFF_MAX_RD;
1134                            assign wr_pntr_rd_adj_asym[RD_PNTR_WIDTH:0] = {wr_pntr_rd_adj,1'b1};
1135                            assign rd_pntr_asym[RD_PNTR_WIDTH:0] = {~rd_pntr,1'b1};
1136                      
1137                            always @(posedge rd_clk ) begin
1138                              if (rd_rst_i) begin
1139                                diff_pntr_pe_asym    &lt;= 0;
1140                                full_reg             &lt;= 0;
1141                                rst_full_ff_reg1     &lt;= 1;
1142                                rst_full_ff_reg2     &lt;= 1;
1143                                diff_pntr_pe_reg1    &lt;= 0;
1144                              end else begin
1145                                diff_pntr_pe_asym &lt;= wr_pntr_rd_adj_asym + rd_pntr_asym;
1146                                full_reg          &lt;= ram_full_i;
1147                                rst_full_ff_reg1  &lt;= FULL_RST_VAL;
1148                                rst_full_ff_reg2  &lt;= rst_full_ff_reg1;
1149                              end
1150                            end
1151                            wire [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_i;
1152                            assign carry = (~(|(diff_pntr_pe_asym [RD_PNTR_WIDTH : 1])));
1153                            assign diff_pntr_pe_i = (full_reg &amp;&amp; ~rst_d2 &amp;&amp; carry ) ? diff_pntr_pe_max : diff_pntr_pe_asym[RD_PNTR_WIDTH:1];
1154                        
1155                            always @(posedge rd_clk) begin
1156                              if (rd_rst_i)
1157                                prog_empty_i  &lt;= 1'b1;
1158                              else begin
1159                                if (diff_pntr_pe_i &lt;= PE_THRESH_ADJ)
1160                                  prog_empty_i &lt;= 1'b1;
1161                                else if (diff_pntr_pe_i &gt; PE_THRESH_ADJ)
1162                                  prog_empty_i &lt;= 1'b0;
1163                                else
1164                                  prog_empty_i &lt;= prog_empty_i;
1165                              end
1166                            end
1167                          end : gpe_cc_asym
1168                        end : wrp_neq_rdp_pf_cc
1169                    
1170                      end : gen_pntr_flags_cc
1171                    
1172                      if (READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1) begin : gen_regce_std
1173                        xpm_reg_pipe_bit #(FIFO_READ_LATENCY-1, 0)
1174                          regce_pipe_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_regce_pipe);
1175                      end : gen_regce_std
1176                      if (!(READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1)) begin : gnen_regce_std
1177                        assign ram_regce_pipe = 1'b0;
1178                      end : gnen_regce_std
1179                    
1180                      if (!((READ_MODE == 1 || READ_MODE == 2)&amp;&amp; FIFO_MEMORY_TYPE != 4)) begin : gn_fwft
1181                       assign invalid_state = 1'b0;
1182                      end : gn_fwft
1183                      //if (READ_MODE == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1184                      if (READ_MODE != 0 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1185                      // First word fall through logic
1186                    
1187                       //localparam invalid             = 0;
1188                       //localparam stage1_valid        = 2;
1189                       //localparam stage2_valid        = 1;
1190                       //localparam both_stages_valid   = 3;
1191                    
1192                       //reg  [1:0] curr_fwft_state = invalid;
1193                       //reg  [1:0] next_fwft_state;// = invalid;
1194                       wire next_fwft_state_d1;
1195                       assign invalid_state = ~|curr_fwft_state;
1196                       assign valid_fwft = next_fwft_state_d1;
1197                       assign ram_valid_fwft = curr_fwft_state[1];
1198                    
1199                        xpm_fifo_reg_bit #(0)
1200                          next_state_d1_inst (1'b0, rd_clk, next_fwft_state[0], next_fwft_state_d1);
1201                       //FSM : To generate the enable, clock enable for xpm_memory and to generate
1202                       //empty signal
1203                       //FSM : Next state Assignment
1204                         if (READ_MODE == 1) begin : gen_fwft_ns
1205                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1206                           case (curr_fwft_state)
1207                             invalid: begin
1208                               if (~ram_empty_i)
1209                                  next_fwft_state     = stage1_valid;
1210                               else
1211                                  next_fwft_state     = invalid;
1212                               end
1213                             stage1_valid: begin
1214                               if (ram_empty_i)
1215                                  next_fwft_state     = stage2_valid;
1216                               else
1217                                  next_fwft_state     = both_stages_valid;
1218                               end
1219                             stage2_valid: begin
1220                               if (ram_empty_i &amp;&amp; rd_en)
1221                                  next_fwft_state     = invalid;
1222                               else if (~ram_empty_i &amp;&amp; rd_en)
1223                                  next_fwft_state     = stage1_valid;
1224                               else if (~ram_empty_i &amp;&amp; ~rd_en)
1225                                  next_fwft_state     = both_stages_valid;
1226                               else
1227                                  next_fwft_state     = stage2_valid;
1228                               end
1229                             both_stages_valid: begin
1230                               if (ram_empty_i &amp;&amp; rd_en)
1231                                  next_fwft_state     = stage2_valid;
1232                               else if (~ram_empty_i &amp;&amp; rd_en)
1233                                  next_fwft_state     = both_stages_valid;
1234                               else
1235                                  next_fwft_state     = both_stages_valid;
1236                               end
1237                             default: next_fwft_state    = invalid;
1238                           endcase
1239                         end
1240                         end : gen_fwft_ns
1241                         if (READ_MODE == 2) begin : gen_fwft_ns_ll
1242                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1243                           case (curr_fwft_state)
1244                             invalid: begin
1245                               if (~ram_empty_i)
1246                                  next_fwft_state     = stage1_valid;
1247                               else
1248                                  next_fwft_state     = invalid;
1249                               end
1250                             stage1_valid: begin
1251                               if (ram_empty_i &amp;&amp; rd_en)
1252                                  next_fwft_state     = invalid;
1253                               else
1254                                  next_fwft_state     = stage1_valid;
1255                               end
1256                             default: next_fwft_state    = invalid;
1257                           endcase
1258                         end
1259                         end : gen_fwft_ns_ll
1260                         // FSM : current state assignment
1261                         always @ (posedge rd_clk) begin
1262                           if (rd_rst_i)
1263                              curr_fwft_state  &lt;= invalid;
1264                           else
1265                              curr_fwft_state  &lt;= next_fwft_state;
1266                         end
1267                     
1268                         reg ram_regout_en;
1269                    
1270                         // FSM(output assignments) : clock enable generation for xpm_memory
1271                         if (READ_MODE == 1) begin : gen_fwft_ro
1272                         always @(curr_fwft_state or rd_en) begin
1273                           case (curr_fwft_state)
1274                             invalid:           ram_regout_en = 1'b0;
1275                             stage1_valid:      ram_regout_en = 1'b1;
1276                             stage2_valid:      ram_regout_en = 1'b0;
1277                             both_stages_valid: ram_regout_en = rd_en;
1278                             default:           ram_regout_en = 1'b0;
1279                           endcase
1280                         end
1281                         end : gen_fwft_ro
1282                         if (READ_MODE == 2) begin : gen_fwft_ro_ll
1283                         always @(curr_fwft_state or rd_en or ram_empty_i or fe_of_empty) begin
1284                           case (curr_fwft_state)
1285                             invalid:           ram_regout_en = fe_of_empty;
1286                             stage1_valid:      ram_regout_en = rd_en &amp; !ram_empty_i;
1287                             default:           ram_regout_en = 1'b0;
1288                           endcase
1289                         end
1290                         end : gen_fwft_ro_ll
1291                    
1292                         // FSM(output assignments) : rd_en (enable) signal generation for xpm_memory
1293                         if (READ_MODE == 1) begin : gen_fwft_re
1294                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1295                           case (curr_fwft_state)
1296                             invalid :
1297                               if (~ram_empty_i)
1298                                 rd_en_fwft = 1'b1;
1299                               else
1300                                 rd_en_fwft = 1'b0;
1301                             stage1_valid :
1302                               if (~ram_empty_i)
1303                                 rd_en_fwft = 1'b1;
1304                               else
1305                                 rd_en_fwft = 1'b0;
1306                             stage2_valid :
1307                               if (~ram_empty_i)
1308                                 rd_en_fwft = 1'b1;
1309                               else
1310                                 rd_en_fwft = 1'b0;
1311                             both_stages_valid :
1312                               if (~ram_empty_i &amp;&amp; rd_en)
1313                                 rd_en_fwft = 1'b1;
1314                               else
1315                                 rd_en_fwft = 1'b0;
1316                             default :
1317                               rd_en_fwft = 1'b0;
1318                           endcase
1319                         end
1320                         end : gen_fwft_re
1321                         if (READ_MODE == 2) begin : gen_fwft_re_ll
1322                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1323                           case (curr_fwft_state)
1324                             invalid :
1325                               if (~ram_empty_i)
1326                                 rd_en_fwft = 1'b1;
1327                               else
1328                                 rd_en_fwft = 1'b0;
1329                             stage1_valid :
1330                               if (~ram_empty_i &amp;&amp; rd_en)
1331                                 rd_en_fwft = 1'b1;
1332                               else
1333                                 rd_en_fwft = 1'b0;
1334                             default :
1335                               rd_en_fwft = 1'b0;
1336                           endcase
1337                         end
1338                         end : gen_fwft_re_ll
1339                         // assingment to control regce xpm_memory
1340                         assign ram_regce = ram_regout_en;
1341                    
1342                         reg going_empty_fwft;
1343                         reg leaving_empty_fwft;
1344                    
1345                         if (READ_MODE == 1) begin : gen_fwft_ge
1346                         always @(curr_fwft_state or rd_en) begin
1347                           case (curr_fwft_state)
1348                             stage2_valid : going_empty_fwft = rd_en;
1349                             default      : going_empty_fwft = 1'b0;
1350                           endcase
1351                         end
1352                    
1353                         always @(curr_fwft_state or rd_en) begin
1354                           case (curr_fwft_state)
1355                             stage1_valid : leaving_empty_fwft = 1'b1;
1356                             default      : leaving_empty_fwft = 1'b0;
1357                           endcase
1358                         end
1359                         end : gen_fwft_ge
1360                         if (READ_MODE == 2) begin : gen_fwft_ge_ll
1361                         always @(curr_fwft_state or rd_en or ram_empty_i) begin
1362                           case (curr_fwft_state)
1363                             stage1_valid : going_empty_fwft = rd_en &amp; ram_empty_i;
1364                             default      : going_empty_fwft = 1'b0;
1365                           endcase
1366                         end
1367                    
1368                         always @ (posedge rd_clk) begin
1369                           if (rd_rst_i) begin
1370                              ram_empty_i_d1  &lt;= 1'b1;
1371                           end else begin
1372                              ram_empty_i_d1  &lt;= ram_empty_i;
1373                           end
1374                         end
1375                         assign fe_of_empty = ram_empty_i_d1 &amp; !ram_empty_i;
1376                    
1377                         always @(curr_fwft_state or fe_of_empty) begin
1378                           case (curr_fwft_state)
1379                             invalid      : leaving_empty_fwft = fe_of_empty;
1380                             stage1_valid : leaving_empty_fwft = 1'b1;
1381                             default      : leaving_empty_fwft = 1'b0;
1382                           endcase
1383                         end
1384                         end : gen_fwft_ge_ll
1385                    
1386                         // fwft empty signal generation 
1387                         always @ (posedge rd_clk) begin
1388                           if (rd_rst_i) begin
1389                             empty_fwft_i     &lt;= 1'b1;
1390                             empty_fwft_fb    &lt;= 1'b1;
1391                           end else begin
1392                             empty_fwft_i     &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1393                             empty_fwft_fb    &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1394                           end
1395                         end
1396                    
1397                         if (EN_AE == 1) begin : gae_fwft
1398                           reg going_aempty_fwft;
1399                           reg leaving_aempty_fwft;
1400                    
1401                           if (READ_MODE == 1) begin : gen_fwft_ae
1402                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1403                               case (curr_fwft_state)
1404                                 both_stages_valid : going_aempty_fwft = rd_en &amp; ram_empty_i;
1405                                 default      : going_aempty_fwft = 1'b0;
1406                               endcase
1407                             end
1408                           end : gen_fwft_ae
1409                           if (READ_MODE == 2) begin : gen_fwft_ae_ll
1410                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1411                               case (curr_fwft_state)
1412                                 stage1_valid : going_aempty_fwft = !rd_en &amp; ram_empty_i;
1413                                 default      : going_aempty_fwft = 1'b0;
1414                               endcase
1415                             end
1416                           end : gen_fwft_ae_ll
1417                    
1418                           always @(curr_fwft_state or rd_en or ram_empty_i) begin
1419                             case (curr_fwft_state)
1420                               stage1_valid : leaving_aempty_fwft = ~ram_empty_i;
1421                               stage2_valid : leaving_aempty_fwft = ~(rd_en | ram_empty_i);
1422                               default      : leaving_aempty_fwft = 1'b0;
1423                             endcase
1424                           end
1425                    
1426                           always @ (posedge rd_clk) begin
1427                             if (rd_rst_i) begin
1428                               aempty_fwft_i    &lt;= 1'b1;
1429                             end else begin
1430                               aempty_fwft_i    &lt;= going_aempty_fwft | (~ leaving_aempty_fwft &amp; aempty_fwft_i);
1431                             end
1432                           end
1433                         end : gae_fwft
1434                    
1435                         if (EN_DVLD == 1) begin : gdvld_fwft
1436                           always @ (posedge rd_clk) begin
1437                             if (rd_rst_i) begin
1438                               data_valid_fwft  &lt;= 1'b0;
1439                             end else begin
1440                               data_valid_fwft  &lt;= ~(going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb));
1441                             end
1442                           end
1443                         end : gdvld_fwft
1444                    
1445                        xpm_fifo_reg_bit #(0)
1446                          empty_fwft_d1_inst (1'b0, rd_clk, leaving_empty_fwft, empty_fwft_d1);
1447                    
1448                        wire ge_fwft_d1;
1449                        xpm_fifo_reg_bit #(0)
1450                          ge_fwft_d1_inst (1'b0, rd_clk, going_empty_fwft, ge_fwft_d1);
1451                    
1452                        wire count_up  ;
1453                        wire count_down;
1454                        wire count_en  ;
1455                        wire count_rst ;
1456                        assign count_up   = (next_fwft_state == 2'b10 &amp;&amp; ~|curr_fwft_state) | (curr_fwft_state == 2'b10 &amp;&amp; &amp;next_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; &amp;next_fwft_state);
1457                        assign count_down = (next_fwft_state == 2'b01 &amp;&amp; &amp;curr_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; ~|next_fwft_state);
1458                        assign count_en   = count_up | count_down;
1459                        assign count_rst  = (rd_rst_i | (~|curr_fwft_state &amp; ~|next_fwft_state));
1460                    
1461                        xpm_counter_updn # (2, 0)
1462                          rdpp1_inst (count_rst, rd_clk, count_en, count_up, count_down, extra_words_fwft);
1463                    
1464                     
1465                      end : gen_fwft
1466                    
1467                      if (READ_MODE == 0) begin : ngen_fwft
1468                        assign le_fwft_re       = 1'b0;
1469                        assign le_fwft_fe       = 1'b0;
1470                        assign extra_words_fwft = 2'h0;
1471                      end : ngen_fwft
1472                    
1473                      // output data bus assignment
1474                      if (FG_EQ_ASYM_DOUT == 0) begin : nfg_eq_asym_dout
1475                        assign dout  = dout_i;
1476                      end : nfg_eq_asym_dout
1477                    
1478                      // Overflow and Underflow flag generation
1479                      if (EN_UF == 1) begin : guf
1480                        always @ (posedge rd_clk) begin
1481       1/1                underflow_i &lt;=  (rd_rst_i | empty_i) &amp; rd_en;
1482                        end
1483                        assign underflow   = underflow_i;
1484                      end : guf
1485                      if (EN_UF == 0) begin : gnuf
1486                        assign underflow   = 1'b0;
1487                      end : gnuf
1488                    
1489                      if (EN_OF == 1) begin : gof
1490                        always @ (posedge wr_clk) begin
1491       1/1               overflow_i  &lt;=  (wrst_busy | rst_d1 | ram_full_i) &amp; wr_en;
1492                        end
1493                        assign overflow    = overflow_i;
1494                      end : gof
1495                      if (EN_OF == 0) begin : gnof
1496                        assign overflow    = 1'b0;
1497                      end : gnof
1498                    
1499                      // -------------------------------------------------------------------------------------------------------------------
1500                      // Write Data Count for Independent Clocks FIFO
1501                      // -------------------------------------------------------------------------------------------------------------------
1502                      if (EN_WDC == 1) begin : gwdc
1503                        reg  [WR_DC_WIDTH_EXT-1:0] wr_data_count_i;
1504                        wire [WR_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr;
1505                        assign diff_wr_rd_pntr = wr_pntr_ext-rd_pntr_wr_adj_dc;
1506                        always @ (posedge wr_clk) begin
1507       1/1                if (wrst_busy)
1508       1/1                   wr_data_count_i   &lt;= {WR_DC_WIDTH_EXT{1'b0}};
1509                          else
1510       1/1                   wr_data_count_i  &lt;= diff_wr_rd_pntr;
1511                        end
1512                        assign wr_data_count = wr_data_count_i[WR_DC_WIDTH_EXT-1:WR_DC_WIDTH_EXT-WR_DATA_COUNT_WIDTH];
1513                      end : gwdc
1514                      if (EN_WDC == 0) begin : gnwdc
1515                        assign wr_data_count = {WR_DC_WIDTH_EXT{1'b0}};
1516                      end : gnwdc
1517                    
1518                      // -------------------------------------------------------------------------------------------------------------------
1519                      // Read Data Count for Independent Clocks FIFO
1520                      // -------------------------------------------------------------------------------------------------------------------
1521                      if (EN_RDC == 1) begin : grdc
1522                        reg  [RD_DC_WIDTH_EXT-1:0] rd_data_count_i;
1523                        wire [RD_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr_rdc;
1524                        assign diff_wr_rd_pntr_rdc = wr_pntr_rd_adj_dc-rd_pntr_ext+extra_words_fwft;
1525                        always @ (posedge rd_clk) begin
1526       1/1                if (rd_rst_i | invalid_state)
1527       1/1                   rd_data_count_i   &lt;= {RD_DC_WIDTH_EXT{1'b0}};
1528                          else
1529       1/1                   rd_data_count_i  &lt;= diff_wr_rd_pntr_rdc;
1530                        end
1531                        assign rd_data_count = rd_data_count_i[RD_DC_WIDTH_EXT-1:RD_DC_WIDTH_EXT-RD_DATA_COUNT_WIDTH];
1532                      end : grdc
1533                      if (EN_RDC == 0) begin : gnrdc
1534                        assign rd_data_count = {RD_DC_WIDTH_EXT{1'b0}};
1535                      end : gnrdc
1536                    
1537                      endgenerate
1538                    
1539                      // -------------------------------------------------------------------------------------------------------------------
1540                      // Simulation constructs
1541                      // -------------------------------------------------------------------------------------------------------------------
1542                      // synthesis translate_off
1543                    
1544                     `ifndef DISABLE_XPM_ASSERTIONS  
1545                      initial begin
1546       2/2            #1;
1547       1/1              if (SIM_ASSERT_CHK == 1)
1548                        `ifdef OBSOLETE
1549                          $warning(&quot;Vivado Simulator does not currently support the SystemVerilog Assertion syntax used within XPM_FIFO.  \
1550                    Messages related to potential misuse will not be reported.&quot;);
1551                        `else
1552       <font color = "red">0/1     ==>        $warning(&quot;SIM_ASSERT_CHK (%0d) specifies simulation message reporting, messages related to potential misuse \</font>
                        MISSING_ELSE
</pre>
<hr>
<a name="inst_tag_271_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod18.html#inst_tag_271" >AdaptedSharpener.fifo.lineBuffer_0.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">Conditions</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="s6"><td class="lf">Logical</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1084
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; read_only_q)
             ---------------1---------------    -----2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1086
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; write_only_q)
             ---------------1---------------    ------2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_271_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod18.html#inst_tag_271" >AdaptedSharpener.fifo.lineBuffer_0.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s3">
<td>Totals</td>
<td class="rt">129</td>
<td class="rt">49</td>
<td class="rt">37.98 </td>
</tr><tr class="s7">
<td>Total Bits</td>
<td class="rt">864</td>
<td class="rt">607</td>
<td class="rt">70.25 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 0->1</td>
<td class="rt">432</td>
<td class="rt">304</td>
<td class="rt">70.37 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 1->0</td>
<td class="rt">432</td>
<td class="rt">303</td>
<td class="rt">70.14 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s2">
<td>Ports</td>
<td class="rt">27</td>
<td class="rt">8</td>
<td class="rt">29.63 </td>
</tr><tr class="s8">
<td>Port Bits</td>
<td class="rt">178</td>
<td class="rt">145</td>
<td class="rt">81.46 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 0->1</td>
<td class="rt">89</td>
<td class="rt">71</td>
<td class="rt">79.78 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 1->0</td>
<td class="rt">89</td>
<td class="rt">74</td>
<td class="rt">83.15 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s4">
<td>Signals</td>
<td class="rt">102</td>
<td class="rt">41</td>
<td class="rt">40.20 </td>
</tr><tr class="s6">
<td>Signal Bits</td>
<td class="rt">686</td>
<td class="rt">462</td>
<td class="rt">67.35 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">343</td>
<td class="rt">233</td>
<td class="rt">67.93 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">343</td>
<td class="rt">229</td>
<td class="rt">66.76 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>sleep</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>rst</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>wr_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>wr_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>din[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_data_count</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_ack</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rd_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>dout[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>empty</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_empty</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_data_count</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>data_valid</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>injectsbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>injectdbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>dbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>curr_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>next_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus2[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus3[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_plus1_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_inv_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pf_q[6:1]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>invalid_state</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>going_aempty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_aempty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_aempty_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>prog_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_afull_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_ack_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_en_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce_pipe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dout_i[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>aempty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_fwft_fb</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>overflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>underflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_vld_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_gt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_lt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_wr_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe_reg1[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe_reg2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>prog_empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_empty_i_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>fe_of_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_en_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_d2</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rst_d1</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rst_d2</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>clr_full</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extra_words_fwft[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gen_sdpram.rst_int</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.rd_data_count_i[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.rd_data_count_i[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.rd_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_273'>
<a name="inst_tag_273_Line"></a>
<b>Line Coverage for Instance : <a href="mod18.html#inst_tag_273" >AdaptedSharpener.fifo.lineBuffer_2.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">TOTAL</td><td></td><td>142</td><td>86</td><td>60.56</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>126</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">ROUTINE</td><td>304</td><td>5</td><td>4</td><td>80.00</td></tr>
<tr class="s3"><td class="lf">INITIAL</td><td>314</td><td>81</td><td>29</td><td>35.80</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>958</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>994</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1026</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1041</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1049</td><td>9</td><td>8</td><td>88.89</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1064</td><td>9</td><td>9</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1081</td><td>7</td><td>6</td><td>85.71</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1481</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1491</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1507</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1526</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">INITIAL</td><td>1546</td><td>4</td><td>3</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
125                       begin 
126        1/1              value = value-1;
127        1/1              for (clog2=0; value&gt;0; clog2=clog2+1)
128        1/1                value = value&gt;&gt;1;
129                         end 
130                       endfunction
131                       // Function to convert ASCII value to binary 
132                       function [3:0] str2bin;
133                         input [7:0] str_val_ascii;
134                           if((str_val_ascii == 8'h30) || (str_val_ascii == 8'h31) || 
135                              (str_val_ascii == 8'h32) || (str_val_ascii == 8'h33) || 
136                              (str_val_ascii == 8'h34) || (str_val_ascii == 8'h35) || 
137                              (str_val_ascii == 8'h36) || (str_val_ascii == 8'h37) || 
138                              (str_val_ascii == 8'h38) || (str_val_ascii == 8'h39) || 
139                              (str_val_ascii == 8'h41) || (str_val_ascii == 8'h42) || 
140                              (str_val_ascii == 8'h43) || (str_val_ascii == 8'h44) || 
141                              (str_val_ascii == 8'h45) || (str_val_ascii == 8'h46) || 
142                              (str_val_ascii == 8'h61) || (str_val_ascii == 8'h62) || 
143                              (str_val_ascii == 8'h63) || (str_val_ascii == 8'h64) || 
144                              (str_val_ascii == 8'h65) || (str_val_ascii == 8'h66) || 
145                              (str_val_ascii == 8'h00)) begin
146                              if (!str_val_ascii[6])
147                                 str2bin = str_val_ascii[3:0];
148                              else begin
149                                str2bin [3] = 1'b1;
150                                str2bin [2] = str_val_ascii[2] | (str_val_ascii[1] &amp; str_val_ascii[0]);
151                                str2bin [1] = str_val_ascii[0] ^ str_val_ascii[1];
152                                str2bin [0] = !str_val_ascii[0];
153                              end
154                           end
155                           else
156                             $error(&quot;Found Invalid character while parsing the string, please cross check the value specified for either READ_RESET_VALUE_A|B or MEMORY_INIT_PARAM (if initialization of memory through parameter is used). XPM_MEMORY supports strings (hex) that contains characters 0-9, A-F and a-f.&quot;);
157                       endfunction
158                       // Function that parses the complete reset value string
159                       function logic [15:0] hstr2bin;
160                         input [16*8-1 : 0] hstr_val;
161                         integer rst_loop_a;
162                         localparam integer  rsta_loop_iter  =  16;
163                         logic [rsta_loop_iter-1 : 0] rst_val_conv_a_i;
164                         for (rst_loop_a=1; rst_loop_a &lt;= rsta_loop_iter/4; rst_loop_a = rst_loop_a+1) begin
165                           rst_val_conv_a_i[(rst_loop_a*4)-1 -: 4] =  str2bin(hstr_val[(rst_loop_a*8)-1 -: 8]);
166                         end
167                         return rst_val_conv_a_i[15:0];
168                       endfunction
169                     
170                     
171                       localparam invalid             = 0;
172                       localparam stage1_valid        = 2;
173                       localparam stage2_valid        = 1;
174                       localparam both_stages_valid   = 3;
175                     
176                       reg  [1:0] curr_fwft_state = invalid;
177                       reg  [1:0] next_fwft_state;// = invalid;
178                     
179                     
180                     
181                       localparam FIFO_MEM_TYPE   = FIFO_MEMORY_TYPE;
182                       localparam RD_MODE         = READ_MODE;
183                       localparam ENABLE_ECC      = (ECC_MODE == 1) ? 3 : 0;
184                       localparam FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH;
185                       localparam FIFO_SIZE       = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH;
186                       localparam WR_WIDTH_LOG    = clog2(WRITE_DATA_WIDTH);
187                       localparam WR_DEPTH_LOG    = clog2(FIFO_WRITE_DEPTH);
188                       localparam WR_PNTR_WIDTH   = clog2(FIFO_WRITE_DEPTH);
189                       localparam RD_PNTR_WIDTH   = clog2(FIFO_READ_DEPTH);
190                       localparam FULL_RST_VAL    = FULL_RESET_VALUE == 0 ? 1'b0 : 1'b1;
191                       localparam WR_RD_RATIO     = (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) ? (WR_PNTR_WIDTH-RD_PNTR_WIDTH) : 0;
192                       localparam READ_MODE_LL    = (READ_MODE == 0) ? 0 : 1;
193                       localparam PF_THRESH_ADJ   = (READ_MODE == 0) ? PROG_FULL_THRESH :
194                                                    PROG_FULL_THRESH - (2*(2**WR_RD_RATIO));
195                       localparam PE_THRESH_ADJ   = (READ_MODE_LL == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) ? PROG_EMPTY_THRESH - 2'h2 : PROG_EMPTY_THRESH;
196                     
197                       localparam PF_THRESH_MIN   = 3+(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1))+(COMMON_CLOCK?0:CDC_DEST_SYNC_FF);
198                       localparam PF_THRESH_MAX   = (FIFO_WRITE_DEPTH-3)-(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1));
199                       localparam PE_THRESH_MIN   = 3+(READ_MODE_LL*2);
200                       localparam PE_THRESH_MAX   = (FIFO_READ_DEPTH-3)-(READ_MODE_LL*2);
201                       localparam WR_DC_WIDTH_EXT = clog2(FIFO_WRITE_DEPTH)+1;
202                       localparam RD_DC_WIDTH_EXT = clog2(FIFO_READ_DEPTH)+1;
203                       localparam RD_LATENCY      = (READ_MODE == 2) ? 1 : (READ_MODE == 1) ? 2 : FIFO_READ_LATENCY;
204                       localparam WIDTH_RATIO     = (READ_DATA_WIDTH &gt; WRITE_DATA_WIDTH) ? (READ_DATA_WIDTH/WRITE_DATA_WIDTH) : (WRITE_DATA_WIDTH/READ_DATA_WIDTH);
205                     
206                       localparam [15:0] EN_ADV_FEATURE = hstr2bin(USE_ADV_FEATURES);
207                     
208                       localparam EN_OF           = EN_ADV_FEATURE[0];  //EN_ADV_FLAGS_WR[0] ? 1 : 0;
209                       localparam EN_PF           = EN_ADV_FEATURE[1];  //EN_ADV_FLAGS_WR[1] ? 1 : 0;
210                       localparam EN_WDC          = EN_ADV_FEATURE[2];  //EN_ADV_FLAGS_WR[2] ? 1 : 0;
211                       localparam EN_AF           = EN_ADV_FEATURE[3];  //EN_ADV_FLAGS_WR[3] ? 1 : 0;
212                       localparam EN_WACK         = EN_ADV_FEATURE[4];  //EN_ADV_FLAGS_WR[4] ? 1 : 0;
213                       localparam FG_EQ_ASYM_DOUT = EN_ADV_FEATURE[5];  //EN_ADV_FLAGS_WR[5] ? 1 : 0;
214                       localparam EN_UF           = EN_ADV_FEATURE[8];  //EN_ADV_FLAGS_RD[0] ? 1 : 0;
215                       localparam EN_PE           = EN_ADV_FEATURE[9];  //EN_ADV_FLAGS_RD[1] ? 1 : 0;
216                       localparam EN_RDC          = EN_ADV_FEATURE[10]; //EN_ADV_FLAGS_RD[2] ? 1 : 0;
217                       localparam EN_AE           = EN_ADV_FEATURE[11]; //EN_ADV_FLAGS_RD[3] ? 1 : 0;
218                       localparam EN_DVLD         = EN_ADV_FEATURE[12]; //EN_ADV_FLAGS_RD[4] ? 1 : 0;
219                     
220                       wire                       wrst_busy;
221                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr;
222                       wire [WR_PNTR_WIDTH:0]     wr_pntr_ext;
223                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd_cdc;
224                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_cdc_dc;
225                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd;
226                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_dc;
227                       wire [WR_PNTR_WIDTH-1:0]   rd_pntr_wr_adj;
228                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_dc;
229                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus1;
230                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus2;
231                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus3;
232                       wire [WR_PNTR_WIDTH:0]     wr_pntr_plus1_pf;
233                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_inv_pf;
234                       reg  [WR_PNTR_WIDTH:0]     diff_pntr_pf_q = {WR_PNTR_WIDTH{1'b0}};
235                       wire [WR_PNTR_WIDTH-1:0]   diff_pntr_pf;
236                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr;
237                       wire [RD_PNTR_WIDTH:0]     rd_pntr_ext;
238                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr_cdc;
239                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr;
240                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_cdc_dc;
241                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_dc;
242                       wire [RD_PNTR_WIDTH-1:0]   wr_pntr_rd_adj;
243                       wire [RD_PNTR_WIDTH:0]     wr_pntr_rd_adj_dc;
244                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus1;
245                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus2;
246                       wire                       invalid_state;
247                       wire                       valid_fwft;
248                       wire                       ram_valid_fwft;
249                       wire                       going_empty;
250                       wire                       leaving_empty;
251                       wire                       going_aempty;
252                       wire                       leaving_aempty;
253                       reg                        ram_empty_i  = 1'b1;
254                       reg                        ram_aempty_i = 1'b1;
255                       wire                       empty_i;
256                       wire                       going_full;
257                       wire                       leaving_full;
258                       wire                       going_afull;
259                       wire                       leaving_afull;
260                       reg                        prog_full_i = FULL_RST_VAL;
261                       reg                        ram_full_i  = FULL_RST_VAL;
262                       reg                        ram_afull_i = FULL_RST_VAL;
263                       reg                        ram_full_n  = ~FULL_RST_VAL;
264                       wire                       ram_wr_en_i;
265                       wire                       ram_rd_en_i;
266                       reg                        wr_ack_i = 1'b0;
267                       wire                       rd_en_i;
268                       reg                        rd_en_fwft;
269                       wire                       ram_regce;
270                       wire                       ram_regce_pipe;
271                       wire [READ_DATA_WIDTH-1:0] dout_i;
272                       reg                        empty_fwft_i     = 1'b1;
273                       reg                        aempty_fwft_i    = 1'b1;
274                       reg                        empty_fwft_fb    = 1'b1;
275                       reg                        overflow_i       = 1'b0;
276                       reg                        underflow_i      = 1'b0;
277                       reg                        data_valid_fwft  = 1'b0;
278                       reg                        data_valid_std   = 1'b0;
279                       wire                       data_vld_std;
280                       wire                       wrp_gt_rdp_and_red;
281                       wire                       wrp_lt_rdp_and_red;
282                       reg                        ram_wr_en_pf_q = 1'b0;
283                       reg                        ram_rd_en_pf_q = 1'b0;
284                       wire                       ram_wr_en_pf;
285                       wire                       ram_rd_en_pf;
286                       wire                       wr_pntr_plus1_pf_carry;
287                       wire                       rd_pntr_wr_adj_pf_carry;
288                       wire                       write_allow;
289                       wire                       read_allow;
290                       wire                       read_only;
291                       wire                       write_only;
292                       reg                        write_only_q;
293                       reg                        read_only_q;
294                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg1;
295                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg2;
296                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe = 'b0;
297                       reg                        prog_empty_i = 1'b1;
298                       reg                        ram_empty_i_d1 = 1'b1;
299                       wire                       fe_of_empty;
300                       // function to validate the write depth value
301                       function logic dpth_pwr_2;
302                         input integer fifo_depth;
303                         integer log2_of_depth; // correcponding to the default value of 2k depth
304        1/1              log2_of_depth = clog2(fifo_depth);
305        1/1              if (fifo_depth == 2 ** log2_of_depth)
306        1/1                dpth_pwr_2 = 1;
307                         else
308        <font color = "red">0/1     ==>        dpth_pwr_2 = 0;</font>
309        1/1              return dpth_pwr_2;
310                       endfunction
311                       
312                       initial begin : config_drc
313                         reg drc_err_flag;
314        1/1              drc_err_flag = 0;
315        2/2              #1;
316                     
317        1/1              if (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEM_TYPE == 3) begin
318        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] UltraRAM cannot be used as asynchronous FIFO because it has only one clock support %m&quot;, &quot;XPM_FIFO&quot;, 1, 1);</font>
319        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
320                         end
                        MISSING_ELSE
321                     
322        1/1              if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 1) begin
323        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Related Clocks cannot be used in synchronous FIFO because it is applicable only for asynchronous FIFO %m&quot;, &quot;XPM_FIFO&quot;, 1, 2);</font>
324        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
325                         end
                        MISSING_ELSE
326                     
327        1/1              if(!(FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
328        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is not within the supported ranges. Miniumum supported depth is 16, and the maximum supported depth is 4*1024*1024 locations. %m&quot;, &quot;XPM_FIFO&quot;, 1, 3, FIFO_WRITE_DEPTH);</font>
329        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
330                         end
                        MISSING_ELSE
331                     
332        1/1              if(!dpth_pwr_2(FIFO_WRITE_DEPTH) &amp;&amp; (FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
333        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is non-power of 2, but this release of XPM_FIFO supports configurations having the fifo write depth set to power of 2. %m&quot;, &quot;XPM_FIFO&quot;, 1, 4, FIFO_WRITE_DEPTH);</font>
334        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
335                         end
                        MISSING_ELSE
336                     
337        1/1              if (CDC_DEST_SYNC_FF &lt; 2 || CDC_DEST_SYNC_FF &gt; 8) begin
338        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but this beta release of XPM_FIFO supports CDC_DEST_SYNC_FF values in between 2 and 8. %m&quot;, &quot;XPM_FIFO&quot;, 1, 5,CDC_DEST_SYNC_FF);</font>
339        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
340                         end
                        MISSING_ELSE
341        1/1              if (CDC_DEST_SYNC_FF != 2 &amp;&amp; RELATED_CLOCKS == 1) begin
342        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but CDC_DEST_SYNC_FF value can not be modified from default value when RELATED_CLOCKS parameter is set to 1. %m&quot;, &quot;XPM_FIFO&quot;, 1, 6,CDC_DEST_SYNC_FF);</font>
343        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
344                         end
                        MISSING_ELSE
345        1/1              if (FIFO_WRITE_DEPTH == 16 &amp;&amp; CDC_DEST_SYNC_FF &gt; 4) begin
346        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF = %0d and FIFO_WRITE_DEPTH = %0d. This is invalid combination. Either FIFO_WRITE_DEPTH should be increased or CDC_DEST_SYNC_FF should be reduced. %m&quot;, &quot;XPM_FIFO&quot;, 1, 7,CDC_DEST_SYNC_FF, FIFO_WRITE_DEPTH);</font>
347        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
348                         end
                        MISSING_ELSE
349        1/1              if (EN_ADV_FEATURE[7:5] != 3'h0) begin
350        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[7:5] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 8, EN_ADV_FEATURE[7:5]);</font>
351        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
352                         end
                        MISSING_ELSE
353        1/1              if (EN_ADV_FEATURE[15:14] != 3'h0) begin
354        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[15:13] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 9, EN_ADV_FEATURE[15:13]);</font>
355        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
356                         end
                        MISSING_ELSE
357                     //    if(WIDTH_RATIO &gt; 32) begin
358                     //      $error(&quot;[%s %0d-%0d] The ratio between WRITE_DATA_WIDTH (%0d) and READ_DATA_WIDTH (%0d) is greater than 32, but this release of XPM_FIFO supports configurations having the ratio between data widths must be less than 32. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH, READ_DATA_WIDTH);
359                     //      drc_err_flag = 1;
360                     //    end
361        1/1              if (WR_WIDTH_LOG+WR_DEPTH_LOG &gt; 30) begin
362        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The specified Width(%0d) and Depth(%0d) exceeds the maximum supported FIFO SIZE. Please reduce either FIFO Width or Depth. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH,FIFO_WRITE_DEPTH);</font>
363        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
364                         end
                        MISSING_ELSE
365        1/1              if(FIFO_READ_DEPTH &lt; 16) begin
366        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Width is %0d Read Width is %0d and Write Depth is %0d, this results in the Read Depth(%0d) less than 16. This is an invalid combination, Ensure the depth on both sides is minimum 16. %m&quot;, &quot;XPM_FIFO&quot;, 1, 11, WRITE_DATA_WIDTH, READ_DATA_WIDTH, FIFO_WRITE_DEPTH, FIFO_READ_DEPTH);</font>
367        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
368                         end
                        MISSING_ELSE
369                     
370                         // Range Checks
371        1/1              if (COMMON_CLOCK &gt; 1) begin
372        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] COMMON_CLOCK (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 1, COMMON_CLOCK);</font>
373        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
374                         end
                        MISSING_ELSE
375        1/1              if (FIFO_MEMORY_TYPE &gt; 3) begin
376        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_MEMORY_TYPE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 2, FIFO_MEMORY_TYPE);</font>
377        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
378                         end
                        MISSING_ELSE
379        1/1          	if (READ_MODE &gt; 2) begin
380        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 3, READ_MODE);</font>
381        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
382                         end
                        MISSING_ELSE
383                     
384        1/1              if (ECC_MODE &gt; 1) begin
385        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] ECC_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 4, ECC_MODE);</font>
386        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
387                         end
                        MISSING_ELSE
388        1/1          	if (!(WAKEUP_TIME == 0 || WAKEUP_TIME == 2)) begin
389        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WAKEUP_TIME (%0d) value is outside of legal range. WAKEUP_TIME should be either 0 or 2. %m&quot;, &quot;XPM_FIFO&quot;, 10, 5, WAKEUP_TIME);</font>
390        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
391                         end
                        MISSING_ELSE
392        1/1              if (!(VERSION == 0)) begin
393        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] VERSION (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 6, VERSION);</font>
394        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
395                         end
                        MISSING_ELSE
396                     
397        1/1              if (!(WRITE_DATA_WIDTH &gt; 0)) begin
398        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 2, WRITE_DATA_WIDTH);</font>
399        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
400                         end
                        MISSING_ELSE
401        1/1              if (!(READ_DATA_WIDTH &gt; 0)) begin
402        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 3, READ_DATA_WIDTH);</font>
403        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
404                         end
                        MISSING_ELSE
405                     
406        1/1              if (EN_PF == 1 &amp;&amp; ((PROG_FULL_THRESH &lt; PF_THRESH_MIN) || (PROG_FULL_THRESH &gt; PF_THRESH_MAX))) begin
407        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Full flag is enabled, but PROG_FULL_THRESH (%0d) value is outside of legal range. PROG_FULL_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 4, PROG_FULL_THRESH, PF_THRESH_MIN, PF_THRESH_MAX);</font>
408        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
409                         end
                        MISSING_ELSE
410                     
411        1/1              if (EN_PE == 1 &amp;&amp; (WIDTH_RATIO &lt;= 32) &amp;&amp; ((PROG_EMPTY_THRESH &lt; PE_THRESH_MIN) || (PROG_EMPTY_THRESH &gt; PE_THRESH_MAX))) begin
412        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Empty flag is enabled, but PROG_EMPTY_THRESH (%0d) value is outside of legal range. PROG_EMPTY_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 5, PROG_EMPTY_THRESH, PE_THRESH_MIN, PE_THRESH_MAX);</font>
413        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
414                         end
                        MISSING_ELSE
415                     
416        1/1              if (EN_WDC == 1 &amp;&amp; ((WR_DATA_COUNT_WIDTH &lt; 0) || (WR_DATA_COUNT_WIDTH &gt; WR_DC_WIDTH_EXT))) begin
417        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Data Count is enabled, but WR_DATA_COUNT_WIDTH (%0d) value is outside of legal range. WR_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 6, WR_DATA_COUNT_WIDTH, 0, WR_DC_WIDTH_EXT);</font>
418        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
419                         end
                        MISSING_ELSE
420                     
421                     
422        1/1              if (EN_RDC == 1 &amp;&amp; ((RD_DATA_COUNT_WIDTH &lt; 0) || (RD_DATA_COUNT_WIDTH &gt; RD_DC_WIDTH_EXT))) begin
423        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Read Data Count is enabled, but RD_DATA_COUNT_WIDTH (%0d) value is outside of legal range. RD_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 7, RD_DATA_COUNT_WIDTH, 0, RD_DC_WIDTH_EXT);</font>
424        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
425                         end
                        MISSING_ELSE
426                     
427                         //DRCs on Low Latency FWFT mode
428        1/1              if (READ_MODE == 2 &amp;&amp; FIFO_MEMORY_TYPE != 1) begin
429        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] XPM_FIFO does not support Read Mode (Low Latency FWFT) for FIFO_MEMORY_TYPE other than lutram/distributed. %m&quot;, &quot;XPM_FIFO&quot;, 16, 2);</font>
430        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
431                         end
                        MISSING_ELSE
432        1/1              if (READ_MODE == 2 &amp;&amp; EN_ADV_FEATURE != 16'h0) begin
433        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES = %0h. XPM_FIFO does not support Advanced Features in Low Latency FWFT mode. %m&quot;, &quot;XPM_FIFO&quot;, 16, 3, EN_ADV_FEATURE);</font>
434        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
435                         end
                        MISSING_ELSE
436                     
437                         // Infos
438                     
439                         // Warnings
440        1/1              if (drc_err_flag == 1)
441        <font color = "red">0/2     ==>        #1 $finish;</font>
                        MISSING_ELSE
442                       end : config_drc
443                     
444                       wire wr_en_i;
445                       wire wr_rst_i;
446                       wire rd_rst_i;
447                       reg  rd_rst_d2 = 1'b0;
448                       wire rst_d1;
449                       wire rst_d2;
450                       wire clr_full;
451                       wire empty_fwft_d1;
452                       wire leaving_empty_fwft_fe;
453                       wire leaving_empty_fwft_re;
454                       wire le_fwft_re;
455                       wire le_fwft_fe;
456                       wire [1:0] extra_words_fwft;
457                       wire le_fwft_re_wr;
458                       wire le_fwft_fe_wr;
459                     
460                       generate
461                     
462                       xpm_fifo_rst # (COMMON_CLOCK, CDC_DEST_SYNC_FF, SIM_ASSERT_CHK)
463                         xpm_fifo_rst_inst (rst, wr_clk, rd_clk, wr_rst_i, rd_rst_i, wrst_busy, rd_rst_busy);
464                       assign wr_rst_busy = wrst_busy | rst_d1;
465                     
466                       xpm_fifo_reg_bit #(0)
467                         rst_d1_inst (1'b0, wr_clk, wrst_busy, rst_d1);
468                       xpm_fifo_reg_bit #(0)
469                         rst_d2_inst (1'b0, wr_clk, rst_d1, rst_d2);
470                     
471                       assign clr_full = ~wrst_busy &amp; rst_d1 &amp; ~rst;
472                       assign rd_en_i = (RD_MODE == 0) ? rd_en : rd_en_fwft;
473                     
474                       if (REMOVE_WR_RD_PROT_LOGIC == 1) begin : ngen_wr_rd_prot
475                         assign ram_wr_en_i = wr_en;
476                         assign ram_rd_en_i = rd_en_i;
477                       end : ngen_wr_rd_prot
478                       else begin : gen_wr_rd_prot
479                         assign ram_wr_en_i = wr_en &amp; ~ram_full_i &amp; ~(wrst_busy|rst_d1);
480                         assign ram_rd_en_i = rd_en_i &amp; ~ram_empty_i;
481                       end : gen_wr_rd_prot
482                     
483                       // Write pointer generation
484                       xpm_counter_updn # (WR_PNTR_WIDTH+1, 0)
485                         wrp_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_ext);
486                       assign wr_pntr = wr_pntr_ext[WR_PNTR_WIDTH-1:0];
487                     
488                       xpm_counter_updn # (WR_PNTR_WIDTH, 1)
489                         wrpp1_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus1);
490                     
491                       xpm_counter_updn # (WR_PNTR_WIDTH, 2)
492                         wrpp2_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus2);
493                     
494                       if (EN_AF == 1) begin : gaf_wptr_p3
495                         xpm_counter_updn # (WR_PNTR_WIDTH, 3)
496                           wrpp3_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus3);
497                       end : gaf_wptr_p3
498                     
499                       // Read pointer generation
500                       xpm_counter_updn # (RD_PNTR_WIDTH+1, 0)
501                         rdp_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_ext);
502                       assign rd_pntr = rd_pntr_ext[RD_PNTR_WIDTH-1:0];
503                     
504                       xpm_counter_updn # (RD_PNTR_WIDTH, 1)
505                         rdpp1_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus1);
506                     
507                       if (EN_AE == 1) begin : gae_rptr_p2
508                         xpm_counter_updn # (RD_PNTR_WIDTH, 2)
509                           rdpp2_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus2);
510                       end : gae_rptr_p2
511                     
512                       assign full        = ram_full_i;
513                       assign full_n      = ram_full_n;
514                       assign almost_full = EN_AF == 1 ? ram_afull_i : 1'b0;
515                       assign wr_ack      = EN_WACK == 1 ? wr_ack_i : 1'b0;
516                       if (EN_WACK == 1) begin : gwack
517                         always @ (posedge wr_clk) begin
518                           if (rst | wr_rst_i | wrst_busy)
519                             wr_ack_i  &lt;= 1'b0;
520                           else
521                             wr_ack_i  &lt;= ram_wr_en_i;
522                         end
523                       end : gwack
524                     
525                       assign prog_full  = EN_PF == 1 ? (PROG_FULL_THRESH &gt; 0)  ? prog_full_i  : 1'b0 : 1'b0;
526                       assign prog_empty = EN_PE == 1 ? (PROG_EMPTY_THRESH &gt; 0) ? prog_empty_i : 1'b1 : 1'b0;
527                       
528                       assign empty_i = (RD_MODE == 0)? ram_empty_i : empty_fwft_i;
529                       assign empty   = empty_i;
530                       assign almost_empty = EN_AE == 1 ? (RD_MODE == 0) ? ram_aempty_i : aempty_fwft_i : 1'b0;
531                       
532                       assign data_valid   = EN_DVLD == 1 ? (RD_MODE == 0) ? data_valid_std : data_valid_fwft : 1'b0;
533                       if (EN_DVLD == 1) begin : gdvld
534                         assign data_vld_std = (RD_MODE == 0) ? (FIFO_READ_LATENCY == 1) ? ram_rd_en_i: ram_regce_pipe : ram_regce;
535                         always @ (posedge rd_clk) begin
536                           if (rd_rst_i)
537                             data_valid_std  &lt;= 1'b0;
538                           else
539                             data_valid_std  &lt;= data_vld_std;
540                         end
541                       end : gdvld
542                     
543                       // Simple dual port RAM instantiation for non-Built-in FIFO
544                       if (FIFO_MEMORY_TYPE &lt; 4) begin : gen_sdpram
545                     
546                       // Reset is not supported when ECC is enabled by the BRAM/URAM primitives
547                         wire rst_int;
548                         if(ECC_MODE !=0) begin : gnd_rst
549                           assign rst_int = 0;
550                         end : gnd_rst
551                         else begin : rst_gen
552                           assign rst_int = rd_rst_i;
553                         end : rst_gen
554                       // ----------------------------------------------------------------------
555                       // Base module instantiation with simple dual port RAM configuration
556                       // ----------------------------------------------------------------------
557                       localparam USE_DRAM_CONSTRAINT = (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEMORY_TYPE == 1) ? 1 : 0;
558                       localparam WR_MODE_B           = (FIFO_MEMORY_TYPE == 1 || FIFO_MEMORY_TYPE == 3) ? 1 : 2;
559                       xpm_memory_base # (
560                     
561                         // Common module parameters
562                         .MEMORY_TYPE              (1                    ),
563                         .MEMORY_SIZE              (FIFO_SIZE            ),
564                         .MEMORY_PRIMITIVE         (FIFO_MEMORY_TYPE     ),
565                         .CLOCKING_MODE            (COMMON_CLOCK ? 0 : 1 ),
566                         .ECC_MODE                 (ENABLE_ECC           ),
567                         .USE_MEM_INIT             (0                    ),
568                         .MEMORY_INIT_FILE         (&quot;none&quot;               ),
569                         .MEMORY_INIT_PARAM        (&quot;&quot;                   ),
570                         .WAKEUP_TIME              (WAKEUP_TIME          ),
571                         .MESSAGE_CONTROL          (0                    ),
572                         .VERSION                  (0                    ),
573                         .MEMORY_OPTIMIZATION      (&quot;true&quot;               ),
574                         .AUTO_SLEEP_TIME          (0                    ),
575                         .USE_EMBEDDED_CONSTRAINT  (USE_DRAM_CONSTRAINT  ),
576                         .CASCADE_HEIGHT           (CASCADE_HEIGHT       ),
577                     
578                         // Port A module parameters
579                         .WRITE_DATA_WIDTH_A       (WRITE_DATA_WIDTH     ),
580                         .READ_DATA_WIDTH_A        (WRITE_DATA_WIDTH     ),
581                         .BYTE_WRITE_WIDTH_A       (WRITE_DATA_WIDTH     ),
582                         .ADDR_WIDTH_A             (WR_PNTR_WIDTH        ),
583                         .READ_RESET_VALUE_A       (&quot;0&quot;                  ),
584                         .READ_LATENCY_A           (2                    ),
585                         .WRITE_MODE_A             (2                    ),
586                     
587                         // Port B module parameters
588                         .WRITE_DATA_WIDTH_B       (READ_DATA_WIDTH      ),
589                         .READ_DATA_WIDTH_B        (READ_DATA_WIDTH      ),
590                         .BYTE_WRITE_WIDTH_B       (READ_DATA_WIDTH      ),
591                         .ADDR_WIDTH_B             (RD_PNTR_WIDTH        ),
592                         .READ_RESET_VALUE_B       (DOUT_RESET_VALUE     ),
593                         .READ_LATENCY_B           (RD_LATENCY           ),
594                         .WRITE_MODE_B             (WR_MODE_B            )
595                       ) xpm_memory_base_inst (
596                     
597                         // Common module ports
598                         .sleep          (sleep                    ),
599                     
600                         // Port A module ports
601                         .clka           (wr_clk                   ),
602                         .rsta           (1'b0                     ),
603                         .ena            (ram_wr_en_i              ),
604                         .regcea         (1'b0                     ),
605                         .wea            (ram_wr_en_i              ),
606                         .addra          (wr_pntr                  ),
607                         .dina           (din                      ),
608                         .injectsbiterra (injectsbiterr            ),
609                         .injectdbiterra (injectdbiterr            ),
610                         .douta          (                         ),
611                         .sbiterra       (                         ),
612                         .dbiterra       (                         ),
613                     
614                         // Port B module ports
615                         .clkb           (rd_clk                   ),
616                         .rstb           (rst_int                  ),
617                         .enb            (ram_rd_en_i              ),
618                         .regceb         (READ_MODE == 0 ? ram_regce_pipe: ram_regce),
619                         .web            (1'b0                     ),
620                         .addrb          (rd_pntr                  ),
621                         .dinb           ({READ_DATA_WIDTH{1'b0}}  ),
622                         .injectsbiterrb (1'b0                     ),
623                         .injectdbiterrb (1'b0                     ),
624                         .doutb          (dout_i                   ),
625                         .sbiterrb       (sbiterr                  ),
626                         .dbiterrb       (dbiterr                  )
627                       );
628                       end : gen_sdpram
629                     
630                       if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
631                         assign wr_pntr_rd_adj    = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
632                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
633                         assign rd_pntr_wr_adj    = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
634                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
635                       end : wrp_eq_rdp
636                     
637                       if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
638                         assign wr_pntr_rd_adj = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
639                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
640                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr;
641                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
642                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr_dc;
643                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
644                       end : wrp_gt_rdp
645                     
646                       if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
647                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd;
648                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
649                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd_dc;
650                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
651                         assign rd_pntr_wr_adj = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
652                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
653                       end : wrp_lt_rdp
654                     
655                       if (COMMON_CLOCK == 0 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_cdc_pntr
656                         // Synchronize the write pointer in rd_clk domain
657                         xpm_cdc_gray #(
658                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
659                           .INIT_SYNC_FF          (1),
660                           .WIDTH                 (WR_PNTR_WIDTH))
661                           
662                           wr_pntr_cdc_inst (
663                             .src_clk             (wr_clk),
664                             .src_in_bin          (wr_pntr),
665                             .dest_clk            (rd_clk),
666                             .dest_out_bin        (wr_pntr_rd_cdc));
667                     
668                         // Register the output of XPM_CDC_GRAY on read side
669                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
670                           wpr_gray_reg (rd_rst_i, rd_clk, wr_pntr_rd_cdc, wr_pntr_rd);
671                     
672                         // Synchronize the extended write pointer in rd_clk domain
673                         xpm_cdc_gray #(
674                           .DEST_SYNC_FF          (READ_MODE == 0 ? CDC_DEST_SYNC_FF : CDC_DEST_SYNC_FF+2),
675                           .INIT_SYNC_FF          (1),
676                           .WIDTH                 (WR_PNTR_WIDTH+1))
677                           wr_pntr_cdc_dc_inst (
678                             .src_clk             (wr_clk),
679                             .src_in_bin          (wr_pntr_ext),
680                             .dest_clk            (rd_clk),
681                             .dest_out_bin        (wr_pntr_rd_cdc_dc));
682                     
683                         // Register the output of XPM_CDC_GRAY on read side
684                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
685                           wpr_gray_reg_dc (rd_rst_i, rd_clk, wr_pntr_rd_cdc_dc, wr_pntr_rd_dc);
686                     
687                         // Synchronize the read pointer in wr_clk domain
688                         xpm_cdc_gray #(
689                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
690                           .INIT_SYNC_FF          (1),
691                           .WIDTH                 (RD_PNTR_WIDTH))
692                           rd_pntr_cdc_inst (
693                             .src_clk             (rd_clk),
694                             .src_in_bin          (rd_pntr),
695                             .dest_clk            (wr_clk),
696                             .dest_out_bin        (rd_pntr_wr_cdc));
697                     
698                         // Register the output of XPM_CDC_GRAY on write side
699                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
700                           rpw_gray_reg (wrst_busy, wr_clk, rd_pntr_wr_cdc, rd_pntr_wr);
701                     
702                         // Synchronize the read pointer, subtracted by the extra word read for FWFT, in wr_clk domain
703                         xpm_cdc_gray #(
704                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
705                           .INIT_SYNC_FF          (1),
706                           .WIDTH                 (RD_PNTR_WIDTH+1))
707                           rd_pntr_cdc_dc_inst (
708                             .src_clk             (rd_clk),
709                             .src_in_bin          (rd_pntr_ext-extra_words_fwft),
710                             .dest_clk            (wr_clk),
711                             .dest_out_bin        (rd_pntr_wr_cdc_dc));
712                     
713                         // Register the output of XPM_CDC_GRAY on write side
714                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
715                           rpw_gray_reg_dc (wrst_busy, wr_clk, rd_pntr_wr_cdc_dc, rd_pntr_wr_dc);
716                     
717                       end : gen_cdc_pntr
718                     
719                       if (RELATED_CLOCKS == 1) begin : gen_pntr_pf_rc
720                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
721                           rpw_rc_reg (wrst_busy, wr_clk, rd_pntr, rd_pntr_wr);
722                     
723                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
724                           wpr_rc_reg (rd_rst_i, rd_clk, wr_pntr, wr_pntr_rd);
725                     
726                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
727                           wpr_rc_reg_dc (rd_rst_i, rd_clk, wr_pntr_ext, wr_pntr_rd_dc);
728                     
729                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
730                           rpw_rc_reg_dc (wrst_busy, wr_clk, (rd_pntr_ext-extra_words_fwft), rd_pntr_wr_dc);
731                       end : gen_pntr_pf_rc
732                     
733                       if (COMMON_CLOCK == 0 || RELATED_CLOCKS == 1) begin : gen_pf_ic_rc
734                       
735                         assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_rd_en_i);
736                         assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr));
737                         assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ram_rd_en_i);
738                         assign leaving_aempty  = ((wr_pntr_rd_adj == rd_pntr_plus1));
739                       
740                         assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i);
741                         assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr_plus1));
742                         assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus3) &amp; ram_wr_en_i);
743                         assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus2));
744                       
745                         // Empty flag generation
746                         always @ (posedge rd_clk) begin
747                           if (rd_rst_i) begin
748                              ram_empty_i  &lt;= 1'b1;
749                           end else begin
750                              ram_empty_i  &lt;= going_empty | leaving_empty;
751                           end
752                         end
753                     
754                         if (EN_AE == 1) begin : gae_ic_std
755                           always @ (posedge rd_clk) begin
756                             if (rd_rst_i) begin
757                               ram_aempty_i &lt;= 1'b1;
758                             end else if (~ram_empty_i) begin
759                               ram_aempty_i &lt;= going_aempty | leaving_aempty;
760                             end
761                           end
762                         end : gae_ic_std
763                       
764                         // Full flag generation
765                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
766                           always @ (posedge wr_clk) begin
767                     	if (wrst_busy) begin
768                               ram_full_i      &lt;= FULL_RST_VAL;
769                               ram_full_n      &lt;= ~FULL_RST_VAL;
770                             end else begin
771                     	  if (clr_full) begin
772                                 ram_full_i    &lt;= 1'b0;
773                                 ram_full_n    &lt;= 1'b1;
774                     	  end else begin
775                                 ram_full_i    &lt;= going_full | leaving_full;
776                                 ram_full_n    &lt;= ~(going_full | leaving_full);
777                               end
778                             end
779                           end
780                         end : gen_full_rst_val
781                         else begin : ngen_full_rst_val
782                           always @ (posedge wr_clk) begin
783                     	if (wrst_busy) begin
784                               ram_full_i   &lt;= 1'b0;
785                               ram_full_n   &lt;= 1'b1;
786                     	end else begin
787                               ram_full_i   &lt;= going_full | leaving_full;
788                               ram_full_n   &lt;= ~(going_full | leaving_full);
789                     	end
790                           end
791                         end : ngen_full_rst_val
792                     
793                         if (EN_AF == 1) begin : gaf_ic
794                           always @ (posedge wr_clk) begin
795                     	if (wrst_busy) begin
796                               ram_afull_i  &lt;= FULL_RST_VAL;
797                             end else if (~rst) begin
798                     	  if (clr_full) begin
799                                 ram_afull_i  &lt;= 1'b0;
800                     	  end else if (~ram_full_i) begin
801                                 ram_afull_i  &lt;= going_afull | leaving_afull;
802                               end
803                             end
804                           end
805                         end : gaf_ic
806                     
807                       // synthesis translate_off
808                         `ifndef DISABLE_XPM_ASSERTIONS
809                         if (SIM_ASSERT_CHK == 1) begin: assert_wr_rd_en
810                           always @ (posedge rd_clk) begin
811                             assert (!$isunknown(rd_en)) else $warning (&quot;Input port 'rd_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'rd_en' has a valid value ('0' or '1')&quot;,$time);
812                           end
813                     
814                           always @ (posedge wr_clk) begin
815                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
816                           end
817                     
818                           always @ (posedge wr_clk) begin
819                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
820                           end
821                     
822                         end : assert_wr_rd_en
823                         `endif
824                       // synthesis translate_on
825                     
826                         // Programmable Full flag generation
827                         if (EN_PF == 1) begin : gpf_ic
828                           assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
829                           assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
830                       
831                           // PF carry generation
832                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i;
833                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i;
834                       
835                           // PF diff pointer generation
836                           always @ (posedge wr_clk) begin
837                             if (wrst_busy)
838                                diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
839                             else
840                                diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
841                           end
842                           assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
843                       
844                           always @ (posedge wr_clk) begin
845                             if (wrst_busy)
846                                prog_full_i  &lt;= FULL_RST_VAL;
847                             else if (clr_full)
848                                prog_full_i  &lt;= 1'b0;
849                             else if (~ram_full_i) begin
850                               if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
851                                 prog_full_i  &lt;= 1'b1;
852                               else
853                                 prog_full_i  &lt;= 1'b0;
854                             end else
855                               prog_full_i  &lt;= prog_full_i;
856                           end
857                         end : gpf_ic
858                     
859                         /*********************************************************
860                          * Programmable EMPTY flags
861                          *********************************************************/
862                         //Determine the Assert and Negate thresholds for Programmable Empty
863                         if (EN_PE == 1) begin : gpe_ic
864                      
865                           always @(posedge rd_clk) begin
866                             if (rd_rst_i) begin
867                               diff_pntr_pe      &lt;= 0;
868                               prog_empty_i       &lt;= 1'b1;
869                             end else begin
870                               if (ram_rd_en_i)
871                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr) - 1'h1;
872                               else
873                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr);
874                          
875                               if (~empty_i) begin
876                                 if (diff_pntr_pe &lt;= PE_THRESH_ADJ)
877                                   prog_empty_i &lt;= 1'b1;
878                                 else
879                                   prog_empty_i &lt;= 1'b0;
880                               end else
881                                 prog_empty_i   &lt;= prog_empty_i;
882                             end
883                           end
884                         end : gpe_ic
885                       end : gen_pf_ic_rc
886                     
887                       if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_pntr_flags_cc
888                         assign wr_pntr_rd = wr_pntr;
889                         assign rd_pntr_wr = rd_pntr;
890                         assign wr_pntr_rd_dc = wr_pntr_ext;
891                         assign rd_pntr_wr_dc = rd_pntr_ext-extra_words_fwft;
892                         assign write_allow  = ram_wr_en_i &amp; ~ram_full_i;
893                         assign read_allow   = ram_rd_en_i &amp; ~empty_i;
894                     
895                         if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
896                           assign ram_wr_en_pf  = ram_wr_en_i;
897                           assign ram_rd_en_pf  = ram_rd_en_i;
898                       
899                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
900                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
901                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
902                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
903                       
904                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
905                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
906                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
907                           assign leaving_afull  = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_rd_en_i &amp; ~ram_wr_en_i);
908                     
909                           assign write_only    = write_allow &amp; ~read_allow;
910                           assign read_only     = read_allow &amp; ~write_allow;
911                     
912                         end : wrp_eq_rdp
913                       
914                         if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
915                           assign wrp_gt_rdp_and_red = &amp;wr_pntr_rd[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0];
916                       
917                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
918                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red));
919                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
920                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ~ram_rd_en_i);
921                       
922                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
923                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
924                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
925                           assign leaving_afull  = (((rd_pntr_wr_adj == wr_pntr) | (rd_pntr_wr_adj == wr_pntr_plus1) | (rd_pntr_wr_adj == wr_pntr_plus2)) &amp; ram_rd_en_i);
926                       
927                           assign ram_wr_en_pf  = ram_wr_en_i &amp; wrp_gt_rdp_and_red;
928                           assign ram_rd_en_pf  = ram_rd_en_i;
929                     
930                           assign read_only     = read_allow &amp; (~(write_allow  &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0])));
931                           assign write_only    = write_allow &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0]) &amp; ~read_allow;
932                     
933                     
934                         end : wrp_gt_rdp
935                       
936                         if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
937                           assign wrp_lt_rdp_and_red = &amp;rd_pntr_wr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0];
938                       
939                           assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
940                           assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
941                           assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
942                           assign leaving_aempty  = (((wr_pntr_rd_adj == rd_pntr) | (wr_pntr_rd_adj == rd_pntr_plus1) | (wr_pntr_rd_adj == rd_pntr_plus2)) &amp; ram_wr_en_i);
943                       
944                           assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
945                           assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr) &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
946                           assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
947                           assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~ram_wr_en_i &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
948                       
949                           assign ram_wr_en_pf = ram_wr_en_i;
950                           assign ram_rd_en_pf = ram_rd_en_i &amp; wrp_lt_rdp_and_red;
951                     
952                           assign read_only   = read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0]) &amp; ~write_allow;
953                           assign write_only    = write_allow    &amp; (~(read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0])));
954                         end : wrp_lt_rdp
955                       
956                         // Empty flag generation
957                         always @ (posedge rd_clk) begin
958        1/1                if (rd_rst_i) begin
959        1/1                   ram_empty_i  &lt;= 1'b1;
960                           end else begin
961        1/1                   ram_empty_i  &lt;= going_empty | (~leaving_empty &amp; ram_empty_i);
962                           end
963                         end
964                     
965                         if (EN_AE == 1) begin : gae_cc_std
966                           always @ (posedge rd_clk) begin
967                             if (rd_rst_i) begin
968                               ram_aempty_i &lt;= 1'b1;
969                             end else begin
970                               ram_aempty_i &lt;= going_aempty | (~leaving_aempty &amp; ram_aempty_i);
971                             end
972                           end
973                         end : gae_cc_std
974                     
975                         // Full flag generation
976                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
977                           always @ (posedge wr_clk) begin
978                     	if (wrst_busy) begin
979                               ram_full_i   &lt;= FULL_RST_VAL;
980                               ram_full_n   &lt;= ~FULL_RST_VAL;
981                             end else begin
982                     	  if (clr_full) begin
983                                 ram_full_i   &lt;= 1'b0;
984                                 ram_full_n   &lt;= 1'b1;
985                     	  end else begin
986                                 ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
987                                 ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
988                               end
989                             end
990                           end
991                         end : gen_full_rst_val
992                         else begin : ngen_full_rst_val
993                           always @ (posedge wr_clk) begin
994        1/1          	if (wrst_busy) begin
995        1/1                    ram_full_i   &lt;= 1'b0;
996        1/1                    ram_full_n   &lt;= 1'b1;
997                     	end else begin
998        1/1                    ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
999        1/1                    ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
1000                    	end
1001                          end
1002                        end : ngen_full_rst_val
1003                    
1004                        if (EN_AF == 1) begin : gaf_cc
1005                          always @ (posedge wr_clk) begin
1006                    	if (wrst_busy) begin
1007                              ram_afull_i  &lt;= FULL_RST_VAL;
1008                            end else if (~rst) begin
1009                    	  if (clr_full) begin
1010                                ram_afull_i  &lt;= 1'b0;
1011                    	  end else begin
1012                                ram_afull_i  &lt;= going_afull | (~leaving_afull &amp; ram_afull_i);
1013                              end
1014                            end
1015                          end
1016                        end : gaf_cc
1017                        // Programmable Full flag generation
1018                        if ((WR_PNTR_WIDTH == RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_eq_rdp_pf_cc
1019                          if (EN_PF == 1) begin : gpf_cc_sym
1020                    
1021                            assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
1022                            assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
1023                      
1024                            // Delayed write/read enable for PF generation
1025                            always @ (posedge wr_clk) begin
1026       1/1                    if (wrst_busy) begin
1027       1/1                       ram_wr_en_pf_q   &lt;= 1'b0;
1028       1/1                       ram_rd_en_pf_q   &lt;= 1'b0;
1029                              end else begin
1030       1/1                       ram_wr_en_pf_q   &lt;= ram_wr_en_pf;
1031       1/1                       ram_rd_en_pf_q   &lt;= ram_rd_en_pf;
1032                              end
1033                            end
1034                      
1035                            // PF carry generation
1036                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i &amp; ~ram_rd_en_pf;
1037                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i &amp; ~ram_rd_en_pf;
1038                      
1039                            // PF diff pointer generation
1040                            always @ (posedge wr_clk) begin
1041       1/1                    if (wrst_busy)
1042       1/1                       diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1043                              else
1044       1/1                       diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
1045                            end
1046                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1047                      
1048                            always @ (posedge wr_clk) begin
1049       1/1                    if (wrst_busy)
1050       1/1                       prog_full_i  &lt;= FULL_RST_VAL;
1051       1/1                    else if (clr_full)
1052       1/1                       prog_full_i  &lt;= 1'b0;
1053       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ram_wr_en_pf_q &amp; ~ram_rd_en_pf_q)
1054       1/1                       prog_full_i  &lt;= 1'b1;
1055       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ~ram_wr_en_pf_q &amp; ram_rd_en_pf_q)
1056       <font color = "red">0/1     ==>               prog_full_i  &lt;= 1'b0;</font>
1057                              else
1058       1/1                       prog_full_i  &lt;= prog_full_i;
1059                            end
1060                          end : gpf_cc_sym
1061                    
1062                          if (EN_PE == 1) begin : gpe_cc_sym
1063                            always @(posedge rd_clk) begin
1064       1/1                    if (rd_rst_i) begin
1065       1/1                      read_only_q    &lt;= 1'b0;
1066       1/1                      write_only_q   &lt;= 1'b0;
1067       1/1                      diff_pntr_pe   &lt;= 0;
1068                              end 
1069                              else begin
1070       1/1                      read_only_q  &lt;= read_only;
1071       1/1                      write_only_q &lt;= write_only;
1072                                // Add 1 to the difference pointer value when write or both write &amp; read or no write &amp; read happen.
1073       1/1                      if (read_only)
1074       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr - 1;
1075                                else
1076       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr;
1077                              end
1078                            end
1079                      
1080                            always @(posedge rd_clk) begin
1081       1/1                    if (rd_rst_i)
1082       1/1                      prog_empty_i  &lt;= 1'b1;
1083                              else begin
1084       1/1                      if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; read_only_q)
1085       <font color = "red">0/1     ==>                prog_empty_i &lt;= 1'b1;</font>
1086       1/1                      else if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; write_only_q)
1087       1/1                        prog_empty_i &lt;= 1'b0;
1088                                else
1089       1/1                        prog_empty_i &lt;= prog_empty_i;
1090                              end
1091                            end
1092                          end : gpe_cc_sym
1093                        end : wrp_eq_rdp_pf_cc
1094                    
1095                        if ((WR_PNTR_WIDTH != RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_neq_rdp_pf_cc
1096                          if (EN_PF == 1) begin : gpf_cc_asym
1097                            // PF diff pointer generation
1098                            always @ (posedge wr_clk) begin
1099                              if (wrst_busy)
1100                                 diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1101                              else if (~ram_full_i)
1102                                 diff_pntr_pf_q[WR_PNTR_WIDTH:1]  &lt;= wr_pntr + ~rd_pntr_wr_adj + 1;
1103                            end
1104                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1105                            always @ (posedge wr_clk) begin
1106                              if (wrst_busy)
1107                                 prog_full_i  &lt;= FULL_RST_VAL;
1108                              else if (clr_full)
1109                                 prog_full_i  &lt;= 1'b0;
1110                              else if (~ram_full_i) begin
1111                                if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
1112                                   prog_full_i  &lt;= 1'b1;
1113                                else if (diff_pntr_pf &lt; PF_THRESH_ADJ)
1114                                   prog_full_i  &lt;= 1'b0;
1115                                else
1116                                   prog_full_i  &lt;= prog_full_i;
1117                              end
1118                            end
1119                          end : gpf_cc_asym
1120                          if (EN_PE == 1) begin : gpe_cc_asym
1121                            // Programmanble Empty flag Generation
1122                            // Diff pointer Generation
1123                            localparam [RD_PNTR_WIDTH-1 : 0] DIFF_MAX_RD = {RD_PNTR_WIDTH{1'b1}};
1124                            wire [RD_PNTR_WIDTH-1:0] diff_pntr_pe_max;
1125                            wire                     carry;
1126                            reg  [RD_PNTR_WIDTH : 0] diff_pntr_pe_asym = 'b0;
1127                            wire [RD_PNTR_WIDTH : 0] wr_pntr_rd_adj_asym;
1128                            wire [RD_PNTR_WIDTH : 0] rd_pntr_asym;
1129                            reg                      full_reg;
1130                            reg                      rst_full_ff_reg1;
1131                            reg                      rst_full_ff_reg2;
1132                      
1133                            assign diff_pntr_pe_max = DIFF_MAX_RD;
1134                            assign wr_pntr_rd_adj_asym[RD_PNTR_WIDTH:0] = {wr_pntr_rd_adj,1'b1};
1135                            assign rd_pntr_asym[RD_PNTR_WIDTH:0] = {~rd_pntr,1'b1};
1136                      
1137                            always @(posedge rd_clk ) begin
1138                              if (rd_rst_i) begin
1139                                diff_pntr_pe_asym    &lt;= 0;
1140                                full_reg             &lt;= 0;
1141                                rst_full_ff_reg1     &lt;= 1;
1142                                rst_full_ff_reg2     &lt;= 1;
1143                                diff_pntr_pe_reg1    &lt;= 0;
1144                              end else begin
1145                                diff_pntr_pe_asym &lt;= wr_pntr_rd_adj_asym + rd_pntr_asym;
1146                                full_reg          &lt;= ram_full_i;
1147                                rst_full_ff_reg1  &lt;= FULL_RST_VAL;
1148                                rst_full_ff_reg2  &lt;= rst_full_ff_reg1;
1149                              end
1150                            end
1151                            wire [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_i;
1152                            assign carry = (~(|(diff_pntr_pe_asym [RD_PNTR_WIDTH : 1])));
1153                            assign diff_pntr_pe_i = (full_reg &amp;&amp; ~rst_d2 &amp;&amp; carry ) ? diff_pntr_pe_max : diff_pntr_pe_asym[RD_PNTR_WIDTH:1];
1154                        
1155                            always @(posedge rd_clk) begin
1156                              if (rd_rst_i)
1157                                prog_empty_i  &lt;= 1'b1;
1158                              else begin
1159                                if (diff_pntr_pe_i &lt;= PE_THRESH_ADJ)
1160                                  prog_empty_i &lt;= 1'b1;
1161                                else if (diff_pntr_pe_i &gt; PE_THRESH_ADJ)
1162                                  prog_empty_i &lt;= 1'b0;
1163                                else
1164                                  prog_empty_i &lt;= prog_empty_i;
1165                              end
1166                            end
1167                          end : gpe_cc_asym
1168                        end : wrp_neq_rdp_pf_cc
1169                    
1170                      end : gen_pntr_flags_cc
1171                    
1172                      if (READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1) begin : gen_regce_std
1173                        xpm_reg_pipe_bit #(FIFO_READ_LATENCY-1, 0)
1174                          regce_pipe_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_regce_pipe);
1175                      end : gen_regce_std
1176                      if (!(READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1)) begin : gnen_regce_std
1177                        assign ram_regce_pipe = 1'b0;
1178                      end : gnen_regce_std
1179                    
1180                      if (!((READ_MODE == 1 || READ_MODE == 2)&amp;&amp; FIFO_MEMORY_TYPE != 4)) begin : gn_fwft
1181                       assign invalid_state = 1'b0;
1182                      end : gn_fwft
1183                      //if (READ_MODE == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1184                      if (READ_MODE != 0 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1185                      // First word fall through logic
1186                    
1187                       //localparam invalid             = 0;
1188                       //localparam stage1_valid        = 2;
1189                       //localparam stage2_valid        = 1;
1190                       //localparam both_stages_valid   = 3;
1191                    
1192                       //reg  [1:0] curr_fwft_state = invalid;
1193                       //reg  [1:0] next_fwft_state;// = invalid;
1194                       wire next_fwft_state_d1;
1195                       assign invalid_state = ~|curr_fwft_state;
1196                       assign valid_fwft = next_fwft_state_d1;
1197                       assign ram_valid_fwft = curr_fwft_state[1];
1198                    
1199                        xpm_fifo_reg_bit #(0)
1200                          next_state_d1_inst (1'b0, rd_clk, next_fwft_state[0], next_fwft_state_d1);
1201                       //FSM : To generate the enable, clock enable for xpm_memory and to generate
1202                       //empty signal
1203                       //FSM : Next state Assignment
1204                         if (READ_MODE == 1) begin : gen_fwft_ns
1205                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1206                           case (curr_fwft_state)
1207                             invalid: begin
1208                               if (~ram_empty_i)
1209                                  next_fwft_state     = stage1_valid;
1210                               else
1211                                  next_fwft_state     = invalid;
1212                               end
1213                             stage1_valid: begin
1214                               if (ram_empty_i)
1215                                  next_fwft_state     = stage2_valid;
1216                               else
1217                                  next_fwft_state     = both_stages_valid;
1218                               end
1219                             stage2_valid: begin
1220                               if (ram_empty_i &amp;&amp; rd_en)
1221                                  next_fwft_state     = invalid;
1222                               else if (~ram_empty_i &amp;&amp; rd_en)
1223                                  next_fwft_state     = stage1_valid;
1224                               else if (~ram_empty_i &amp;&amp; ~rd_en)
1225                                  next_fwft_state     = both_stages_valid;
1226                               else
1227                                  next_fwft_state     = stage2_valid;
1228                               end
1229                             both_stages_valid: begin
1230                               if (ram_empty_i &amp;&amp; rd_en)
1231                                  next_fwft_state     = stage2_valid;
1232                               else if (~ram_empty_i &amp;&amp; rd_en)
1233                                  next_fwft_state     = both_stages_valid;
1234                               else
1235                                  next_fwft_state     = both_stages_valid;
1236                               end
1237                             default: next_fwft_state    = invalid;
1238                           endcase
1239                         end
1240                         end : gen_fwft_ns
1241                         if (READ_MODE == 2) begin : gen_fwft_ns_ll
1242                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1243                           case (curr_fwft_state)
1244                             invalid: begin
1245                               if (~ram_empty_i)
1246                                  next_fwft_state     = stage1_valid;
1247                               else
1248                                  next_fwft_state     = invalid;
1249                               end
1250                             stage1_valid: begin
1251                               if (ram_empty_i &amp;&amp; rd_en)
1252                                  next_fwft_state     = invalid;
1253                               else
1254                                  next_fwft_state     = stage1_valid;
1255                               end
1256                             default: next_fwft_state    = invalid;
1257                           endcase
1258                         end
1259                         end : gen_fwft_ns_ll
1260                         // FSM : current state assignment
1261                         always @ (posedge rd_clk) begin
1262                           if (rd_rst_i)
1263                              curr_fwft_state  &lt;= invalid;
1264                           else
1265                              curr_fwft_state  &lt;= next_fwft_state;
1266                         end
1267                     
1268                         reg ram_regout_en;
1269                    
1270                         // FSM(output assignments) : clock enable generation for xpm_memory
1271                         if (READ_MODE == 1) begin : gen_fwft_ro
1272                         always @(curr_fwft_state or rd_en) begin
1273                           case (curr_fwft_state)
1274                             invalid:           ram_regout_en = 1'b0;
1275                             stage1_valid:      ram_regout_en = 1'b1;
1276                             stage2_valid:      ram_regout_en = 1'b0;
1277                             both_stages_valid: ram_regout_en = rd_en;
1278                             default:           ram_regout_en = 1'b0;
1279                           endcase
1280                         end
1281                         end : gen_fwft_ro
1282                         if (READ_MODE == 2) begin : gen_fwft_ro_ll
1283                         always @(curr_fwft_state or rd_en or ram_empty_i or fe_of_empty) begin
1284                           case (curr_fwft_state)
1285                             invalid:           ram_regout_en = fe_of_empty;
1286                             stage1_valid:      ram_regout_en = rd_en &amp; !ram_empty_i;
1287                             default:           ram_regout_en = 1'b0;
1288                           endcase
1289                         end
1290                         end : gen_fwft_ro_ll
1291                    
1292                         // FSM(output assignments) : rd_en (enable) signal generation for xpm_memory
1293                         if (READ_MODE == 1) begin : gen_fwft_re
1294                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1295                           case (curr_fwft_state)
1296                             invalid :
1297                               if (~ram_empty_i)
1298                                 rd_en_fwft = 1'b1;
1299                               else
1300                                 rd_en_fwft = 1'b0;
1301                             stage1_valid :
1302                               if (~ram_empty_i)
1303                                 rd_en_fwft = 1'b1;
1304                               else
1305                                 rd_en_fwft = 1'b0;
1306                             stage2_valid :
1307                               if (~ram_empty_i)
1308                                 rd_en_fwft = 1'b1;
1309                               else
1310                                 rd_en_fwft = 1'b0;
1311                             both_stages_valid :
1312                               if (~ram_empty_i &amp;&amp; rd_en)
1313                                 rd_en_fwft = 1'b1;
1314                               else
1315                                 rd_en_fwft = 1'b0;
1316                             default :
1317                               rd_en_fwft = 1'b0;
1318                           endcase
1319                         end
1320                         end : gen_fwft_re
1321                         if (READ_MODE == 2) begin : gen_fwft_re_ll
1322                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1323                           case (curr_fwft_state)
1324                             invalid :
1325                               if (~ram_empty_i)
1326                                 rd_en_fwft = 1'b1;
1327                               else
1328                                 rd_en_fwft = 1'b0;
1329                             stage1_valid :
1330                               if (~ram_empty_i &amp;&amp; rd_en)
1331                                 rd_en_fwft = 1'b1;
1332                               else
1333                                 rd_en_fwft = 1'b0;
1334                             default :
1335                               rd_en_fwft = 1'b0;
1336                           endcase
1337                         end
1338                         end : gen_fwft_re_ll
1339                         // assingment to control regce xpm_memory
1340                         assign ram_regce = ram_regout_en;
1341                    
1342                         reg going_empty_fwft;
1343                         reg leaving_empty_fwft;
1344                    
1345                         if (READ_MODE == 1) begin : gen_fwft_ge
1346                         always @(curr_fwft_state or rd_en) begin
1347                           case (curr_fwft_state)
1348                             stage2_valid : going_empty_fwft = rd_en;
1349                             default      : going_empty_fwft = 1'b0;
1350                           endcase
1351                         end
1352                    
1353                         always @(curr_fwft_state or rd_en) begin
1354                           case (curr_fwft_state)
1355                             stage1_valid : leaving_empty_fwft = 1'b1;
1356                             default      : leaving_empty_fwft = 1'b0;
1357                           endcase
1358                         end
1359                         end : gen_fwft_ge
1360                         if (READ_MODE == 2) begin : gen_fwft_ge_ll
1361                         always @(curr_fwft_state or rd_en or ram_empty_i) begin
1362                           case (curr_fwft_state)
1363                             stage1_valid : going_empty_fwft = rd_en &amp; ram_empty_i;
1364                             default      : going_empty_fwft = 1'b0;
1365                           endcase
1366                         end
1367                    
1368                         always @ (posedge rd_clk) begin
1369                           if (rd_rst_i) begin
1370                              ram_empty_i_d1  &lt;= 1'b1;
1371                           end else begin
1372                              ram_empty_i_d1  &lt;= ram_empty_i;
1373                           end
1374                         end
1375                         assign fe_of_empty = ram_empty_i_d1 &amp; !ram_empty_i;
1376                    
1377                         always @(curr_fwft_state or fe_of_empty) begin
1378                           case (curr_fwft_state)
1379                             invalid      : leaving_empty_fwft = fe_of_empty;
1380                             stage1_valid : leaving_empty_fwft = 1'b1;
1381                             default      : leaving_empty_fwft = 1'b0;
1382                           endcase
1383                         end
1384                         end : gen_fwft_ge_ll
1385                    
1386                         // fwft empty signal generation 
1387                         always @ (posedge rd_clk) begin
1388                           if (rd_rst_i) begin
1389                             empty_fwft_i     &lt;= 1'b1;
1390                             empty_fwft_fb    &lt;= 1'b1;
1391                           end else begin
1392                             empty_fwft_i     &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1393                             empty_fwft_fb    &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1394                           end
1395                         end
1396                    
1397                         if (EN_AE == 1) begin : gae_fwft
1398                           reg going_aempty_fwft;
1399                           reg leaving_aempty_fwft;
1400                    
1401                           if (READ_MODE == 1) begin : gen_fwft_ae
1402                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1403                               case (curr_fwft_state)
1404                                 both_stages_valid : going_aempty_fwft = rd_en &amp; ram_empty_i;
1405                                 default      : going_aempty_fwft = 1'b0;
1406                               endcase
1407                             end
1408                           end : gen_fwft_ae
1409                           if (READ_MODE == 2) begin : gen_fwft_ae_ll
1410                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1411                               case (curr_fwft_state)
1412                                 stage1_valid : going_aempty_fwft = !rd_en &amp; ram_empty_i;
1413                                 default      : going_aempty_fwft = 1'b0;
1414                               endcase
1415                             end
1416                           end : gen_fwft_ae_ll
1417                    
1418                           always @(curr_fwft_state or rd_en or ram_empty_i) begin
1419                             case (curr_fwft_state)
1420                               stage1_valid : leaving_aempty_fwft = ~ram_empty_i;
1421                               stage2_valid : leaving_aempty_fwft = ~(rd_en | ram_empty_i);
1422                               default      : leaving_aempty_fwft = 1'b0;
1423                             endcase
1424                           end
1425                    
1426                           always @ (posedge rd_clk) begin
1427                             if (rd_rst_i) begin
1428                               aempty_fwft_i    &lt;= 1'b1;
1429                             end else begin
1430                               aempty_fwft_i    &lt;= going_aempty_fwft | (~ leaving_aempty_fwft &amp; aempty_fwft_i);
1431                             end
1432                           end
1433                         end : gae_fwft
1434                    
1435                         if (EN_DVLD == 1) begin : gdvld_fwft
1436                           always @ (posedge rd_clk) begin
1437                             if (rd_rst_i) begin
1438                               data_valid_fwft  &lt;= 1'b0;
1439                             end else begin
1440                               data_valid_fwft  &lt;= ~(going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb));
1441                             end
1442                           end
1443                         end : gdvld_fwft
1444                    
1445                        xpm_fifo_reg_bit #(0)
1446                          empty_fwft_d1_inst (1'b0, rd_clk, leaving_empty_fwft, empty_fwft_d1);
1447                    
1448                        wire ge_fwft_d1;
1449                        xpm_fifo_reg_bit #(0)
1450                          ge_fwft_d1_inst (1'b0, rd_clk, going_empty_fwft, ge_fwft_d1);
1451                    
1452                        wire count_up  ;
1453                        wire count_down;
1454                        wire count_en  ;
1455                        wire count_rst ;
1456                        assign count_up   = (next_fwft_state == 2'b10 &amp;&amp; ~|curr_fwft_state) | (curr_fwft_state == 2'b10 &amp;&amp; &amp;next_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; &amp;next_fwft_state);
1457                        assign count_down = (next_fwft_state == 2'b01 &amp;&amp; &amp;curr_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; ~|next_fwft_state);
1458                        assign count_en   = count_up | count_down;
1459                        assign count_rst  = (rd_rst_i | (~|curr_fwft_state &amp; ~|next_fwft_state));
1460                    
1461                        xpm_counter_updn # (2, 0)
1462                          rdpp1_inst (count_rst, rd_clk, count_en, count_up, count_down, extra_words_fwft);
1463                    
1464                     
1465                      end : gen_fwft
1466                    
1467                      if (READ_MODE == 0) begin : ngen_fwft
1468                        assign le_fwft_re       = 1'b0;
1469                        assign le_fwft_fe       = 1'b0;
1470                        assign extra_words_fwft = 2'h0;
1471                      end : ngen_fwft
1472                    
1473                      // output data bus assignment
1474                      if (FG_EQ_ASYM_DOUT == 0) begin : nfg_eq_asym_dout
1475                        assign dout  = dout_i;
1476                      end : nfg_eq_asym_dout
1477                    
1478                      // Overflow and Underflow flag generation
1479                      if (EN_UF == 1) begin : guf
1480                        always @ (posedge rd_clk) begin
1481       1/1                underflow_i &lt;=  (rd_rst_i | empty_i) &amp; rd_en;
1482                        end
1483                        assign underflow   = underflow_i;
1484                      end : guf
1485                      if (EN_UF == 0) begin : gnuf
1486                        assign underflow   = 1'b0;
1487                      end : gnuf
1488                    
1489                      if (EN_OF == 1) begin : gof
1490                        always @ (posedge wr_clk) begin
1491       1/1               overflow_i  &lt;=  (wrst_busy | rst_d1 | ram_full_i) &amp; wr_en;
1492                        end
1493                        assign overflow    = overflow_i;
1494                      end : gof
1495                      if (EN_OF == 0) begin : gnof
1496                        assign overflow    = 1'b0;
1497                      end : gnof
1498                    
1499                      // -------------------------------------------------------------------------------------------------------------------
1500                      // Write Data Count for Independent Clocks FIFO
1501                      // -------------------------------------------------------------------------------------------------------------------
1502                      if (EN_WDC == 1) begin : gwdc
1503                        reg  [WR_DC_WIDTH_EXT-1:0] wr_data_count_i;
1504                        wire [WR_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr;
1505                        assign diff_wr_rd_pntr = wr_pntr_ext-rd_pntr_wr_adj_dc;
1506                        always @ (posedge wr_clk) begin
1507       1/1                if (wrst_busy)
1508       1/1                   wr_data_count_i   &lt;= {WR_DC_WIDTH_EXT{1'b0}};
1509                          else
1510       1/1                   wr_data_count_i  &lt;= diff_wr_rd_pntr;
1511                        end
1512                        assign wr_data_count = wr_data_count_i[WR_DC_WIDTH_EXT-1:WR_DC_WIDTH_EXT-WR_DATA_COUNT_WIDTH];
1513                      end : gwdc
1514                      if (EN_WDC == 0) begin : gnwdc
1515                        assign wr_data_count = {WR_DC_WIDTH_EXT{1'b0}};
1516                      end : gnwdc
1517                    
1518                      // -------------------------------------------------------------------------------------------------------------------
1519                      // Read Data Count for Independent Clocks FIFO
1520                      // -------------------------------------------------------------------------------------------------------------------
1521                      if (EN_RDC == 1) begin : grdc
1522                        reg  [RD_DC_WIDTH_EXT-1:0] rd_data_count_i;
1523                        wire [RD_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr_rdc;
1524                        assign diff_wr_rd_pntr_rdc = wr_pntr_rd_adj_dc-rd_pntr_ext+extra_words_fwft;
1525                        always @ (posedge rd_clk) begin
1526       1/1                if (rd_rst_i | invalid_state)
1527       1/1                   rd_data_count_i   &lt;= {RD_DC_WIDTH_EXT{1'b0}};
1528                          else
1529       1/1                   rd_data_count_i  &lt;= diff_wr_rd_pntr_rdc;
1530                        end
1531                        assign rd_data_count = rd_data_count_i[RD_DC_WIDTH_EXT-1:RD_DC_WIDTH_EXT-RD_DATA_COUNT_WIDTH];
1532                      end : grdc
1533                      if (EN_RDC == 0) begin : gnrdc
1534                        assign rd_data_count = {RD_DC_WIDTH_EXT{1'b0}};
1535                      end : gnrdc
1536                    
1537                      endgenerate
1538                    
1539                      // -------------------------------------------------------------------------------------------------------------------
1540                      // Simulation constructs
1541                      // -------------------------------------------------------------------------------------------------------------------
1542                      // synthesis translate_off
1543                    
1544                     `ifndef DISABLE_XPM_ASSERTIONS  
1545                      initial begin
1546       2/2            #1;
1547       1/1              if (SIM_ASSERT_CHK == 1)
1548                        `ifdef OBSOLETE
1549                          $warning(&quot;Vivado Simulator does not currently support the SystemVerilog Assertion syntax used within XPM_FIFO.  \
1550                    Messages related to potential misuse will not be reported.&quot;);
1551                        `else
1552       <font color = "red">0/1     ==>        $warning(&quot;SIM_ASSERT_CHK (%0d) specifies simulation message reporting, messages related to potential misuse \</font>
                        MISSING_ELSE
</pre>
<hr>
<a name="inst_tag_273_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod18.html#inst_tag_273" >AdaptedSharpener.fifo.lineBuffer_2.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">Conditions</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="s6"><td class="lf">Logical</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1084
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; read_only_q)
             ---------------1---------------    -----2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1086
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; write_only_q)
             ---------------1---------------    ------2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_273_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod18.html#inst_tag_273" >AdaptedSharpener.fifo.lineBuffer_2.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s3">
<td>Totals</td>
<td class="rt">129</td>
<td class="rt">50</td>
<td class="rt">38.76 </td>
</tr><tr class="s7">
<td>Total Bits</td>
<td class="rt">864</td>
<td class="rt">607</td>
<td class="rt">70.25 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 0->1</td>
<td class="rt">432</td>
<td class="rt">304</td>
<td class="rt">70.37 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 1->0</td>
<td class="rt">432</td>
<td class="rt">303</td>
<td class="rt">70.14 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s2">
<td>Ports</td>
<td class="rt">27</td>
<td class="rt">8</td>
<td class="rt">29.63 </td>
</tr><tr class="s8">
<td>Port Bits</td>
<td class="rt">178</td>
<td class="rt">145</td>
<td class="rt">81.46 </td>
</tr><tr class="s7">
<td nowrap>Port Bits 0->1</td>
<td class="rt">89</td>
<td class="rt">71</td>
<td class="rt">79.78 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 1->0</td>
<td class="rt">89</td>
<td class="rt">74</td>
<td class="rt">83.15 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s4">
<td>Signals</td>
<td class="rt">102</td>
<td class="rt">42</td>
<td class="rt">41.18 </td>
</tr><tr class="s6">
<td>Signal Bits</td>
<td class="rt">686</td>
<td class="rt">462</td>
<td class="rt">67.35 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">343</td>
<td class="rt">233</td>
<td class="rt">67.93 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">343</td>
<td class="rt">229</td>
<td class="rt">66.76 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>sleep</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>rst</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>wr_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>wr_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>din[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_data_count</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_ack</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rd_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>dout[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>empty</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_empty</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_data_count</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>data_valid</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>injectsbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>injectdbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>dbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>curr_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>next_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus2[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus3[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_plus1_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_inv_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pf_q[6:1]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>invalid_state</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>going_aempty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_aempty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_aempty_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>prog_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_afull_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_ack_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_en_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce_pipe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dout_i[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>aempty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_fwft_fb</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>overflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>underflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_vld_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_gt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_lt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_wr_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe_reg1[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe_reg2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>prog_empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_empty_i_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>fe_of_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_en_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_d2</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rst_d1</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rst_d2</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>clr_full</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extra_words_fwft[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gen_sdpram.rst_int</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.rd_data_count_i[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.rd_data_count_i[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.rd_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
</div>
<div name='inst_tag_272'>
<a name="inst_tag_272_Line"></a>
<b>Line Coverage for Instance : <a href="mod18.html#inst_tag_272" >AdaptedSharpener.fifo.lineBuffer_1.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="4" width="82">
<tr><th></th><th>Line No.</th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">TOTAL</td><td></td><td>142</td><td>86</td><td>60.56</td></tr>
<tr class="s10"><td class="lf">ROUTINE</td><td>126</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">ROUTINE</td><td>304</td><td>5</td><td>4</td><td>80.00</td></tr>
<tr class="s3"><td class="lf">INITIAL</td><td>314</td><td>81</td><td>29</td><td>35.80</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>958</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>994</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1026</td><td>5</td><td>5</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1041</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1049</td><td>9</td><td>8</td><td>88.89</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1064</td><td>9</td><td>9</td><td>100.00</td></tr>
<tr class="s8"><td class="lf">ALWAYS</td><td>1081</td><td>7</td><td>6</td><td>85.71</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1481</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1491</td><td>1</td><td>1</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1507</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s10"><td class="lf">ALWAYS</td><td>1526</td><td>3</td><td>3</td><td>100.00</td></tr>
<tr class="s7"><td class="lf">INITIAL</td><td>1546</td><td>4</td><td>3</td><td>75.00</td></tr>
</table>
<pre class="code"><br clear=all>
125                       begin 
126        1/1              value = value-1;
127        1/1              for (clog2=0; value&gt;0; clog2=clog2+1)
128        1/1                value = value&gt;&gt;1;
129                         end 
130                       endfunction
131                       // Function to convert ASCII value to binary 
132                       function [3:0] str2bin;
133                         input [7:0] str_val_ascii;
134                           if((str_val_ascii == 8'h30) || (str_val_ascii == 8'h31) || 
135                              (str_val_ascii == 8'h32) || (str_val_ascii == 8'h33) || 
136                              (str_val_ascii == 8'h34) || (str_val_ascii == 8'h35) || 
137                              (str_val_ascii == 8'h36) || (str_val_ascii == 8'h37) || 
138                              (str_val_ascii == 8'h38) || (str_val_ascii == 8'h39) || 
139                              (str_val_ascii == 8'h41) || (str_val_ascii == 8'h42) || 
140                              (str_val_ascii == 8'h43) || (str_val_ascii == 8'h44) || 
141                              (str_val_ascii == 8'h45) || (str_val_ascii == 8'h46) || 
142                              (str_val_ascii == 8'h61) || (str_val_ascii == 8'h62) || 
143                              (str_val_ascii == 8'h63) || (str_val_ascii == 8'h64) || 
144                              (str_val_ascii == 8'h65) || (str_val_ascii == 8'h66) || 
145                              (str_val_ascii == 8'h00)) begin
146                              if (!str_val_ascii[6])
147                                 str2bin = str_val_ascii[3:0];
148                              else begin
149                                str2bin [3] = 1'b1;
150                                str2bin [2] = str_val_ascii[2] | (str_val_ascii[1] &amp; str_val_ascii[0]);
151                                str2bin [1] = str_val_ascii[0] ^ str_val_ascii[1];
152                                str2bin [0] = !str_val_ascii[0];
153                              end
154                           end
155                           else
156                             $error(&quot;Found Invalid character while parsing the string, please cross check the value specified for either READ_RESET_VALUE_A|B or MEMORY_INIT_PARAM (if initialization of memory through parameter is used). XPM_MEMORY supports strings (hex) that contains characters 0-9, A-F and a-f.&quot;);
157                       endfunction
158                       // Function that parses the complete reset value string
159                       function logic [15:0] hstr2bin;
160                         input [16*8-1 : 0] hstr_val;
161                         integer rst_loop_a;
162                         localparam integer  rsta_loop_iter  =  16;
163                         logic [rsta_loop_iter-1 : 0] rst_val_conv_a_i;
164                         for (rst_loop_a=1; rst_loop_a &lt;= rsta_loop_iter/4; rst_loop_a = rst_loop_a+1) begin
165                           rst_val_conv_a_i[(rst_loop_a*4)-1 -: 4] =  str2bin(hstr_val[(rst_loop_a*8)-1 -: 8]);
166                         end
167                         return rst_val_conv_a_i[15:0];
168                       endfunction
169                     
170                     
171                       localparam invalid             = 0;
172                       localparam stage1_valid        = 2;
173                       localparam stage2_valid        = 1;
174                       localparam both_stages_valid   = 3;
175                     
176                       reg  [1:0] curr_fwft_state = invalid;
177                       reg  [1:0] next_fwft_state;// = invalid;
178                     
179                     
180                     
181                       localparam FIFO_MEM_TYPE   = FIFO_MEMORY_TYPE;
182                       localparam RD_MODE         = READ_MODE;
183                       localparam ENABLE_ECC      = (ECC_MODE == 1) ? 3 : 0;
184                       localparam FIFO_READ_DEPTH = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH/READ_DATA_WIDTH;
185                       localparam FIFO_SIZE       = FIFO_WRITE_DEPTH*WRITE_DATA_WIDTH;
186                       localparam WR_WIDTH_LOG    = clog2(WRITE_DATA_WIDTH);
187                       localparam WR_DEPTH_LOG    = clog2(FIFO_WRITE_DEPTH);
188                       localparam WR_PNTR_WIDTH   = clog2(FIFO_WRITE_DEPTH);
189                       localparam RD_PNTR_WIDTH   = clog2(FIFO_READ_DEPTH);
190                       localparam FULL_RST_VAL    = FULL_RESET_VALUE == 0 ? 1'b0 : 1'b1;
191                       localparam WR_RD_RATIO     = (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) ? (WR_PNTR_WIDTH-RD_PNTR_WIDTH) : 0;
192                       localparam READ_MODE_LL    = (READ_MODE == 0) ? 0 : 1;
193                       localparam PF_THRESH_ADJ   = (READ_MODE == 0) ? PROG_FULL_THRESH :
194                                                    PROG_FULL_THRESH - (2*(2**WR_RD_RATIO));
195                       localparam PE_THRESH_ADJ   = (READ_MODE_LL == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) ? PROG_EMPTY_THRESH - 2'h2 : PROG_EMPTY_THRESH;
196                     
197                       localparam PF_THRESH_MIN   = 3+(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1))+(COMMON_CLOCK?0:CDC_DEST_SYNC_FF);
198                       localparam PF_THRESH_MAX   = (FIFO_WRITE_DEPTH-3)-(READ_MODE_LL*2*(((FIFO_WRITE_DEPTH-1)/FIFO_READ_DEPTH)+1));
199                       localparam PE_THRESH_MIN   = 3+(READ_MODE_LL*2);
200                       localparam PE_THRESH_MAX   = (FIFO_READ_DEPTH-3)-(READ_MODE_LL*2);
201                       localparam WR_DC_WIDTH_EXT = clog2(FIFO_WRITE_DEPTH)+1;
202                       localparam RD_DC_WIDTH_EXT = clog2(FIFO_READ_DEPTH)+1;
203                       localparam RD_LATENCY      = (READ_MODE == 2) ? 1 : (READ_MODE == 1) ? 2 : FIFO_READ_LATENCY;
204                       localparam WIDTH_RATIO     = (READ_DATA_WIDTH &gt; WRITE_DATA_WIDTH) ? (READ_DATA_WIDTH/WRITE_DATA_WIDTH) : (WRITE_DATA_WIDTH/READ_DATA_WIDTH);
205                     
206                       localparam [15:0] EN_ADV_FEATURE = hstr2bin(USE_ADV_FEATURES);
207                     
208                       localparam EN_OF           = EN_ADV_FEATURE[0];  //EN_ADV_FLAGS_WR[0] ? 1 : 0;
209                       localparam EN_PF           = EN_ADV_FEATURE[1];  //EN_ADV_FLAGS_WR[1] ? 1 : 0;
210                       localparam EN_WDC          = EN_ADV_FEATURE[2];  //EN_ADV_FLAGS_WR[2] ? 1 : 0;
211                       localparam EN_AF           = EN_ADV_FEATURE[3];  //EN_ADV_FLAGS_WR[3] ? 1 : 0;
212                       localparam EN_WACK         = EN_ADV_FEATURE[4];  //EN_ADV_FLAGS_WR[4] ? 1 : 0;
213                       localparam FG_EQ_ASYM_DOUT = EN_ADV_FEATURE[5];  //EN_ADV_FLAGS_WR[5] ? 1 : 0;
214                       localparam EN_UF           = EN_ADV_FEATURE[8];  //EN_ADV_FLAGS_RD[0] ? 1 : 0;
215                       localparam EN_PE           = EN_ADV_FEATURE[9];  //EN_ADV_FLAGS_RD[1] ? 1 : 0;
216                       localparam EN_RDC          = EN_ADV_FEATURE[10]; //EN_ADV_FLAGS_RD[2] ? 1 : 0;
217                       localparam EN_AE           = EN_ADV_FEATURE[11]; //EN_ADV_FLAGS_RD[3] ? 1 : 0;
218                       localparam EN_DVLD         = EN_ADV_FEATURE[12]; //EN_ADV_FLAGS_RD[4] ? 1 : 0;
219                     
220                       wire                       wrst_busy;
221                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr;
222                       wire [WR_PNTR_WIDTH:0]     wr_pntr_ext;
223                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd_cdc;
224                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_cdc_dc;
225                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_rd;
226                       wire [WR_PNTR_WIDTH:0]     wr_pntr_rd_dc;
227                       wire [WR_PNTR_WIDTH-1:0]   rd_pntr_wr_adj;
228                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_dc;
229                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus1;
230                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus2;
231                       wire [WR_PNTR_WIDTH-1:0]   wr_pntr_plus3;
232                       wire [WR_PNTR_WIDTH:0]     wr_pntr_plus1_pf;
233                       wire [WR_PNTR_WIDTH:0]     rd_pntr_wr_adj_inv_pf;
234                       reg  [WR_PNTR_WIDTH:0]     diff_pntr_pf_q = {WR_PNTR_WIDTH{1'b0}};
235                       wire [WR_PNTR_WIDTH-1:0]   diff_pntr_pf;
236                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr;
237                       wire [RD_PNTR_WIDTH:0]     rd_pntr_ext;
238                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr_cdc;
239                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_wr;
240                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_cdc_dc;
241                       wire [RD_PNTR_WIDTH:0]     rd_pntr_wr_dc;
242                       wire [RD_PNTR_WIDTH-1:0]   wr_pntr_rd_adj;
243                       wire [RD_PNTR_WIDTH:0]     wr_pntr_rd_adj_dc;
244                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus1;
245                       wire [RD_PNTR_WIDTH-1:0]   rd_pntr_plus2;
246                       wire                       invalid_state;
247                       wire                       valid_fwft;
248                       wire                       ram_valid_fwft;
249                       wire                       going_empty;
250                       wire                       leaving_empty;
251                       wire                       going_aempty;
252                       wire                       leaving_aempty;
253                       reg                        ram_empty_i  = 1'b1;
254                       reg                        ram_aempty_i = 1'b1;
255                       wire                       empty_i;
256                       wire                       going_full;
257                       wire                       leaving_full;
258                       wire                       going_afull;
259                       wire                       leaving_afull;
260                       reg                        prog_full_i = FULL_RST_VAL;
261                       reg                        ram_full_i  = FULL_RST_VAL;
262                       reg                        ram_afull_i = FULL_RST_VAL;
263                       reg                        ram_full_n  = ~FULL_RST_VAL;
264                       wire                       ram_wr_en_i;
265                       wire                       ram_rd_en_i;
266                       reg                        wr_ack_i = 1'b0;
267                       wire                       rd_en_i;
268                       reg                        rd_en_fwft;
269                       wire                       ram_regce;
270                       wire                       ram_regce_pipe;
271                       wire [READ_DATA_WIDTH-1:0] dout_i;
272                       reg                        empty_fwft_i     = 1'b1;
273                       reg                        aempty_fwft_i    = 1'b1;
274                       reg                        empty_fwft_fb    = 1'b1;
275                       reg                        overflow_i       = 1'b0;
276                       reg                        underflow_i      = 1'b0;
277                       reg                        data_valid_fwft  = 1'b0;
278                       reg                        data_valid_std   = 1'b0;
279                       wire                       data_vld_std;
280                       wire                       wrp_gt_rdp_and_red;
281                       wire                       wrp_lt_rdp_and_red;
282                       reg                        ram_wr_en_pf_q = 1'b0;
283                       reg                        ram_rd_en_pf_q = 1'b0;
284                       wire                       ram_wr_en_pf;
285                       wire                       ram_rd_en_pf;
286                       wire                       wr_pntr_plus1_pf_carry;
287                       wire                       rd_pntr_wr_adj_pf_carry;
288                       wire                       write_allow;
289                       wire                       read_allow;
290                       wire                       read_only;
291                       wire                       write_only;
292                       reg                        write_only_q;
293                       reg                        read_only_q;
294                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg1;
295                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_reg2;
296                       reg [RD_PNTR_WIDTH-1:0]    diff_pntr_pe = 'b0;
297                       reg                        prog_empty_i = 1'b1;
298                       reg                        ram_empty_i_d1 = 1'b1;
299                       wire                       fe_of_empty;
300                       // function to validate the write depth value
301                       function logic dpth_pwr_2;
302                         input integer fifo_depth;
303                         integer log2_of_depth; // correcponding to the default value of 2k depth
304        1/1              log2_of_depth = clog2(fifo_depth);
305        1/1              if (fifo_depth == 2 ** log2_of_depth)
306        1/1                dpth_pwr_2 = 1;
307                         else
308        <font color = "red">0/1     ==>        dpth_pwr_2 = 0;</font>
309        1/1              return dpth_pwr_2;
310                       endfunction
311                       
312                       initial begin : config_drc
313                         reg drc_err_flag;
314        1/1              drc_err_flag = 0;
315        2/2              #1;
316                     
317        1/1              if (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEM_TYPE == 3) begin
318        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] UltraRAM cannot be used as asynchronous FIFO because it has only one clock support %m&quot;, &quot;XPM_FIFO&quot;, 1, 1);</font>
319        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
320                         end
                        MISSING_ELSE
321                     
322        1/1              if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 1) begin
323        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Related Clocks cannot be used in synchronous FIFO because it is applicable only for asynchronous FIFO %m&quot;, &quot;XPM_FIFO&quot;, 1, 2);</font>
324        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
325                         end
                        MISSING_ELSE
326                     
327        1/1              if(!(FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
328        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is not within the supported ranges. Miniumum supported depth is 16, and the maximum supported depth is 4*1024*1024 locations. %m&quot;, &quot;XPM_FIFO&quot;, 1, 3, FIFO_WRITE_DEPTH);</font>
329        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
330                         end
                        MISSING_ELSE
331                     
332        1/1              if(!dpth_pwr_2(FIFO_WRITE_DEPTH) &amp;&amp; (FIFO_WRITE_DEPTH &gt; 15 &amp;&amp; FIFO_WRITE_DEPTH &lt;= 4*1024*1024)) begin
333        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_WRITE_DEPTH (%0d) value specified is non-power of 2, but this release of XPM_FIFO supports configurations having the fifo write depth set to power of 2. %m&quot;, &quot;XPM_FIFO&quot;, 1, 4, FIFO_WRITE_DEPTH);</font>
334        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
335                         end
                        MISSING_ELSE
336                     
337        1/1              if (CDC_DEST_SYNC_FF &lt; 2 || CDC_DEST_SYNC_FF &gt; 8) begin
338        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but this beta release of XPM_FIFO supports CDC_DEST_SYNC_FF values in between 2 and 8. %m&quot;, &quot;XPM_FIFO&quot;, 1, 5,CDC_DEST_SYNC_FF);</font>
339        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
340                         end
                        MISSING_ELSE
341        1/1              if (CDC_DEST_SYNC_FF != 2 &amp;&amp; RELATED_CLOCKS == 1) begin
342        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF (%0d) value is specified for this configuration, but CDC_DEST_SYNC_FF value can not be modified from default value when RELATED_CLOCKS parameter is set to 1. %m&quot;, &quot;XPM_FIFO&quot;, 1, 6,CDC_DEST_SYNC_FF);</font>
343        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
344                         end
                        MISSING_ELSE
345        1/1              if (FIFO_WRITE_DEPTH == 16 &amp;&amp; CDC_DEST_SYNC_FF &gt; 4) begin
346        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CDC_DEST_SYNC_FF = %0d and FIFO_WRITE_DEPTH = %0d. This is invalid combination. Either FIFO_WRITE_DEPTH should be increased or CDC_DEST_SYNC_FF should be reduced. %m&quot;, &quot;XPM_FIFO&quot;, 1, 7,CDC_DEST_SYNC_FF, FIFO_WRITE_DEPTH);</font>
347        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
348                         end
                        MISSING_ELSE
349        1/1              if (EN_ADV_FEATURE[7:5] != 3'h0) begin
350        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[7:5] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 8, EN_ADV_FEATURE[7:5]);</font>
351        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
352                         end
                        MISSING_ELSE
353        1/1              if (EN_ADV_FEATURE[15:14] != 3'h0) begin
354        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES[15:13] = %0h. This is a reserved field and must be set to 0s. %m&quot;, &quot;XPM_FIFO&quot;, 1, 9, EN_ADV_FEATURE[15:13]);</font>
355        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
356                         end
                        MISSING_ELSE
357                     //    if(WIDTH_RATIO &gt; 32) begin
358                     //      $error(&quot;[%s %0d-%0d] The ratio between WRITE_DATA_WIDTH (%0d) and READ_DATA_WIDTH (%0d) is greater than 32, but this release of XPM_FIFO supports configurations having the ratio between data widths must be less than 32. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH, READ_DATA_WIDTH);
359                     //      drc_err_flag = 1;
360                     //    end
361        1/1              if (WR_WIDTH_LOG+WR_DEPTH_LOG &gt; 30) begin
362        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The specified Width(%0d) and Depth(%0d) exceeds the maximum supported FIFO SIZE. Please reduce either FIFO Width or Depth. %m&quot;, &quot;XPM_FIFO&quot;, 1, 10, WRITE_DATA_WIDTH,FIFO_WRITE_DEPTH);</font>
363        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
364                         end
                        MISSING_ELSE
365        1/1              if(FIFO_READ_DEPTH &lt; 16) begin
366        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Width is %0d Read Width is %0d and Write Depth is %0d, this results in the Read Depth(%0d) less than 16. This is an invalid combination, Ensure the depth on both sides is minimum 16. %m&quot;, &quot;XPM_FIFO&quot;, 1, 11, WRITE_DATA_WIDTH, READ_DATA_WIDTH, FIFO_WRITE_DEPTH, FIFO_READ_DEPTH);</font>
367        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
368                         end
                        MISSING_ELSE
369                     
370                         // Range Checks
371        1/1              if (COMMON_CLOCK &gt; 1) begin
372        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] COMMON_CLOCK (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 1, COMMON_CLOCK);</font>
373        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
374                         end
                        MISSING_ELSE
375        1/1              if (FIFO_MEMORY_TYPE &gt; 3) begin
376        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] FIFO_MEMORY_TYPE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 2, FIFO_MEMORY_TYPE);</font>
377        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
378                         end
                        MISSING_ELSE
379        1/1          	if (READ_MODE &gt; 2) begin
380        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 3, READ_MODE);</font>
381        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
382                         end
                        MISSING_ELSE
383                     
384        1/1              if (ECC_MODE &gt; 1) begin
385        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] ECC_MODE (%s) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 4, ECC_MODE);</font>
386        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
387                         end
                        MISSING_ELSE
388        1/1          	if (!(WAKEUP_TIME == 0 || WAKEUP_TIME == 2)) begin
389        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WAKEUP_TIME (%0d) value is outside of legal range. WAKEUP_TIME should be either 0 or 2. %m&quot;, &quot;XPM_FIFO&quot;, 10, 5, WAKEUP_TIME);</font>
390        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
391                         end
                        MISSING_ELSE
392        1/1              if (!(VERSION == 0)) begin
393        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] VERSION (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 10, 6, VERSION);</font>
394        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
395                         end
                        MISSING_ELSE
396                     
397        1/1              if (!(WRITE_DATA_WIDTH &gt; 0)) begin
398        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 2, WRITE_DATA_WIDTH);</font>
399        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
400                         end
                        MISSING_ELSE
401        1/1              if (!(READ_DATA_WIDTH &gt; 0)) begin
402        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH (%0d) value is outside of legal range. %m&quot;, &quot;XPM_FIFO&quot;, 15, 3, READ_DATA_WIDTH);</font>
403        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
404                         end
                        MISSING_ELSE
405                     
406        1/1              if (EN_PF == 1 &amp;&amp; ((PROG_FULL_THRESH &lt; PF_THRESH_MIN) || (PROG_FULL_THRESH &gt; PF_THRESH_MAX))) begin
407        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Full flag is enabled, but PROG_FULL_THRESH (%0d) value is outside of legal range. PROG_FULL_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 4, PROG_FULL_THRESH, PF_THRESH_MIN, PF_THRESH_MAX);</font>
408        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
409                         end
                        MISSING_ELSE
410                     
411        1/1              if (EN_PE == 1 &amp;&amp; (WIDTH_RATIO &lt;= 32) &amp;&amp; ((PROG_EMPTY_THRESH &lt; PE_THRESH_MIN) || (PROG_EMPTY_THRESH &gt; PE_THRESH_MAX))) begin
412        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Programmable Empty flag is enabled, but PROG_EMPTY_THRESH (%0d) value is outside of legal range. PROG_EMPTY_THRESH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 5, PROG_EMPTY_THRESH, PE_THRESH_MIN, PE_THRESH_MAX);</font>
413        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
414                         end
                        MISSING_ELSE
415                     
416        1/1              if (EN_WDC == 1 &amp;&amp; ((WR_DATA_COUNT_WIDTH &lt; 0) || (WR_DATA_COUNT_WIDTH &gt; WR_DC_WIDTH_EXT))) begin
417        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Write Data Count is enabled, but WR_DATA_COUNT_WIDTH (%0d) value is outside of legal range. WR_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 6, WR_DATA_COUNT_WIDTH, 0, WR_DC_WIDTH_EXT);</font>
418        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
419                         end
                        MISSING_ELSE
420                     
421                     
422        1/1              if (EN_RDC == 1 &amp;&amp; ((RD_DATA_COUNT_WIDTH &lt; 0) || (RD_DATA_COUNT_WIDTH &gt; RD_DC_WIDTH_EXT))) begin
423        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Read Data Count is enabled, but RD_DATA_COUNT_WIDTH (%0d) value is outside of legal range. RD_DATA_COUNT_WIDTH value must be between %0d and %0d. %m&quot;, &quot;XPM_FIFO&quot;, 15, 7, RD_DATA_COUNT_WIDTH, 0, RD_DC_WIDTH_EXT);</font>
424        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
425                         end
                        MISSING_ELSE
426                     
427                         //DRCs on Low Latency FWFT mode
428        1/1              if (READ_MODE == 2 &amp;&amp; FIFO_MEMORY_TYPE != 1) begin
429        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] XPM_FIFO does not support Read Mode (Low Latency FWFT) for FIFO_MEMORY_TYPE other than lutram/distributed. %m&quot;, &quot;XPM_FIFO&quot;, 16, 2);</font>
430        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
431                         end
                        MISSING_ELSE
432        1/1              if (READ_MODE == 2 &amp;&amp; EN_ADV_FEATURE != 16'h0) begin
433        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_ADV_FEATURES = %0h. XPM_FIFO does not support Advanced Features in Low Latency FWFT mode. %m&quot;, &quot;XPM_FIFO&quot;, 16, 3, EN_ADV_FEATURE);</font>
434        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
435                         end
                        MISSING_ELSE
436                     
437                         // Infos
438                     
439                         // Warnings
440        1/1              if (drc_err_flag == 1)
441        <font color = "red">0/2     ==>        #1 $finish;</font>
                        MISSING_ELSE
442                       end : config_drc
443                     
444                       wire wr_en_i;
445                       wire wr_rst_i;
446                       wire rd_rst_i;
447                       reg  rd_rst_d2 = 1'b0;
448                       wire rst_d1;
449                       wire rst_d2;
450                       wire clr_full;
451                       wire empty_fwft_d1;
452                       wire leaving_empty_fwft_fe;
453                       wire leaving_empty_fwft_re;
454                       wire le_fwft_re;
455                       wire le_fwft_fe;
456                       wire [1:0] extra_words_fwft;
457                       wire le_fwft_re_wr;
458                       wire le_fwft_fe_wr;
459                     
460                       generate
461                     
462                       xpm_fifo_rst # (COMMON_CLOCK, CDC_DEST_SYNC_FF, SIM_ASSERT_CHK)
463                         xpm_fifo_rst_inst (rst, wr_clk, rd_clk, wr_rst_i, rd_rst_i, wrst_busy, rd_rst_busy);
464                       assign wr_rst_busy = wrst_busy | rst_d1;
465                     
466                       xpm_fifo_reg_bit #(0)
467                         rst_d1_inst (1'b0, wr_clk, wrst_busy, rst_d1);
468                       xpm_fifo_reg_bit #(0)
469                         rst_d2_inst (1'b0, wr_clk, rst_d1, rst_d2);
470                     
471                       assign clr_full = ~wrst_busy &amp; rst_d1 &amp; ~rst;
472                       assign rd_en_i = (RD_MODE == 0) ? rd_en : rd_en_fwft;
473                     
474                       if (REMOVE_WR_RD_PROT_LOGIC == 1) begin : ngen_wr_rd_prot
475                         assign ram_wr_en_i = wr_en;
476                         assign ram_rd_en_i = rd_en_i;
477                       end : ngen_wr_rd_prot
478                       else begin : gen_wr_rd_prot
479                         assign ram_wr_en_i = wr_en &amp; ~ram_full_i &amp; ~(wrst_busy|rst_d1);
480                         assign ram_rd_en_i = rd_en_i &amp; ~ram_empty_i;
481                       end : gen_wr_rd_prot
482                     
483                       // Write pointer generation
484                       xpm_counter_updn # (WR_PNTR_WIDTH+1, 0)
485                         wrp_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_ext);
486                       assign wr_pntr = wr_pntr_ext[WR_PNTR_WIDTH-1:0];
487                     
488                       xpm_counter_updn # (WR_PNTR_WIDTH, 1)
489                         wrpp1_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus1);
490                     
491                       xpm_counter_updn # (WR_PNTR_WIDTH, 2)
492                         wrpp2_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus2);
493                     
494                       if (EN_AF == 1) begin : gaf_wptr_p3
495                         xpm_counter_updn # (WR_PNTR_WIDTH, 3)
496                           wrpp3_inst (wrst_busy, wr_clk, ram_wr_en_i, ram_wr_en_i, 1'b0, wr_pntr_plus3);
497                       end : gaf_wptr_p3
498                     
499                       // Read pointer generation
500                       xpm_counter_updn # (RD_PNTR_WIDTH+1, 0)
501                         rdp_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_ext);
502                       assign rd_pntr = rd_pntr_ext[RD_PNTR_WIDTH-1:0];
503                     
504                       xpm_counter_updn # (RD_PNTR_WIDTH, 1)
505                         rdpp1_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus1);
506                     
507                       if (EN_AE == 1) begin : gae_rptr_p2
508                         xpm_counter_updn # (RD_PNTR_WIDTH, 2)
509                           rdpp2_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_rd_en_i, 1'b0, rd_pntr_plus2);
510                       end : gae_rptr_p2
511                     
512                       assign full        = ram_full_i;
513                       assign full_n      = ram_full_n;
514                       assign almost_full = EN_AF == 1 ? ram_afull_i : 1'b0;
515                       assign wr_ack      = EN_WACK == 1 ? wr_ack_i : 1'b0;
516                       if (EN_WACK == 1) begin : gwack
517                         always @ (posedge wr_clk) begin
518                           if (rst | wr_rst_i | wrst_busy)
519                             wr_ack_i  &lt;= 1'b0;
520                           else
521                             wr_ack_i  &lt;= ram_wr_en_i;
522                         end
523                       end : gwack
524                     
525                       assign prog_full  = EN_PF == 1 ? (PROG_FULL_THRESH &gt; 0)  ? prog_full_i  : 1'b0 : 1'b0;
526                       assign prog_empty = EN_PE == 1 ? (PROG_EMPTY_THRESH &gt; 0) ? prog_empty_i : 1'b1 : 1'b0;
527                       
528                       assign empty_i = (RD_MODE == 0)? ram_empty_i : empty_fwft_i;
529                       assign empty   = empty_i;
530                       assign almost_empty = EN_AE == 1 ? (RD_MODE == 0) ? ram_aempty_i : aempty_fwft_i : 1'b0;
531                       
532                       assign data_valid   = EN_DVLD == 1 ? (RD_MODE == 0) ? data_valid_std : data_valid_fwft : 1'b0;
533                       if (EN_DVLD == 1) begin : gdvld
534                         assign data_vld_std = (RD_MODE == 0) ? (FIFO_READ_LATENCY == 1) ? ram_rd_en_i: ram_regce_pipe : ram_regce;
535                         always @ (posedge rd_clk) begin
536                           if (rd_rst_i)
537                             data_valid_std  &lt;= 1'b0;
538                           else
539                             data_valid_std  &lt;= data_vld_std;
540                         end
541                       end : gdvld
542                     
543                       // Simple dual port RAM instantiation for non-Built-in FIFO
544                       if (FIFO_MEMORY_TYPE &lt; 4) begin : gen_sdpram
545                     
546                       // Reset is not supported when ECC is enabled by the BRAM/URAM primitives
547                         wire rst_int;
548                         if(ECC_MODE !=0) begin : gnd_rst
549                           assign rst_int = 0;
550                         end : gnd_rst
551                         else begin : rst_gen
552                           assign rst_int = rd_rst_i;
553                         end : rst_gen
554                       // ----------------------------------------------------------------------
555                       // Base module instantiation with simple dual port RAM configuration
556                       // ----------------------------------------------------------------------
557                       localparam USE_DRAM_CONSTRAINT = (COMMON_CLOCK == 0 &amp;&amp; FIFO_MEMORY_TYPE == 1) ? 1 : 0;
558                       localparam WR_MODE_B           = (FIFO_MEMORY_TYPE == 1 || FIFO_MEMORY_TYPE == 3) ? 1 : 2;
559                       xpm_memory_base # (
560                     
561                         // Common module parameters
562                         .MEMORY_TYPE              (1                    ),
563                         .MEMORY_SIZE              (FIFO_SIZE            ),
564                         .MEMORY_PRIMITIVE         (FIFO_MEMORY_TYPE     ),
565                         .CLOCKING_MODE            (COMMON_CLOCK ? 0 : 1 ),
566                         .ECC_MODE                 (ENABLE_ECC           ),
567                         .USE_MEM_INIT             (0                    ),
568                         .MEMORY_INIT_FILE         (&quot;none&quot;               ),
569                         .MEMORY_INIT_PARAM        (&quot;&quot;                   ),
570                         .WAKEUP_TIME              (WAKEUP_TIME          ),
571                         .MESSAGE_CONTROL          (0                    ),
572                         .VERSION                  (0                    ),
573                         .MEMORY_OPTIMIZATION      (&quot;true&quot;               ),
574                         .AUTO_SLEEP_TIME          (0                    ),
575                         .USE_EMBEDDED_CONSTRAINT  (USE_DRAM_CONSTRAINT  ),
576                         .CASCADE_HEIGHT           (CASCADE_HEIGHT       ),
577                     
578                         // Port A module parameters
579                         .WRITE_DATA_WIDTH_A       (WRITE_DATA_WIDTH     ),
580                         .READ_DATA_WIDTH_A        (WRITE_DATA_WIDTH     ),
581                         .BYTE_WRITE_WIDTH_A       (WRITE_DATA_WIDTH     ),
582                         .ADDR_WIDTH_A             (WR_PNTR_WIDTH        ),
583                         .READ_RESET_VALUE_A       (&quot;0&quot;                  ),
584                         .READ_LATENCY_A           (2                    ),
585                         .WRITE_MODE_A             (2                    ),
586                     
587                         // Port B module parameters
588                         .WRITE_DATA_WIDTH_B       (READ_DATA_WIDTH      ),
589                         .READ_DATA_WIDTH_B        (READ_DATA_WIDTH      ),
590                         .BYTE_WRITE_WIDTH_B       (READ_DATA_WIDTH      ),
591                         .ADDR_WIDTH_B             (RD_PNTR_WIDTH        ),
592                         .READ_RESET_VALUE_B       (DOUT_RESET_VALUE     ),
593                         .READ_LATENCY_B           (RD_LATENCY           ),
594                         .WRITE_MODE_B             (WR_MODE_B            )
595                       ) xpm_memory_base_inst (
596                     
597                         // Common module ports
598                         .sleep          (sleep                    ),
599                     
600                         // Port A module ports
601                         .clka           (wr_clk                   ),
602                         .rsta           (1'b0                     ),
603                         .ena            (ram_wr_en_i              ),
604                         .regcea         (1'b0                     ),
605                         .wea            (ram_wr_en_i              ),
606                         .addra          (wr_pntr                  ),
607                         .dina           (din                      ),
608                         .injectsbiterra (injectsbiterr            ),
609                         .injectdbiterra (injectdbiterr            ),
610                         .douta          (                         ),
611                         .sbiterra       (                         ),
612                         .dbiterra       (                         ),
613                     
614                         // Port B module ports
615                         .clkb           (rd_clk                   ),
616                         .rstb           (rst_int                  ),
617                         .enb            (ram_rd_en_i              ),
618                         .regceb         (READ_MODE == 0 ? ram_regce_pipe: ram_regce),
619                         .web            (1'b0                     ),
620                         .addrb          (rd_pntr                  ),
621                         .dinb           ({READ_DATA_WIDTH{1'b0}}  ),
622                         .injectsbiterrb (1'b0                     ),
623                         .injectdbiterrb (1'b0                     ),
624                         .doutb          (dout_i                   ),
625                         .sbiterrb       (sbiterr                  ),
626                         .dbiterrb       (dbiterr                  )
627                       );
628                       end : gen_sdpram
629                     
630                       if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
631                         assign wr_pntr_rd_adj    = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
632                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
633                         assign rd_pntr_wr_adj    = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
634                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
635                       end : wrp_eq_rdp
636                     
637                       if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
638                         assign wr_pntr_rd_adj = wr_pntr_rd[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
639                         assign wr_pntr_rd_adj_dc = wr_pntr_rd_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH];
640                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-1:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr;
641                         assign rd_pntr_wr_adj[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
642                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH:WR_PNTR_WIDTH-RD_PNTR_WIDTH] = rd_pntr_wr_dc;
643                         assign rd_pntr_wr_adj_dc[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0] = {(WR_PNTR_WIDTH-RD_PNTR_WIDTH){1'b0}};
644                       end : wrp_gt_rdp
645                     
646                       if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
647                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd;
648                         assign wr_pntr_rd_adj[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
649                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH] = wr_pntr_rd_dc;
650                         assign wr_pntr_rd_adj_dc[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0] = {(RD_PNTR_WIDTH-WR_PNTR_WIDTH){1'b0}};
651                         assign rd_pntr_wr_adj = rd_pntr_wr[RD_PNTR_WIDTH-1:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
652                         assign rd_pntr_wr_adj_dc = rd_pntr_wr_dc[RD_PNTR_WIDTH:RD_PNTR_WIDTH-WR_PNTR_WIDTH];
653                       end : wrp_lt_rdp
654                     
655                       if (COMMON_CLOCK == 0 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_cdc_pntr
656                         // Synchronize the write pointer in rd_clk domain
657                         xpm_cdc_gray #(
658                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
659                           .INIT_SYNC_FF          (1),
660                           .WIDTH                 (WR_PNTR_WIDTH))
661                           
662                           wr_pntr_cdc_inst (
663                             .src_clk             (wr_clk),
664                             .src_in_bin          (wr_pntr),
665                             .dest_clk            (rd_clk),
666                             .dest_out_bin        (wr_pntr_rd_cdc));
667                     
668                         // Register the output of XPM_CDC_GRAY on read side
669                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
670                           wpr_gray_reg (rd_rst_i, rd_clk, wr_pntr_rd_cdc, wr_pntr_rd);
671                     
672                         // Synchronize the extended write pointer in rd_clk domain
673                         xpm_cdc_gray #(
674                           .DEST_SYNC_FF          (READ_MODE == 0 ? CDC_DEST_SYNC_FF : CDC_DEST_SYNC_FF+2),
675                           .INIT_SYNC_FF          (1),
676                           .WIDTH                 (WR_PNTR_WIDTH+1))
677                           wr_pntr_cdc_dc_inst (
678                             .src_clk             (wr_clk),
679                             .src_in_bin          (wr_pntr_ext),
680                             .dest_clk            (rd_clk),
681                             .dest_out_bin        (wr_pntr_rd_cdc_dc));
682                     
683                         // Register the output of XPM_CDC_GRAY on read side
684                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
685                           wpr_gray_reg_dc (rd_rst_i, rd_clk, wr_pntr_rd_cdc_dc, wr_pntr_rd_dc);
686                     
687                         // Synchronize the read pointer in wr_clk domain
688                         xpm_cdc_gray #(
689                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
690                           .INIT_SYNC_FF          (1),
691                           .WIDTH                 (RD_PNTR_WIDTH))
692                           rd_pntr_cdc_inst (
693                             .src_clk             (rd_clk),
694                             .src_in_bin          (rd_pntr),
695                             .dest_clk            (wr_clk),
696                             .dest_out_bin        (rd_pntr_wr_cdc));
697                     
698                         // Register the output of XPM_CDC_GRAY on write side
699                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
700                           rpw_gray_reg (wrst_busy, wr_clk, rd_pntr_wr_cdc, rd_pntr_wr);
701                     
702                         // Synchronize the read pointer, subtracted by the extra word read for FWFT, in wr_clk domain
703                         xpm_cdc_gray #(
704                           .DEST_SYNC_FF          (CDC_DEST_SYNC_FF),
705                           .INIT_SYNC_FF          (1),
706                           .WIDTH                 (RD_PNTR_WIDTH+1))
707                           rd_pntr_cdc_dc_inst (
708                             .src_clk             (rd_clk),
709                             .src_in_bin          (rd_pntr_ext-extra_words_fwft),
710                             .dest_clk            (wr_clk),
711                             .dest_out_bin        (rd_pntr_wr_cdc_dc));
712                     
713                         // Register the output of XPM_CDC_GRAY on write side
714                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
715                           rpw_gray_reg_dc (wrst_busy, wr_clk, rd_pntr_wr_cdc_dc, rd_pntr_wr_dc);
716                     
717                       end : gen_cdc_pntr
718                     
719                       if (RELATED_CLOCKS == 1) begin : gen_pntr_pf_rc
720                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH)
721                           rpw_rc_reg (wrst_busy, wr_clk, rd_pntr, rd_pntr_wr);
722                     
723                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH)
724                           wpr_rc_reg (rd_rst_i, rd_clk, wr_pntr, wr_pntr_rd);
725                     
726                         xpm_fifo_reg_vec #(WR_PNTR_WIDTH+1)
727                           wpr_rc_reg_dc (rd_rst_i, rd_clk, wr_pntr_ext, wr_pntr_rd_dc);
728                     
729                         xpm_fifo_reg_vec #(RD_PNTR_WIDTH+1)
730                           rpw_rc_reg_dc (wrst_busy, wr_clk, (rd_pntr_ext-extra_words_fwft), rd_pntr_wr_dc);
731                       end : gen_pntr_pf_rc
732                     
733                       if (COMMON_CLOCK == 0 || RELATED_CLOCKS == 1) begin : gen_pf_ic_rc
734                       
735                         assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_rd_en_i);
736                         assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr));
737                         assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ram_rd_en_i);
738                         assign leaving_aempty  = ((wr_pntr_rd_adj == rd_pntr_plus1));
739                       
740                         assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i);
741                         assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr_plus1));
742                         assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus3) &amp; ram_wr_en_i);
743                         assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus2));
744                       
745                         // Empty flag generation
746                         always @ (posedge rd_clk) begin
747                           if (rd_rst_i) begin
748                              ram_empty_i  &lt;= 1'b1;
749                           end else begin
750                              ram_empty_i  &lt;= going_empty | leaving_empty;
751                           end
752                         end
753                     
754                         if (EN_AE == 1) begin : gae_ic_std
755                           always @ (posedge rd_clk) begin
756                             if (rd_rst_i) begin
757                               ram_aempty_i &lt;= 1'b1;
758                             end else if (~ram_empty_i) begin
759                               ram_aempty_i &lt;= going_aempty | leaving_aempty;
760                             end
761                           end
762                         end : gae_ic_std
763                       
764                         // Full flag generation
765                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
766                           always @ (posedge wr_clk) begin
767                     	if (wrst_busy) begin
768                               ram_full_i      &lt;= FULL_RST_VAL;
769                               ram_full_n      &lt;= ~FULL_RST_VAL;
770                             end else begin
771                     	  if (clr_full) begin
772                                 ram_full_i    &lt;= 1'b0;
773                                 ram_full_n    &lt;= 1'b1;
774                     	  end else begin
775                                 ram_full_i    &lt;= going_full | leaving_full;
776                                 ram_full_n    &lt;= ~(going_full | leaving_full);
777                               end
778                             end
779                           end
780                         end : gen_full_rst_val
781                         else begin : ngen_full_rst_val
782                           always @ (posedge wr_clk) begin
783                     	if (wrst_busy) begin
784                               ram_full_i   &lt;= 1'b0;
785                               ram_full_n   &lt;= 1'b1;
786                     	end else begin
787                               ram_full_i   &lt;= going_full | leaving_full;
788                               ram_full_n   &lt;= ~(going_full | leaving_full);
789                     	end
790                           end
791                         end : ngen_full_rst_val
792                     
793                         if (EN_AF == 1) begin : gaf_ic
794                           always @ (posedge wr_clk) begin
795                     	if (wrst_busy) begin
796                               ram_afull_i  &lt;= FULL_RST_VAL;
797                             end else if (~rst) begin
798                     	  if (clr_full) begin
799                                 ram_afull_i  &lt;= 1'b0;
800                     	  end else if (~ram_full_i) begin
801                                 ram_afull_i  &lt;= going_afull | leaving_afull;
802                               end
803                             end
804                           end
805                         end : gaf_ic
806                     
807                       // synthesis translate_off
808                         `ifndef DISABLE_XPM_ASSERTIONS
809                         if (SIM_ASSERT_CHK == 1) begin: assert_wr_rd_en
810                           always @ (posedge rd_clk) begin
811                             assert (!$isunknown(rd_en)) else $warning (&quot;Input port 'rd_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'rd_en' has a valid value ('0' or '1')&quot;,$time);
812                           end
813                     
814                           always @ (posedge wr_clk) begin
815                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
816                           end
817                     
818                           always @ (posedge wr_clk) begin
819                             assert (!$isunknown(wr_en)) else $warning (&quot;Input port 'wr_en' has unknown value 'X' or 'Z' at %0t. This may cause full/empty to be 'X' or 'Z' in simulation. Ensure 'wr_en' has a valid value ('0' or '1')&quot;,$time);
820                           end
821                     
822                         end : assert_wr_rd_en
823                         `endif
824                       // synthesis translate_on
825                     
826                         // Programmable Full flag generation
827                         if (EN_PF == 1) begin : gpf_ic
828                           assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
829                           assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
830                       
831                           // PF carry generation
832                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i;
833                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i;
834                       
835                           // PF diff pointer generation
836                           always @ (posedge wr_clk) begin
837                             if (wrst_busy)
838                                diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
839                             else
840                                diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
841                           end
842                           assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
843                       
844                           always @ (posedge wr_clk) begin
845                             if (wrst_busy)
846                                prog_full_i  &lt;= FULL_RST_VAL;
847                             else if (clr_full)
848                                prog_full_i  &lt;= 1'b0;
849                             else if (~ram_full_i) begin
850                               if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
851                                 prog_full_i  &lt;= 1'b1;
852                               else
853                                 prog_full_i  &lt;= 1'b0;
854                             end else
855                               prog_full_i  &lt;= prog_full_i;
856                           end
857                         end : gpf_ic
858                     
859                         /*********************************************************
860                          * Programmable EMPTY flags
861                          *********************************************************/
862                         //Determine the Assert and Negate thresholds for Programmable Empty
863                         if (EN_PE == 1) begin : gpe_ic
864                      
865                           always @(posedge rd_clk) begin
866                             if (rd_rst_i) begin
867                               diff_pntr_pe      &lt;= 0;
868                               prog_empty_i       &lt;= 1'b1;
869                             end else begin
870                               if (ram_rd_en_i)
871                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr) - 1'h1;
872                               else
873                                 diff_pntr_pe       &lt;=  (wr_pntr_rd_adj - rd_pntr);
874                          
875                               if (~empty_i) begin
876                                 if (diff_pntr_pe &lt;= PE_THRESH_ADJ)
877                                   prog_empty_i &lt;= 1'b1;
878                                 else
879                                   prog_empty_i &lt;= 1'b0;
880                               end else
881                                 prog_empty_i   &lt;= prog_empty_i;
882                             end
883                           end
884                         end : gpe_ic
885                       end : gen_pf_ic_rc
886                     
887                       if (COMMON_CLOCK == 1 &amp;&amp; RELATED_CLOCKS == 0) begin : gen_pntr_flags_cc
888                         assign wr_pntr_rd = wr_pntr;
889                         assign rd_pntr_wr = rd_pntr;
890                         assign wr_pntr_rd_dc = wr_pntr_ext;
891                         assign rd_pntr_wr_dc = rd_pntr_ext-extra_words_fwft;
892                         assign write_allow  = ram_wr_en_i &amp; ~ram_full_i;
893                         assign read_allow   = ram_rd_en_i &amp; ~empty_i;
894                     
895                         if (WR_PNTR_WIDTH == RD_PNTR_WIDTH) begin : wrp_eq_rdp
896                           assign ram_wr_en_pf  = ram_wr_en_i;
897                           assign ram_rd_en_pf  = ram_rd_en_i;
898                       
899                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
900                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
901                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
902                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
903                       
904                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
905                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
906                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
907                           assign leaving_afull  = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_rd_en_i &amp; ~ram_wr_en_i);
908                     
909                           assign write_only    = write_allow &amp; ~read_allow;
910                           assign read_only     = read_allow &amp; ~write_allow;
911                     
912                         end : wrp_eq_rdp
913                       
914                         if (WR_PNTR_WIDTH &gt; RD_PNTR_WIDTH) begin : wrp_gt_rdp
915                           assign wrp_gt_rdp_and_red = &amp;wr_pntr_rd[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1:0];
916                       
917                           assign going_empty    = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
918                           assign leaving_empty  = ((wr_pntr_rd_adj == rd_pntr) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red));
919                           assign going_aempty   = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~(ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ram_rd_en_i);
920                           assign leaving_aempty = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; (ram_wr_en_i &amp; wrp_gt_rdp_and_red) &amp; ~ram_rd_en_i);
921                       
922                           assign going_full     = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
923                           assign leaving_full   = ((rd_pntr_wr_adj == wr_pntr) &amp; ram_rd_en_i);
924                           assign going_afull    = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ram_wr_en_i &amp; ~ram_rd_en_i);
925                           assign leaving_afull  = (((rd_pntr_wr_adj == wr_pntr) | (rd_pntr_wr_adj == wr_pntr_plus1) | (rd_pntr_wr_adj == wr_pntr_plus2)) &amp; ram_rd_en_i);
926                       
927                           assign ram_wr_en_pf  = ram_wr_en_i &amp; wrp_gt_rdp_and_red;
928                           assign ram_rd_en_pf  = ram_rd_en_i;
929                     
930                           assign read_only     = read_allow &amp; (~(write_allow  &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0])));
931                           assign write_only    = write_allow &amp; (&amp;wr_pntr[WR_PNTR_WIDTH-RD_PNTR_WIDTH-1 : 0]) &amp; ~read_allow;
932                     
933                     
934                         end : wrp_gt_rdp
935                       
936                         if (WR_PNTR_WIDTH &lt; RD_PNTR_WIDTH) begin : wrp_lt_rdp
937                           assign wrp_lt_rdp_and_red = &amp;rd_pntr_wr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1:0];
938                       
939                           assign going_empty     = ((wr_pntr_rd_adj == rd_pntr_plus1) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
940                           assign leaving_empty   = ((wr_pntr_rd_adj == rd_pntr) &amp; ram_wr_en_i);
941                           assign going_aempty    = ((wr_pntr_rd_adj == rd_pntr_plus2) &amp; ~ram_wr_en_i &amp; ram_rd_en_i);
942                           assign leaving_aempty  = (((wr_pntr_rd_adj == rd_pntr) | (wr_pntr_rd_adj == rd_pntr_plus1) | (wr_pntr_rd_adj == rd_pntr_plus2)) &amp; ram_wr_en_i);
943                       
944                           assign going_full      = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
945                           assign leaving_full    = ((rd_pntr_wr_adj == wr_pntr) &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
946                           assign going_afull     = ((rd_pntr_wr_adj == wr_pntr_plus2) &amp; ~(ram_rd_en_i &amp; wrp_lt_rdp_and_red) &amp; ram_wr_en_i);
947                           assign leaving_afull   = ((rd_pntr_wr_adj == wr_pntr_plus1) &amp; ~ram_wr_en_i &amp; (ram_rd_en_i &amp; wrp_lt_rdp_and_red));
948                       
949                           assign ram_wr_en_pf = ram_wr_en_i;
950                           assign ram_rd_en_pf = ram_rd_en_i &amp; wrp_lt_rdp_and_red;
951                     
952                           assign read_only   = read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0]) &amp; ~write_allow;
953                           assign write_only    = write_allow    &amp; (~(read_allow &amp; (&amp;rd_pntr[RD_PNTR_WIDTH-WR_PNTR_WIDTH-1 : 0])));
954                         end : wrp_lt_rdp
955                       
956                         // Empty flag generation
957                         always @ (posedge rd_clk) begin
958        1/1                if (rd_rst_i) begin
959        1/1                   ram_empty_i  &lt;= 1'b1;
960                           end else begin
961        1/1                   ram_empty_i  &lt;= going_empty | (~leaving_empty &amp; ram_empty_i);
962                           end
963                         end
964                     
965                         if (EN_AE == 1) begin : gae_cc_std
966                           always @ (posedge rd_clk) begin
967                             if (rd_rst_i) begin
968                               ram_aempty_i &lt;= 1'b1;
969                             end else begin
970                               ram_aempty_i &lt;= going_aempty | (~leaving_aempty &amp; ram_aempty_i);
971                             end
972                           end
973                         end : gae_cc_std
974                     
975                         // Full flag generation
976                         if (FULL_RST_VAL == 1) begin : gen_full_rst_val
977                           always @ (posedge wr_clk) begin
978                     	if (wrst_busy) begin
979                               ram_full_i   &lt;= FULL_RST_VAL;
980                               ram_full_n   &lt;= ~FULL_RST_VAL;
981                             end else begin
982                     	  if (clr_full) begin
983                                 ram_full_i   &lt;= 1'b0;
984                                 ram_full_n   &lt;= 1'b1;
985                     	  end else begin
986                                 ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
987                                 ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
988                               end
989                             end
990                           end
991                         end : gen_full_rst_val
992                         else begin : ngen_full_rst_val
993                           always @ (posedge wr_clk) begin
994        1/1          	if (wrst_busy) begin
995        1/1                    ram_full_i   &lt;= 1'b0;
996        1/1                    ram_full_n   &lt;= 1'b1;
997                     	end else begin
998        1/1                    ram_full_i   &lt;= going_full | (~leaving_full &amp; ram_full_i);
999        1/1                    ram_full_n   &lt;= ~(going_full | (~leaving_full &amp; ram_full_i));
1000                    	end
1001                          end
1002                        end : ngen_full_rst_val
1003                    
1004                        if (EN_AF == 1) begin : gaf_cc
1005                          always @ (posedge wr_clk) begin
1006                    	if (wrst_busy) begin
1007                              ram_afull_i  &lt;= FULL_RST_VAL;
1008                            end else if (~rst) begin
1009                    	  if (clr_full) begin
1010                                ram_afull_i  &lt;= 1'b0;
1011                    	  end else begin
1012                                ram_afull_i  &lt;= going_afull | (~leaving_afull &amp; ram_afull_i);
1013                              end
1014                            end
1015                          end
1016                        end : gaf_cc
1017                        // Programmable Full flag generation
1018                        if ((WR_PNTR_WIDTH == RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_eq_rdp_pf_cc
1019                          if (EN_PF == 1) begin : gpf_cc_sym
1020                    
1021                            assign wr_pntr_plus1_pf = {wr_pntr_plus1,wr_pntr_plus1_pf_carry};
1022                            assign rd_pntr_wr_adj_inv_pf = {~rd_pntr_wr_adj,rd_pntr_wr_adj_pf_carry};
1023                      
1024                            // Delayed write/read enable for PF generation
1025                            always @ (posedge wr_clk) begin
1026       1/1                    if (wrst_busy) begin
1027       1/1                       ram_wr_en_pf_q   &lt;= 1'b0;
1028       1/1                       ram_rd_en_pf_q   &lt;= 1'b0;
1029                              end else begin
1030       1/1                       ram_wr_en_pf_q   &lt;= ram_wr_en_pf;
1031       1/1                       ram_rd_en_pf_q   &lt;= ram_rd_en_pf;
1032                              end
1033                            end
1034                      
1035                            // PF carry generation
1036                           assign wr_pntr_plus1_pf_carry  = ram_wr_en_i &amp; ~ram_rd_en_pf;
1037                           assign rd_pntr_wr_adj_pf_carry = ram_wr_en_i &amp; ~ram_rd_en_pf;
1038                      
1039                            // PF diff pointer generation
1040                            always @ (posedge wr_clk) begin
1041       1/1                    if (wrst_busy)
1042       1/1                       diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1043                              else
1044       1/1                       diff_pntr_pf_q  &lt;= wr_pntr_plus1_pf + rd_pntr_wr_adj_inv_pf;
1045                            end
1046                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1047                      
1048                            always @ (posedge wr_clk) begin
1049       1/1                    if (wrst_busy)
1050       1/1                       prog_full_i  &lt;= FULL_RST_VAL;
1051       1/1                    else if (clr_full)
1052       1/1                       prog_full_i  &lt;= 1'b0;
1053       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ram_wr_en_pf_q &amp; ~ram_rd_en_pf_q)
1054       1/1                       prog_full_i  &lt;= 1'b1;
1055       1/1                    else if ((diff_pntr_pf == PF_THRESH_ADJ) &amp; ~ram_wr_en_pf_q &amp; ram_rd_en_pf_q)
1056       <font color = "red">0/1     ==>               prog_full_i  &lt;= 1'b0;</font>
1057                              else
1058       1/1                       prog_full_i  &lt;= prog_full_i;
1059                            end
1060                          end : gpf_cc_sym
1061                    
1062                          if (EN_PE == 1) begin : gpe_cc_sym
1063                            always @(posedge rd_clk) begin
1064       1/1                    if (rd_rst_i) begin
1065       1/1                      read_only_q    &lt;= 1'b0;
1066       1/1                      write_only_q   &lt;= 1'b0;
1067       1/1                      diff_pntr_pe   &lt;= 0;
1068                              end 
1069                              else begin
1070       1/1                      read_only_q  &lt;= read_only;
1071       1/1                      write_only_q &lt;= write_only;
1072                                // Add 1 to the difference pointer value when write or both write &amp; read or no write &amp; read happen.
1073       1/1                      if (read_only)
1074       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr - 1;
1075                                else
1076       1/1                        diff_pntr_pe &lt;= wr_pntr_rd_adj - rd_pntr;
1077                              end
1078                            end
1079                      
1080                            always @(posedge rd_clk) begin
1081       1/1                    if (rd_rst_i)
1082       1/1                      prog_empty_i  &lt;= 1'b1;
1083                              else begin
1084       1/1                      if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; read_only_q)
1085       <font color = "red">0/1     ==>                prog_empty_i &lt;= 1'b1;</font>
1086       1/1                      else if (diff_pntr_pe == PE_THRESH_ADJ &amp;&amp; write_only_q)
1087       1/1                        prog_empty_i &lt;= 1'b0;
1088                                else
1089       1/1                        prog_empty_i &lt;= prog_empty_i;
1090                              end
1091                            end
1092                          end : gpe_cc_sym
1093                        end : wrp_eq_rdp_pf_cc
1094                    
1095                        if ((WR_PNTR_WIDTH != RD_PNTR_WIDTH) &amp;&amp; (RELATED_CLOCKS == 0)) begin : wrp_neq_rdp_pf_cc
1096                          if (EN_PF == 1) begin : gpf_cc_asym
1097                            // PF diff pointer generation
1098                            always @ (posedge wr_clk) begin
1099                              if (wrst_busy)
1100                                 diff_pntr_pf_q  &lt;= {WR_PNTR_WIDTH{1'b0}};
1101                              else if (~ram_full_i)
1102                                 diff_pntr_pf_q[WR_PNTR_WIDTH:1]  &lt;= wr_pntr + ~rd_pntr_wr_adj + 1;
1103                            end
1104                            assign diff_pntr_pf = diff_pntr_pf_q[WR_PNTR_WIDTH:1];
1105                            always @ (posedge wr_clk) begin
1106                              if (wrst_busy)
1107                                 prog_full_i  &lt;= FULL_RST_VAL;
1108                              else if (clr_full)
1109                                 prog_full_i  &lt;= 1'b0;
1110                              else if (~ram_full_i) begin
1111                                if (diff_pntr_pf &gt;= PF_THRESH_ADJ)
1112                                   prog_full_i  &lt;= 1'b1;
1113                                else if (diff_pntr_pf &lt; PF_THRESH_ADJ)
1114                                   prog_full_i  &lt;= 1'b0;
1115                                else
1116                                   prog_full_i  &lt;= prog_full_i;
1117                              end
1118                            end
1119                          end : gpf_cc_asym
1120                          if (EN_PE == 1) begin : gpe_cc_asym
1121                            // Programmanble Empty flag Generation
1122                            // Diff pointer Generation
1123                            localparam [RD_PNTR_WIDTH-1 : 0] DIFF_MAX_RD = {RD_PNTR_WIDTH{1'b1}};
1124                            wire [RD_PNTR_WIDTH-1:0] diff_pntr_pe_max;
1125                            wire                     carry;
1126                            reg  [RD_PNTR_WIDTH : 0] diff_pntr_pe_asym = 'b0;
1127                            wire [RD_PNTR_WIDTH : 0] wr_pntr_rd_adj_asym;
1128                            wire [RD_PNTR_WIDTH : 0] rd_pntr_asym;
1129                            reg                      full_reg;
1130                            reg                      rst_full_ff_reg1;
1131                            reg                      rst_full_ff_reg2;
1132                      
1133                            assign diff_pntr_pe_max = DIFF_MAX_RD;
1134                            assign wr_pntr_rd_adj_asym[RD_PNTR_WIDTH:0] = {wr_pntr_rd_adj,1'b1};
1135                            assign rd_pntr_asym[RD_PNTR_WIDTH:0] = {~rd_pntr,1'b1};
1136                      
1137                            always @(posedge rd_clk ) begin
1138                              if (rd_rst_i) begin
1139                                diff_pntr_pe_asym    &lt;= 0;
1140                                full_reg             &lt;= 0;
1141                                rst_full_ff_reg1     &lt;= 1;
1142                                rst_full_ff_reg2     &lt;= 1;
1143                                diff_pntr_pe_reg1    &lt;= 0;
1144                              end else begin
1145                                diff_pntr_pe_asym &lt;= wr_pntr_rd_adj_asym + rd_pntr_asym;
1146                                full_reg          &lt;= ram_full_i;
1147                                rst_full_ff_reg1  &lt;= FULL_RST_VAL;
1148                                rst_full_ff_reg2  &lt;= rst_full_ff_reg1;
1149                              end
1150                            end
1151                            wire [RD_PNTR_WIDTH-1:0]    diff_pntr_pe_i;
1152                            assign carry = (~(|(diff_pntr_pe_asym [RD_PNTR_WIDTH : 1])));
1153                            assign diff_pntr_pe_i = (full_reg &amp;&amp; ~rst_d2 &amp;&amp; carry ) ? diff_pntr_pe_max : diff_pntr_pe_asym[RD_PNTR_WIDTH:1];
1154                        
1155                            always @(posedge rd_clk) begin
1156                              if (rd_rst_i)
1157                                prog_empty_i  &lt;= 1'b1;
1158                              else begin
1159                                if (diff_pntr_pe_i &lt;= PE_THRESH_ADJ)
1160                                  prog_empty_i &lt;= 1'b1;
1161                                else if (diff_pntr_pe_i &gt; PE_THRESH_ADJ)
1162                                  prog_empty_i &lt;= 1'b0;
1163                                else
1164                                  prog_empty_i &lt;= prog_empty_i;
1165                              end
1166                            end
1167                          end : gpe_cc_asym
1168                        end : wrp_neq_rdp_pf_cc
1169                    
1170                      end : gen_pntr_flags_cc
1171                    
1172                      if (READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1) begin : gen_regce_std
1173                        xpm_reg_pipe_bit #(FIFO_READ_LATENCY-1, 0)
1174                          regce_pipe_inst (rd_rst_i, rd_clk, ram_rd_en_i, ram_regce_pipe);
1175                      end : gen_regce_std
1176                      if (!(READ_MODE == 0 &amp;&amp; FIFO_READ_LATENCY &gt; 1)) begin : gnen_regce_std
1177                        assign ram_regce_pipe = 1'b0;
1178                      end : gnen_regce_std
1179                    
1180                      if (!((READ_MODE == 1 || READ_MODE == 2)&amp;&amp; FIFO_MEMORY_TYPE != 4)) begin : gn_fwft
1181                       assign invalid_state = 1'b0;
1182                      end : gn_fwft
1183                      //if (READ_MODE == 1 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1184                      if (READ_MODE != 0 &amp;&amp; FIFO_MEMORY_TYPE != 4) begin : gen_fwft
1185                      // First word fall through logic
1186                    
1187                       //localparam invalid             = 0;
1188                       //localparam stage1_valid        = 2;
1189                       //localparam stage2_valid        = 1;
1190                       //localparam both_stages_valid   = 3;
1191                    
1192                       //reg  [1:0] curr_fwft_state = invalid;
1193                       //reg  [1:0] next_fwft_state;// = invalid;
1194                       wire next_fwft_state_d1;
1195                       assign invalid_state = ~|curr_fwft_state;
1196                       assign valid_fwft = next_fwft_state_d1;
1197                       assign ram_valid_fwft = curr_fwft_state[1];
1198                    
1199                        xpm_fifo_reg_bit #(0)
1200                          next_state_d1_inst (1'b0, rd_clk, next_fwft_state[0], next_fwft_state_d1);
1201                       //FSM : To generate the enable, clock enable for xpm_memory and to generate
1202                       //empty signal
1203                       //FSM : Next state Assignment
1204                         if (READ_MODE == 1) begin : gen_fwft_ns
1205                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1206                           case (curr_fwft_state)
1207                             invalid: begin
1208                               if (~ram_empty_i)
1209                                  next_fwft_state     = stage1_valid;
1210                               else
1211                                  next_fwft_state     = invalid;
1212                               end
1213                             stage1_valid: begin
1214                               if (ram_empty_i)
1215                                  next_fwft_state     = stage2_valid;
1216                               else
1217                                  next_fwft_state     = both_stages_valid;
1218                               end
1219                             stage2_valid: begin
1220                               if (ram_empty_i &amp;&amp; rd_en)
1221                                  next_fwft_state     = invalid;
1222                               else if (~ram_empty_i &amp;&amp; rd_en)
1223                                  next_fwft_state     = stage1_valid;
1224                               else if (~ram_empty_i &amp;&amp; ~rd_en)
1225                                  next_fwft_state     = both_stages_valid;
1226                               else
1227                                  next_fwft_state     = stage2_valid;
1228                               end
1229                             both_stages_valid: begin
1230                               if (ram_empty_i &amp;&amp; rd_en)
1231                                  next_fwft_state     = stage2_valid;
1232                               else if (~ram_empty_i &amp;&amp; rd_en)
1233                                  next_fwft_state     = both_stages_valid;
1234                               else
1235                                  next_fwft_state     = both_stages_valid;
1236                               end
1237                             default: next_fwft_state    = invalid;
1238                           endcase
1239                         end
1240                         end : gen_fwft_ns
1241                         if (READ_MODE == 2) begin : gen_fwft_ns_ll
1242                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1243                           case (curr_fwft_state)
1244                             invalid: begin
1245                               if (~ram_empty_i)
1246                                  next_fwft_state     = stage1_valid;
1247                               else
1248                                  next_fwft_state     = invalid;
1249                               end
1250                             stage1_valid: begin
1251                               if (ram_empty_i &amp;&amp; rd_en)
1252                                  next_fwft_state     = invalid;
1253                               else
1254                                  next_fwft_state     = stage1_valid;
1255                               end
1256                             default: next_fwft_state    = invalid;
1257                           endcase
1258                         end
1259                         end : gen_fwft_ns_ll
1260                         // FSM : current state assignment
1261                         always @ (posedge rd_clk) begin
1262                           if (rd_rst_i)
1263                              curr_fwft_state  &lt;= invalid;
1264                           else
1265                              curr_fwft_state  &lt;= next_fwft_state;
1266                         end
1267                     
1268                         reg ram_regout_en;
1269                    
1270                         // FSM(output assignments) : clock enable generation for xpm_memory
1271                         if (READ_MODE == 1) begin : gen_fwft_ro
1272                         always @(curr_fwft_state or rd_en) begin
1273                           case (curr_fwft_state)
1274                             invalid:           ram_regout_en = 1'b0;
1275                             stage1_valid:      ram_regout_en = 1'b1;
1276                             stage2_valid:      ram_regout_en = 1'b0;
1277                             both_stages_valid: ram_regout_en = rd_en;
1278                             default:           ram_regout_en = 1'b0;
1279                           endcase
1280                         end
1281                         end : gen_fwft_ro
1282                         if (READ_MODE == 2) begin : gen_fwft_ro_ll
1283                         always @(curr_fwft_state or rd_en or ram_empty_i or fe_of_empty) begin
1284                           case (curr_fwft_state)
1285                             invalid:           ram_regout_en = fe_of_empty;
1286                             stage1_valid:      ram_regout_en = rd_en &amp; !ram_empty_i;
1287                             default:           ram_regout_en = 1'b0;
1288                           endcase
1289                         end
1290                         end : gen_fwft_ro_ll
1291                    
1292                         // FSM(output assignments) : rd_en (enable) signal generation for xpm_memory
1293                         if (READ_MODE == 1) begin : gen_fwft_re
1294                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1295                           case (curr_fwft_state)
1296                             invalid :
1297                               if (~ram_empty_i)
1298                                 rd_en_fwft = 1'b1;
1299                               else
1300                                 rd_en_fwft = 1'b0;
1301                             stage1_valid :
1302                               if (~ram_empty_i)
1303                                 rd_en_fwft = 1'b1;
1304                               else
1305                                 rd_en_fwft = 1'b0;
1306                             stage2_valid :
1307                               if (~ram_empty_i)
1308                                 rd_en_fwft = 1'b1;
1309                               else
1310                                 rd_en_fwft = 1'b0;
1311                             both_stages_valid :
1312                               if (~ram_empty_i &amp;&amp; rd_en)
1313                                 rd_en_fwft = 1'b1;
1314                               else
1315                                 rd_en_fwft = 1'b0;
1316                             default :
1317                               rd_en_fwft = 1'b0;
1318                           endcase
1319                         end
1320                         end : gen_fwft_re
1321                         if (READ_MODE == 2) begin : gen_fwft_re_ll
1322                         always @(curr_fwft_state or ram_empty_i or rd_en) begin
1323                           case (curr_fwft_state)
1324                             invalid :
1325                               if (~ram_empty_i)
1326                                 rd_en_fwft = 1'b1;
1327                               else
1328                                 rd_en_fwft = 1'b0;
1329                             stage1_valid :
1330                               if (~ram_empty_i &amp;&amp; rd_en)
1331                                 rd_en_fwft = 1'b1;
1332                               else
1333                                 rd_en_fwft = 1'b0;
1334                             default :
1335                               rd_en_fwft = 1'b0;
1336                           endcase
1337                         end
1338                         end : gen_fwft_re_ll
1339                         // assingment to control regce xpm_memory
1340                         assign ram_regce = ram_regout_en;
1341                    
1342                         reg going_empty_fwft;
1343                         reg leaving_empty_fwft;
1344                    
1345                         if (READ_MODE == 1) begin : gen_fwft_ge
1346                         always @(curr_fwft_state or rd_en) begin
1347                           case (curr_fwft_state)
1348                             stage2_valid : going_empty_fwft = rd_en;
1349                             default      : going_empty_fwft = 1'b0;
1350                           endcase
1351                         end
1352                    
1353                         always @(curr_fwft_state or rd_en) begin
1354                           case (curr_fwft_state)
1355                             stage1_valid : leaving_empty_fwft = 1'b1;
1356                             default      : leaving_empty_fwft = 1'b0;
1357                           endcase
1358                         end
1359                         end : gen_fwft_ge
1360                         if (READ_MODE == 2) begin : gen_fwft_ge_ll
1361                         always @(curr_fwft_state or rd_en or ram_empty_i) begin
1362                           case (curr_fwft_state)
1363                             stage1_valid : going_empty_fwft = rd_en &amp; ram_empty_i;
1364                             default      : going_empty_fwft = 1'b0;
1365                           endcase
1366                         end
1367                    
1368                         always @ (posedge rd_clk) begin
1369                           if (rd_rst_i) begin
1370                              ram_empty_i_d1  &lt;= 1'b1;
1371                           end else begin
1372                              ram_empty_i_d1  &lt;= ram_empty_i;
1373                           end
1374                         end
1375                         assign fe_of_empty = ram_empty_i_d1 &amp; !ram_empty_i;
1376                    
1377                         always @(curr_fwft_state or fe_of_empty) begin
1378                           case (curr_fwft_state)
1379                             invalid      : leaving_empty_fwft = fe_of_empty;
1380                             stage1_valid : leaving_empty_fwft = 1'b1;
1381                             default      : leaving_empty_fwft = 1'b0;
1382                           endcase
1383                         end
1384                         end : gen_fwft_ge_ll
1385                    
1386                         // fwft empty signal generation 
1387                         always @ (posedge rd_clk) begin
1388                           if (rd_rst_i) begin
1389                             empty_fwft_i     &lt;= 1'b1;
1390                             empty_fwft_fb    &lt;= 1'b1;
1391                           end else begin
1392                             empty_fwft_i     &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1393                             empty_fwft_fb    &lt;= going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb);
1394                           end
1395                         end
1396                    
1397                         if (EN_AE == 1) begin : gae_fwft
1398                           reg going_aempty_fwft;
1399                           reg leaving_aempty_fwft;
1400                    
1401                           if (READ_MODE == 1) begin : gen_fwft_ae
1402                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1403                               case (curr_fwft_state)
1404                                 both_stages_valid : going_aempty_fwft = rd_en &amp; ram_empty_i;
1405                                 default      : going_aempty_fwft = 1'b0;
1406                               endcase
1407                             end
1408                           end : gen_fwft_ae
1409                           if (READ_MODE == 2) begin : gen_fwft_ae_ll
1410                             always @(curr_fwft_state or rd_en or ram_empty_i) begin
1411                               case (curr_fwft_state)
1412                                 stage1_valid : going_aempty_fwft = !rd_en &amp; ram_empty_i;
1413                                 default      : going_aempty_fwft = 1'b0;
1414                               endcase
1415                             end
1416                           end : gen_fwft_ae_ll
1417                    
1418                           always @(curr_fwft_state or rd_en or ram_empty_i) begin
1419                             case (curr_fwft_state)
1420                               stage1_valid : leaving_aempty_fwft = ~ram_empty_i;
1421                               stage2_valid : leaving_aempty_fwft = ~(rd_en | ram_empty_i);
1422                               default      : leaving_aempty_fwft = 1'b0;
1423                             endcase
1424                           end
1425                    
1426                           always @ (posedge rd_clk) begin
1427                             if (rd_rst_i) begin
1428                               aempty_fwft_i    &lt;= 1'b1;
1429                             end else begin
1430                               aempty_fwft_i    &lt;= going_aempty_fwft | (~ leaving_aempty_fwft &amp; aempty_fwft_i);
1431                             end
1432                           end
1433                         end : gae_fwft
1434                    
1435                         if (EN_DVLD == 1) begin : gdvld_fwft
1436                           always @ (posedge rd_clk) begin
1437                             if (rd_rst_i) begin
1438                               data_valid_fwft  &lt;= 1'b0;
1439                             end else begin
1440                               data_valid_fwft  &lt;= ~(going_empty_fwft | (~ leaving_empty_fwft &amp; empty_fwft_fb));
1441                             end
1442                           end
1443                         end : gdvld_fwft
1444                    
1445                        xpm_fifo_reg_bit #(0)
1446                          empty_fwft_d1_inst (1'b0, rd_clk, leaving_empty_fwft, empty_fwft_d1);
1447                    
1448                        wire ge_fwft_d1;
1449                        xpm_fifo_reg_bit #(0)
1450                          ge_fwft_d1_inst (1'b0, rd_clk, going_empty_fwft, ge_fwft_d1);
1451                    
1452                        wire count_up  ;
1453                        wire count_down;
1454                        wire count_en  ;
1455                        wire count_rst ;
1456                        assign count_up   = (next_fwft_state == 2'b10 &amp;&amp; ~|curr_fwft_state) | (curr_fwft_state == 2'b10 &amp;&amp; &amp;next_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; &amp;next_fwft_state);
1457                        assign count_down = (next_fwft_state == 2'b01 &amp;&amp; &amp;curr_fwft_state) | (curr_fwft_state == 2'b01 &amp;&amp; ~|next_fwft_state);
1458                        assign count_en   = count_up | count_down;
1459                        assign count_rst  = (rd_rst_i | (~|curr_fwft_state &amp; ~|next_fwft_state));
1460                    
1461                        xpm_counter_updn # (2, 0)
1462                          rdpp1_inst (count_rst, rd_clk, count_en, count_up, count_down, extra_words_fwft);
1463                    
1464                     
1465                      end : gen_fwft
1466                    
1467                      if (READ_MODE == 0) begin : ngen_fwft
1468                        assign le_fwft_re       = 1'b0;
1469                        assign le_fwft_fe       = 1'b0;
1470                        assign extra_words_fwft = 2'h0;
1471                      end : ngen_fwft
1472                    
1473                      // output data bus assignment
1474                      if (FG_EQ_ASYM_DOUT == 0) begin : nfg_eq_asym_dout
1475                        assign dout  = dout_i;
1476                      end : nfg_eq_asym_dout
1477                    
1478                      // Overflow and Underflow flag generation
1479                      if (EN_UF == 1) begin : guf
1480                        always @ (posedge rd_clk) begin
1481       1/1                underflow_i &lt;=  (rd_rst_i | empty_i) &amp; rd_en;
1482                        end
1483                        assign underflow   = underflow_i;
1484                      end : guf
1485                      if (EN_UF == 0) begin : gnuf
1486                        assign underflow   = 1'b0;
1487                      end : gnuf
1488                    
1489                      if (EN_OF == 1) begin : gof
1490                        always @ (posedge wr_clk) begin
1491       1/1               overflow_i  &lt;=  (wrst_busy | rst_d1 | ram_full_i) &amp; wr_en;
1492                        end
1493                        assign overflow    = overflow_i;
1494                      end : gof
1495                      if (EN_OF == 0) begin : gnof
1496                        assign overflow    = 1'b0;
1497                      end : gnof
1498                    
1499                      // -------------------------------------------------------------------------------------------------------------------
1500                      // Write Data Count for Independent Clocks FIFO
1501                      // -------------------------------------------------------------------------------------------------------------------
1502                      if (EN_WDC == 1) begin : gwdc
1503                        reg  [WR_DC_WIDTH_EXT-1:0] wr_data_count_i;
1504                        wire [WR_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr;
1505                        assign diff_wr_rd_pntr = wr_pntr_ext-rd_pntr_wr_adj_dc;
1506                        always @ (posedge wr_clk) begin
1507       1/1                if (wrst_busy)
1508       1/1                   wr_data_count_i   &lt;= {WR_DC_WIDTH_EXT{1'b0}};
1509                          else
1510       1/1                   wr_data_count_i  &lt;= diff_wr_rd_pntr;
1511                        end
1512                        assign wr_data_count = wr_data_count_i[WR_DC_WIDTH_EXT-1:WR_DC_WIDTH_EXT-WR_DATA_COUNT_WIDTH];
1513                      end : gwdc
1514                      if (EN_WDC == 0) begin : gnwdc
1515                        assign wr_data_count = {WR_DC_WIDTH_EXT{1'b0}};
1516                      end : gnwdc
1517                    
1518                      // -------------------------------------------------------------------------------------------------------------------
1519                      // Read Data Count for Independent Clocks FIFO
1520                      // -------------------------------------------------------------------------------------------------------------------
1521                      if (EN_RDC == 1) begin : grdc
1522                        reg  [RD_DC_WIDTH_EXT-1:0] rd_data_count_i;
1523                        wire [RD_DC_WIDTH_EXT-1:0] diff_wr_rd_pntr_rdc;
1524                        assign diff_wr_rd_pntr_rdc = wr_pntr_rd_adj_dc-rd_pntr_ext+extra_words_fwft;
1525                        always @ (posedge rd_clk) begin
1526       1/1                if (rd_rst_i | invalid_state)
1527       1/1                   rd_data_count_i   &lt;= {RD_DC_WIDTH_EXT{1'b0}};
1528                          else
1529       1/1                   rd_data_count_i  &lt;= diff_wr_rd_pntr_rdc;
1530                        end
1531                        assign rd_data_count = rd_data_count_i[RD_DC_WIDTH_EXT-1:RD_DC_WIDTH_EXT-RD_DATA_COUNT_WIDTH];
1532                      end : grdc
1533                      if (EN_RDC == 0) begin : gnrdc
1534                        assign rd_data_count = {RD_DC_WIDTH_EXT{1'b0}};
1535                      end : gnrdc
1536                    
1537                      endgenerate
1538                    
1539                      // -------------------------------------------------------------------------------------------------------------------
1540                      // Simulation constructs
1541                      // -------------------------------------------------------------------------------------------------------------------
1542                      // synthesis translate_off
1543                    
1544                     `ifndef DISABLE_XPM_ASSERTIONS  
1545                      initial begin
1546       2/2            #1;
1547       1/1              if (SIM_ASSERT_CHK == 1)
1548                        `ifdef OBSOLETE
1549                          $warning(&quot;Vivado Simulator does not currently support the SystemVerilog Assertion syntax used within XPM_FIFO.  \
1550                    Messages related to potential misuse will not be reported.&quot;);
1551                        `else
1552       <font color = "red">0/1     ==>        $warning(&quot;SIM_ASSERT_CHK (%0d) specifies simulation message reporting, messages related to potential misuse \</font>
                        MISSING_ELSE
</pre>
<hr>
<a name="inst_tag_272_Cond"></a>
<b>Cond Coverage for Instance : <a href="mod18.html#inst_tag_272" >AdaptedSharpener.fifo.lineBuffer_1.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table class="noborder">
<col width="122">
<col span="3" width="82">
<tr><th></th><th>Total</th><th>Covered</th><th>Percent</th></tr>
<tr class="s6"><td class="lf">Conditions</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="s6"><td class="lf">Logical</td><td>6</td><td>4</td><td>66.67</td></tr>
<tr class="wht"><td class="lf">Non-Logical</td><td>0</td><td>0</td><td></td></tr>
<tr class="wht"><td class="lf">Event</td><td>0</td><td>0</td><td></td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1084
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; read_only_q)
             ---------------1---------------    -----2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uGreen"><td>1</td><td>0</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>1</td><td class="lf">Not Covered</td></tr>
</table>
<br clear=all>
<pre class="code"> LINE       1086
 EXPRESSION ((diff_pntr_pe == PE_THRESH_ADJ) &amp;&amp; write_only_q)
             ---------------1---------------    ------2-----
</pre>
<table class="noborder">
<col span="2" width="40">
<tr><th>-1-</th><th>-2-</th><th>Status</th></tr>
<tr class="uGreen"><td>0</td><td>1</td><td class="lf">Covered</td></tr>
<tr class="uRed"><td>1</td><td>0</td><td class="lf">Not Covered</td></tr>
<tr class="uGreen"><td>1</td><td>1</td><td class="lf">Covered</td></tr>
</table>
<hr>
<a name="inst_tag_272_Toggle"></a>
<b>Toggle Coverage for Instance : <a href="mod18.html#inst_tag_272" >AdaptedSharpener.fifo.lineBuffer_1.xpm_fifo_sync_inst.xpm_fifo_base_inst</a></b><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80>Total</th><th nowrap width=80>Covered</th><th nowrap width=80>Percent</th></tr><tr class="s4">
<td>Totals</td>
<td class="rt">129</td>
<td class="rt">53</td>
<td class="rt">41.09 </td>
</tr><tr class="s7">
<td>Total Bits</td>
<td class="rt">864</td>
<td class="rt">611</td>
<td class="rt">70.72 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 0->1</td>
<td class="rt">432</td>
<td class="rt">307</td>
<td class="rt">71.06 </td>
</tr><tr class="s7">
<td nowrap>Total Bits 1->0</td>
<td class="rt">432</td>
<td class="rt">304</td>
<td class="rt">70.37 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s3">
<td>Ports</td>
<td class="rt">27</td>
<td class="rt">9</td>
<td class="rt">33.33 </td>
</tr><tr class="s8">
<td>Port Bits</td>
<td class="rt">178</td>
<td class="rt">146</td>
<td class="rt">82.02 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 0->1</td>
<td class="rt">89</td>
<td class="rt">72</td>
<td class="rt">80.90 </td>
</tr><tr class="s8">
<td nowrap>Port Bits 1->0</td>
<td class="rt">89</td>
<td class="rt">74</td>
<td class="rt">83.15 </td>
</tr></table><br clear=all>
<table align=left class="noborder">
<tr>
<th nowrap width=120></th><th nowrap width=80></th><th nowrap width=80></th><th nowrap width=80></th></tr><tr class="s4">
<td>Signals</td>
<td class="rt">102</td>
<td class="rt">44</td>
<td class="rt">43.14 </td>
</tr><tr class="s6">
<td>Signal Bits</td>
<td class="rt">686</td>
<td class="rt">465</td>
<td class="rt">67.78 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 0->1</td>
<td class="rt">343</td>
<td class="rt">235</td>
<td class="rt">68.51 </td>
</tr><tr class="s6">
<td nowrap>Signal Bits 1->0</td>
<td class="rt">343</td>
<td class="rt">230</td>
<td class="rt">67.06 </td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Port Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td><td class="alfsrt">Direction</td></tr><tr>
<td>sleep</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>rst</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>wr_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>wr_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>din[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_data_count</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>overflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>wr_ack</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_clk</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>rd_en</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>INPUT</td>
</tr><tr>
<td>dout[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>empty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>prog_empty</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_data_count</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>underflow</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>rd_rst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td>OUTPUT</td>
</tr><tr>
<td>almost_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>data_valid</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>injectsbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>injectdbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>INPUT</td>
</tr><tr>
<td>sbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr><tr>
<td>dbiterr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td>OUTPUT</td>
</tr></table><br clear=all>
<table align=left class="sortable noborder">
<caption><b>Signal Details</b></caption>
<tr class="sortablehead">
<td class="alfsrt">Name</td><td class="alfsrt">Toggle</td><td class="alfsrt">Toggle 1->0</td><td class="alfsrt">Toggle 0->1</td></tr><tr>
<td>curr_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>next_fwft_state[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrst_busy</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_rd[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus2[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus3[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_pntr_plus1_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_inv_pf[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pf_q[6:1]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf_q[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pf[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_ext[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_cdc_dc[7:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_pntr_wr_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_rd_adj_dc[7:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus1[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_plus2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>invalid_state</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>going_aempty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_aempty</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_empty_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_aempty_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>going_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_full</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>going_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_afull</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>prog_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_full_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_afull_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_full_n</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_ack_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rd_en_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_en_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_regce_pipe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>dout_i[31:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>aempty_fwft_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>empty_fwft_fb</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>overflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>underflow_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_fwft</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_valid_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>data_vld_std</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_gt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wrp_lt_rdp_and_red</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_wr_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_wr_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>ram_rd_en_pf</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>wr_pntr_plus1_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_pntr_wr_adj_pf_carry</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_allow</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>write_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>read_only_q</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe_reg1[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe_reg2[6:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>diff_pntr_pe[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>diff_pntr_pe[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>prog_empty_i</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>ram_empty_i_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>fe_of_empty</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_en_i</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>wr_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_i</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rd_rst_d2</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>rst_d1</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>rst_d2</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>clr_full</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>empty_fwft_d1</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>leaving_empty_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>extra_words_fwft[1:0]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_re_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>le_fwft_fe_wr</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gen_sdpram.rst_int</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[6:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.wr_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>gwdc.diff_wr_rd_pntr[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.rd_data_count_i[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.rd_data_count_i[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.rd_data_count_i[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[5:0]</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[6]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s9 cl">Yes</td>
</tr><tr>
<td>grdc.diff_wr_rd_pntr_rdc[7]</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
<td class="s3 cl">No</td>
</tr></table><br clear=all>
</div>
</div>
<div class="ui-layout-center-inner-north">
<div id="center-bread-crumb" class="breadCrumb module urg-margin-bottom">
  <ul name="inst_tag_271">
    <li>
      <a href="#inst_tag_271_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_271_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_271_Toggle">Toggle</a>    </li>
  </ul>
  <ul name="inst_tag_272">
    <li>
      <a href="#inst_tag_272_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_272_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_272_Toggle">Toggle</a>    </li>
  </ul>
  <ul name="inst_tag_273">
    <li>
      <a href="#inst_tag_273_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_273_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_273_Toggle">Toggle</a>    </li>
  </ul>
  <ul name="inst_tag_274">
    <li>
      <a href="#inst_tag_274_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_274_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_274_Toggle">Toggle</a>    </li>
  </ul>
  <ul name="inst_tag_275">
    <li>
      <a href="#inst_tag_275_Line">Line</a>    </li>
    <li>
      <a href="#inst_tag_275_Cond">Cond</a>    </li>
    <li>
      <a href="#inst_tag_275_Toggle">Toggle</a>    </li>
  </ul>
  <ul name="tag_\XPM.xpm_fifo_base ">
    <li>
      <a href="#Line">Line</a>    </li>
    <li>
      <a href="#Cond">Cond</a>    </li>
    <li>
      <a href="#Toggle">Toggle</a>    </li>
  </ul>
</div>
</div>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
