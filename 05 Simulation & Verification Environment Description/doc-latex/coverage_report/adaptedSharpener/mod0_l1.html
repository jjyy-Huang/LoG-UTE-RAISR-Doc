<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="Author" content="<username>"> <meta name="GENERATOR" content="urg/version [en] (platform name) [urg]">
<title>Unified Coverage Report :: Line split page</title>
<link type="text/css" rel="stylesheet" href="css/.urg.css">
<link type="text/css" rel="stylesheet" href="css/.layout.css">
<script type="text/javascript" src="js/.jquery.js"></script>
<script type="text/javascript" src="js/.jquery-ui.js"></script>
<script type="text/javascript" src="js/.sortable.js"></script>
<script type="text/javascript" src="js/.colResizable.js"></script>
<script type="text/javascript" src="js/.layout.js"></script>
<script type="text/javascript">
var layout, westLayout, centerLayout;
$(document).ready(function () {
  layout = $("body").layout({ 
    resizable: true,
    spacing_open: 4,
    spacing_closed: 4,
    north: {
      size: 76
    },
    south: {
      size: 45,
      initClosed: true
    }  });
  $("table").colResizable({    liveDrag:true,
    fixed:false,
    draggingClass:"dragging"
  });
});
</script>
</head>
<body><div class="ui-layout-north">
<div class="logo"></div>
<center class="pagetitle">Line split page</center>
<div align="center"><a href="dashboard.html" ><b>dashboard</b></a> | <a href="hierarchy.html" ><b>hierarchy</b></a> | <a href="modlist.html" ><b>modlist</b></a> | groups | <a href="tests.html" ><b>tests</b></a> | asserts</div>

</div>
<div class="ui-layout-center">
Go <a href="mod0.html#l1">back</a>
<pre class="code"><br clear=all>
298                         reg drc_err_flag;
299        1/1              drc_err_flag = 0;
300        2/2              #1;
301                     
302                         // notification and restrictions
303        1/1              if (1) 
304        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTA_READ &amp;&amp; WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_A &amp;&amp; `NO_ECC) begin
305        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_A (%0d) for this configuration which uses port A write and read operations, but this release of XPM_MEMORY requires symmetric write and read data widths within each enabled port. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 2, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_A);</font>
306        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
307                         end
                        MISSING_ELSE
                   <font color = "red">==>  MISSING_ELSE</font>
308        1/1              if (`MEM_PORTB_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; WRITE_DATA_WIDTH_B != READ_DATA_WIDTH_B &amp;&amp; `NO_ECC) begin
309        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_B (%0d) does not equal READ_DATA_WIDTH_B (%0d) for this configuration which uses port B write and read operations, but this release of XPM_MEMORY requires symmetric write and read data widths within each enabled port. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 3, WRITE_DATA_WIDTH_B, READ_DATA_WIDTH_B);</font>
310        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
311                         end
                        MISSING_ELSE
312                         
313        1/1              if (`MEM_TYPE_RAM_SDP &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_B) begin
314        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_B (%0d) for this simple dual port RAM configuration with memory primitive set to distributed RAM, but this release of XPM_MEMORY requires symmetric write and read data widths when memory primitive set to distributed RAM. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 13, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_B);</font>
315        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
316                         end
                        MISSING_ELSE
317                     
318        1/1              if (`MEM_TYPE_RAM_TDP &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_B) begin
319        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_B (%0d) for this true dual port RAM configuration with memory primitive set to distributed RAM, but this release of XPM_MEMORY requires symmetric write and read data widths when memory primitive set to distributed RAM. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 14, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_B);</font>
320        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
321                         end
                        MISSING_ELSE
322                     
323        1/1              if (`MEM_TYPE_ROM_DP &amp;&amp; READ_DATA_WIDTH_A != READ_DATA_WIDTH_B) begin
324        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_B (%0d) for this dual port ROM configuration , but this release of XPM_MEMORY requires symmetric read data widths when memory type is set to dual port ROM. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 15, READ_DATA_WIDTH_A, READ_DATA_WIDTH_B);</font>
325        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
326                         end
                        MISSING_ELSE
327                     
328        1/1              if (CASCADE_HEIGHT &gt; 64 &amp;&amp; `MEM_PRIM_ULTRA) begin
329        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] XPM_MEMORY does not support CASCADE_HEIGHT (%0d) greater than 64 for Ultra RAM configurations. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 16, CASCADE_HEIGHT);</font>
330        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
331                         end
                        MISSING_ELSE
332                     
333        1/1              if (CASCADE_HEIGHT &gt; 16 &amp;&amp; `MEM_PRIM_BLOCK) begin
334        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] XPM_MEMORY does not support CASCADE_HEIGHT (%0d) greater than 16 for Block RAM configurations. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 16, CASCADE_HEIGHT);</font>
335        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
336                         end 
                        MISSING_ELSE
337                     
338        1/1              if (!`NO_ECC &amp;&amp; !`NO_MEMORY_INIT) begin
339        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Memory initialization is specified for this configuration with ECC (%0d) enabled, but this release of XPM_MEMORY does not support ECC with memory Initialization . %m&quot;, &quot;XPM_MEMORY&quot;, 1, 18, ECC_MODE);</font>
340        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
341                         end
                        MISSING_ELSE
342                         
343        1/1              if (!`NO_ECC &amp;&amp; `MEM_TYPE_ROM) begin
344        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Memory type is set to ROM for this configuration with ECC (%0d) enabled, but this release of XPM_MEMORY does not support ECC with memory Initialization . %m&quot;, &quot;XPM_MEMORY&quot;, 1, 19, ECC_MODE);</font>
345        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
346                         end
                        MISSING_ELSE
347                         
348        1/1              if  (`MEM_PORT_ASYM_BWE &amp;&amp; !`NO_MEMORY_INIT) begin
349        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Asymmetry with Byte Write Enable is specified with Memory initialization, but this release of XPM_MEMORY does not support Memory initialization with Asymmetric Byte Write Enable. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 21);</font>
350        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
351                         end
                        MISSING_ELSE
352                     
353        1/1              if (`MEM_PORT_ASYM_BWE &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; (`SLEEP_MODE || `MEM_AUTO_SLP_EN)) begin
354        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration has UltraRAM,Asymmetric ports with Byte Write Enable with Sleep Mode or Auto Sleep Mode enabled, but this release of XPM_MEMORY does not support the specified configuration. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 20);</font>
355        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
356                         end
                        MISSING_ELSE
357                     
358        1/1              if ((`MEM_PRIM_AUTO || `MEM_PRIM_BLOCK || `MEM_PRIM_ULTRA) &amp;&amp; USE_EMBEDDED_CONSTRAINT) begin
359        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] USE_EMBEDDED_CONSTRAINT is set to (%0d), but Embedded Constraint is supported only for distributed RAM with separate write and read clocks. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 22, USE_EMBEDDED_CONSTRAINT);</font>
360        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
361                         end
                        MISSING_ELSE
362                     
363        1/1              if ((`MEM_PORT_ASYM_BWE &amp;&amp; `MEM_TYPE_RAM_SDP &amp;&amp; `MEM_PORTA_WR_BYTE &amp;&amp; (WRITE_DATA_WIDTH_B%BYTE_WRITE_WIDTH_A != 0)) || (`MEM_PORT_ASYM_BWE &amp;&amp; `MEM_TYPE_RAM_TDP &amp;&amp; `MEM_PORTA_WR_BYTE &amp;&amp; (BYTE_WRITE_WIDTH_B%BYTE_WRITE_WIDTH_A != 0)) || (`MEM_PORT_ASYM_BWE &amp;&amp; `MEM_TYPE_RAM_TDP &amp;&amp; `MEM_PORTB_WR_BYTE &amp;&amp; (BYTE_WRITE_WIDTH_A%BYTE_WRITE_WIDTH_B != 0))) begin
364        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Asymmetry with Byte Write Enable is specified, but the write data width and byte write width of port A and port B are not compatible. If byte write is enabled on port A, then data width of port B must be divisible by Port A byte write width, and vice versa. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 23);</font>
365        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
366                         end
                        MISSING_ELSE
367                     
368        1/1              if (`MEM_AUTO_SLP_EN &amp;&amp; `MEM_TYPE_RAM_SDP &amp;&amp; `MEM_PORTB_WF &amp;&amp; (READ_LATENCY_B &lt; 4) ) begin
369        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] This configuration has Simple Dual Port RAM, UltraRAM, Write First Mode with Non-Zero Auto Sleep value and READ_LATENCY_B (%0d) value less than 4. But in this release of XPM_MEMORY does not support READ_LATENCY_B value less than 4 for the specified configuration. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 24, READ_LATENCY_B);</font>
370        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
371                         end
                        MISSING_ELSE
372                     
373        1/1              if (`MEM_AUTO_SLP_EN &amp;&amp; `MEM_TYPE_RAM_SDP &amp;&amp; `MEM_PORTB_RF &amp;&amp; (READ_LATENCY_B &lt; 3)) begin
374        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] This configuration has Simple Dual Port RAM, UltraRAM, Read First Mode with Non-Zero Auto Sleep value and READ_LATENCY_B (%0d) value less than 3. But in this release of XPM_MEMORY does not support READ_LATENCY_B value less than 3 for the specified configuration. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 25, READ_LATENCY_B);</font>
375        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
376                         end
                        MISSING_ELSE
377                     
378        1/1              if (`MEM_AUTO_SLP_EN &amp;&amp; `MEM_TYPE_RAM_SP &amp;&amp; (READ_LATENCY_A &lt; 3)) begin
379        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] This configuration has Single Port RAM, UltraRAM with Non-Zero Auto Sleep value and READ_LATENCY_A (%0d) value less than 3. But in this release of XPM_MEMORY does not support READ_LATENCY_A value less than 3 for the specified configuration. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 26, READ_LATENCY_A);</font>
380        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
381                         end
                        MISSING_ELSE
382                     
383        1/1              if (`MEM_AUTO_SLP_EN &amp;&amp; `MEM_TYPE_RAM_TDP &amp;&amp; (READ_LATENCY_A &lt; 3)) begin
384        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] This configuration has True Dual Port RAM, UltraRAM with Non-Zero Auto Sleep value and READ_LATENCY_A (%0d) value less than 3. But in this release of XPM_MEMORY does not support READ_LATENCY_A value less than 3 for the specified configuration. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 27, READ_LATENCY_A);</font>
385        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
386                         end
                        MISSING_ELSE
387                     
388        1/1              if (`MEM_AUTO_SLP_EN &amp;&amp; `MEM_TYPE_RAM_TDP &amp;&amp; (READ_LATENCY_B &lt; 3)) begin
389        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] This configuration has True Dual Port RAM, UltraRAM with Non-Zero Auto Sleep value and READ_LATENCY_B (%0d) value less than 3. But in this release of XPM_MEMORY does not support READ_LATENCY_B value less than 3 for the specified configuration. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 28, READ_LATENCY_B);</font>
390        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
391                         end
                        MISSING_ELSE
392                     
393        1/1              if ((WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_B) &amp;&amp; `MEM_TYPE_RAM_SDP &amp;&amp; `MEM_PORTB_WF) begin
394        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] This configuration has Simple Dual Port RAM, Port-B Write First Mode with WRITE_DATA_WIDTH_A (%0d) not equal to READ_DATA_WIDTH_B (%0d). But in this release of XPM_MEMORY does not support the specified configuration. %m&quot;, &quot;XPM_MEMORY&quot;, 1, 29, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_B);</font>
395        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
396                         end
                        MISSING_ELSE
397                     
398                     
399                         // Range checks
400        1/1              if (!(MEMORY_TYPE == 0 || MEMORY_TYPE == 1 || MEMORY_TYPE == 2 || MEMORY_TYPE == 3 || MEMORY_TYPE == 4)) begin
401        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_TYPE (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 10, 1, MEMORY_TYPE);</font>
402        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
403                         end
                        MISSING_ELSE
404        1/1              if (!(MEMORY_SIZE &gt; 0)) begin
405        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 10, 2, MEMORY_SIZE);</font>
406        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
407                         end
                        MISSING_ELSE
408                         //if ((MEMORY_SIZE &gt; 150994944 )) begin
409                         //  $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) value exceeds the maximum supported size. %m&quot;, &quot;XPM_MEMORY&quot;, 10, 11, MEMORY_SIZE);
410                         //  drc_err_flag = 1;
411                         //end
412        1/1              if (!(MEMORY_PRIMITIVE == 0 || MEMORY_PRIMITIVE == 1 || MEMORY_PRIMITIVE == 2 || MEMORY_PRIMITIVE == 3 || MEMORY_PRIMITIVE == 4)) begin
413        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_PRIMITIVE (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 10, 3, MEMORY_PRIMITIVE);</font>
414        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
415                         end
                        MISSING_ELSE
416        1/1              if (!(CLOCKING_MODE == 0 || CLOCKING_MODE == 1)) begin
417        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CLOCKING_MODE (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 10, 4, CLOCKING_MODE);</font>
418        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
419                         end
                        MISSING_ELSE
420        1/1              if (!(ECC_MODE == 0 || ECC_MODE == 1 || ECC_MODE == 2 || ECC_MODE == 3)) begin
421        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] ECC_MODE (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 10, 5, ECC_MODE);</font>
422        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
423                         end
                        MISSING_ELSE
424        1/1              if (!(WAKEUP_TIME == 0 || WAKEUP_TIME == 2)) begin
425        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WAKEUP_TIME (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 10, 7, WAKEUP_TIME);</font>
426        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
427                         end
                        MISSING_ELSE
428        1/1              if (!(MESSAGE_CONTROL == 0 || MESSAGE_CONTROL == 1)) begin
429        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MESSAGE_CONTROL (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 10, 8, MESSAGE_CONTROL);</font>
430        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
431                         end
                        MISSING_ELSE
432        1/1              if (!(VERSION == 0)) begin
433        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] VERSION (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 10, 9, VERSION);</font>
434        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
435                         end
                        MISSING_ELSE
436        1/1              if (!(AUTO_SLEEP_TIME == 0 || (AUTO_SLEEP_TIME &gt;=3 &amp;&amp; AUTO_SLEEP_TIME &lt; 16))) begin
437        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] AUTO_SLEEP_TIME (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 10, 10, AUTO_SLEEP_TIME);</font>
438        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
439                         end
                        MISSING_ELSE
440        1/1              if (!(WRITE_DATA_WIDTH_A &gt; 0)) begin
441        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 15, 1, WRITE_DATA_WIDTH_A);</font>
442        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
443                         end
                        MISSING_ELSE
444        1/1              if (!(READ_DATA_WIDTH_A &gt; 0)) begin
445        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_A (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 15, 2, READ_DATA_WIDTH_A);</font>
446        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
447                         end
                        MISSING_ELSE
448        1/1              if (!(BYTE_WRITE_WIDTH_A == 8 || BYTE_WRITE_WIDTH_A == 9 || BYTE_WRITE_WIDTH_A == WRITE_DATA_WIDTH_A)) begin
449        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] BYTE_WRITE_WIDTH_A (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 15, 3, BYTE_WRITE_WIDTH_A);</font>
450        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
451                         end
                        MISSING_ELSE
452        1/1              if (!(ADDR_WIDTH_A &gt; 0)) begin
453        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] ADDR_WIDTH_A (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 15, 4, ADDR_WIDTH_A);</font>
454        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
455                         end
                        MISSING_ELSE
456        1/1              if (!(READ_LATENCY_A &gt;= 0)) begin
457        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_LATENCY_A (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 15, 6, READ_LATENCY_A);</font>
458        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
459                         end
                        MISSING_ELSE
460        1/1              if (!(WRITE_MODE_A == 0 || WRITE_MODE_A == 1 || WRITE_MODE_A == 2)) begin
461        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_MODE_A (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 15, 7, WRITE_MODE_A);</font>
462        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
463                         end
                        MISSING_ELSE
464        1/1              if (!(WRITE_DATA_WIDTH_B &gt; 0)) begin
465        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_B (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 16, 1, WRITE_DATA_WIDTH_B);</font>
466        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
467                         end
                        MISSING_ELSE
468        1/1              if (!(READ_DATA_WIDTH_B &gt; 0)) begin
469        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_B (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 16, 2, READ_DATA_WIDTH_B);</font>
470        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
471                         end
                        MISSING_ELSE
472        1/1              if (!(BYTE_WRITE_WIDTH_B == 8 || BYTE_WRITE_WIDTH_B == 9 || BYTE_WRITE_WIDTH_B == WRITE_DATA_WIDTH_B)) begin
473        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] BYTE_WRITE_WIDTH_B (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 16, 3, BYTE_WRITE_WIDTH_B);</font>
474        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
475                         end
                        MISSING_ELSE
476        1/1              if (!(ADDR_WIDTH_B &gt; 0)) begin
477        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] ADDR_WIDTH_B (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 16, 4, ADDR_WIDTH_B);</font>
478        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
479                         end
                        MISSING_ELSE
480        1/1              if (!(READ_LATENCY_B &gt;= 0)) begin
481        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_LATENCY_B (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 16, 6, READ_LATENCY_B);</font>
482        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
483                         end
                        MISSING_ELSE
484        1/1              if (!(WRITE_MODE_B == 0 || WRITE_MODE_B == 1 || WRITE_MODE_B == 2)) begin
485        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_MODE_B (%0d) value is outside of legal range. %m&quot;, &quot;XPM_MEMORY&quot;, 16, 7, WRITE_MODE_B);</font>
486        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
487                         end
                        MISSING_ELSE
488                     
489                         // Infos
490        1/1              if (`MEM_PRIM_AUTO)
491        1/1                $info(&quot;[%s %0d-%0d] MEMORY_PRIMITIVE (%0d) instructs Vivado Synthesis to choose the memory primitive type. Depending on their values, other XPM_MEMORY parameters may preclude the choice of certain memory primitive types. Review XPM_MEMORY documentation and parameter values to understand any limitations, or set MEMORY_PRIMITIVE to a different value. %m&quot;, &quot;XPM_MEMORY&quot;, 20, 1, MEMORY_PRIMITIVE);
                   <font color = "red">==>  MISSING_ELSE</font>
492        1/1              if (`NO_MEMORY_INIT &amp;&amp; !`MEM_PRIM_ULTRA &amp;&amp; `EN_INIT_MESSAGE)
493        <font color = "red">0/1     ==>        $info(&quot;[%s %0d-%0d] MEMORY_INIT_FILE (%0s), MEMORY_INIT_PARAM together specify no memory initialization. Initial memory contents will be all 0's. %m&quot;, &quot;XPM_MEMORY&quot;, 20, 2, MEMORY_INIT_FILE,MEMORY_INIT_PARAM);</font>
                        MISSING_ELSE
494        1/1              if (`COMMON_CLOCK &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; `MEM_TYPE_RAM_TDP)
495        <font color = "red">0/1     ==>        $info(&quot;[%s %0d-%0d] XPM_MEMORY behaviorally models the port operation ordering of true dual port UltraRAM configurations by slightly delaying the common clock for port B operations only. Refer to UltraRAM documentation for details. %m&quot;, &quot;XPM_MEMORY&quot;, 20, 3);</font>
                        MISSING_ELSE
496        1/1              if (AUTO_SLEEP_TIME != 0 &amp;&amp; `MEM_PRIM_ULTRA) begin
497        <font color = "red">0/1     ==>        $info(&quot;[%s %0d-%0d] Non-zero AUTO_SLEEP_TIME (%0d) is specifed for this configuration, An input pipeline having the number of register stages equal to AUTO_SLEEP_TIME will be introduced on all the input control/data signals path except for the port-enables(en[a|b]) and reset(rst[a|b]). %m&quot;, &quot;XPM_MEMORY&quot;, 20, 4, AUTO_SLEEP_TIME);</font>
498                         end
                        MISSING_ELSE
499                     
500                         // Warnings
501        1/1              if (`MEM_TYPE_ROM &amp;&amp; `NO_MEMORY_INIT)
502        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] MEMORY_INIT_FILE (%0s) specifies no memory initialization file for this ROM configuration, which will result in an empty memory that may be optimized away. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 1, MEMORY_INIT_FILE);</font>
                        MISSING_ELSE
503        1/1              if (`MEM_TYPE_ROM &amp;&amp; WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_A)
504        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default WRITE_DATA_WIDTH_A (%0d) value ignored for ROM configurations because write operations are not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 2, WRITE_DATA_WIDTH_A);</font>
                        MISSING_ELSE
505        1/1              if (`MEM_TYPE_RAM_SDP &amp;&amp; READ_DATA_WIDTH_A != WRITE_DATA_WIDTH_A)
506        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default READ_DATA_WIDTH_A (%0d) value ignored for simple dual port RAM configurations because port A read operations are not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 3, READ_DATA_WIDTH_A);</font>
                        MISSING_ELSE
507        1/1              if (`MEM_TYPE_ROM &amp;&amp; BYTE_WRITE_WIDTH_A != WRITE_DATA_WIDTH_A)
508        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default BYTE_WRITE_WIDTH_A (%0d) value ignored for ROM configurations because write operations are not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 4, BYTE_WRITE_WIDTH_A);</font>
                        MISSING_ELSE
509        1/1              if (`MEM_TYPE_RAM_SDP &amp;&amp; READ_RESET_VALUE_A != &quot;0&quot;)
510        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default READ_RESET_VALUE_A value ignored for simple dual port RAM configurations because port A read operations are not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 5);</font>
                        MISSING_ELSE
511        1/1              if (`MEM_TYPE_RAM_SDP &amp;&amp; READ_LATENCY_A != 2)
512        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default READ_LATENCY_A (%0d) value ignored for simple dual port RAM configurations because port A read operations are not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 6, READ_LATENCY_A);</font>
                        MISSING_ELSE
513        1/1              if (`MEM_TYPE_RAM_SP &amp;&amp; WRITE_DATA_WIDTH_B != WRITE_DATA_WIDTH_A)
514        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default WRITE_DATA_WIDTH_B (%0d) value ignored for single port RAM configurations because port B write operations are not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 7, WRITE_DATA_WIDTH_B);</font>
                        MISSING_ELSE
515        1/1              if ((`MEM_TYPE_RAM_SDP || (`MEM_TYPE_RAM_TDP &amp;&amp; `MEM_PRIM_DISTRIBUTED) || `MEM_TYPE_ROM) &amp;&amp; WRITE_DATA_WIDTH_B != READ_DATA_WIDTH_B)
516        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default WRITE_DATA_WIDTH_B (%0d) value ignored for simple dual port RAM, dual port distributed RAM, or ROM configurations because port B write operations are not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 8, WRITE_DATA_WIDTH_B);</font>
                        MISSING_ELSE
517        1/1              if ((`MEM_TYPE_RAM_SP || `MEM_TYPE_ROM_SP) &amp;&amp; READ_DATA_WIDTH_B != READ_DATA_WIDTH_A)
518        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default READ_DATA_WIDTH_B (%0d) value ignored for single port RAM or single port ROM configurations because port B is not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 9, READ_DATA_WIDTH_B);</font>
                        MISSING_ELSE
519        1/1              if ((`MEM_TYPE_RAM_SP || `MEM_TYPE_RAM_SDP || (`MEM_TYPE_RAM_TDP &amp;&amp; `MEM_PRIM_DISTRIBUTED) || `MEM_TYPE_ROM) &amp;&amp; BYTE_WRITE_WIDTH_B != WRITE_DATA_WIDTH_B)
520        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default BYTE_WRITE_WIDTH_B (%0d) value ignored for single port RAM, simple dual port RAM, dual port distributed RAM, or ROM configurations because port B write operations are not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 10, BYTE_WRITE_WIDTH_B);</font>
                        MISSING_ELSE
521        1/1              if ((`MEM_TYPE_RAM_SP || `MEM_TYPE_ROM_SP) &amp;&amp; ADDR_WIDTH_B != $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_B))
522        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default ADDR_WIDTH_B (%0d) value ignored for single port RAM or single port ROM configurations because port B is not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 11, ADDR_WIDTH_B);</font>
                        MISSING_ELSE
523        1/1              if ((`MEM_TYPE_RAM_SP || `MEM_TYPE_ROM_SP) &amp;&amp; READ_RESET_VALUE_B != &quot;0&quot;)
524        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default READ_RESET_VALUE_B value ignored for single port RAM or single port ROM configurations because port B is not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 12);</font>
                        MISSING_ELSE
525        1/1              if ((`MEM_TYPE_RAM_SP || `MEM_TYPE_ROM_SP) &amp;&amp; READ_LATENCY_B != READ_LATENCY_A)
526        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default READ_LATENCY_B (%0d) value ignored for single port RAM or single port ROM configurations because port B is not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 13, READ_LATENCY_B);</font>
                        MISSING_ELSE
527        1/1              if ((`MEM_TYPE_RAM_SP || `MEM_TYPE_ROM) &amp;&amp; WRITE_MODE_B != WRITE_MODE_A)
528        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default WRITE_MODE_B (%0d) value ignored for single port RAM or ROM configurations because port B write operations are not used. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 14, WRITE_MODE_B);</font>
                        MISSING_ELSE
529        1/1              if (`MEM_TYPE_RAM_TDP &amp;&amp; `MEM_PRIM_DISTRIBUTED)
530        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] MEMORY_TYPE (%0d) and MEMORY_PRIMITIVE (%0d) together specify a true dual port distributed RAM, which will be mapped to a dual port RAM structure using port A and B read interfaces but a single port A write interface, leaving the port B write interface unused. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 15, MEMORY_TYPE, MEMORY_PRIMITIVE);</font>
                        MISSING_ELSE
531        1/1              if (`MEM_PORTA_WRITE &amp;&amp; $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_A) &lt; ADDR_WIDTH_A)
532        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), WRITE_DATA_WIDTH_A (%0d), and ADDR_WIDTH_A (%0d) together imply that the addressable range exceeds the memory size for this configuration which uses port A write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 16, MEMORY_SIZE, WRITE_DATA_WIDTH_A, ADDR_WIDTH_A);</font>
                        MISSING_ELSE
533        1/1              if (`MEM_PORTA_READ &amp;&amp; $clog2(MEMORY_SIZE/READ_DATA_WIDTH_A) &lt; ADDR_WIDTH_A)
534        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), READ_DATA_WIDTH_A (%0d), and ADDR_WIDTH_A (%0d) together imply that the addressable range exceeds the memory size for this configuration which uses port A read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 17, MEMORY_SIZE, READ_DATA_WIDTH_A, ADDR_WIDTH_A);</font>
                        MISSING_ELSE
535        1/1              if (`MEM_PORTB_WRITE &amp;&amp; $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_B) &lt; ADDR_WIDTH_B)
536        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), WRITE_DATA_WIDTH_B (%0d), and ADDR_WIDTH_B (%0d) together imply that the addressable range exceeds the memory size for this configuration which uses port B write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 18, MEMORY_SIZE, WRITE_DATA_WIDTH_B, ADDR_WIDTH_B);</font>
                        MISSING_ELSE
537        1/1              if (`MEM_PORTB_READ &amp;&amp; $clog2(MEMORY_SIZE/READ_DATA_WIDTH_B) &lt; ADDR_WIDTH_B)
538        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), READ_DATA_WIDTH_B (%0d), and ADDR_WIDTH_B (%0d) together imply that the addressable range exceeds the memory size for this configuration which uses port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 19, MEMORY_SIZE, READ_DATA_WIDTH_B, ADDR_WIDTH_B);</font>
                        MISSING_ELSE
539        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTA_READ &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_A)
540        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_A (%0d) for this distributed RAM configuration configuration which uses port A write and read operations, resulting in inefficient use of memory resources. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 20, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_A);</font>
                        MISSING_ELSE
541        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_B)
542        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_B (%0d) for this distributed RAM configuration configuration which uses port A write and port B read operations, resulting in inefficient use of memory resources. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 21, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_B);</font>
                        MISSING_ELSE
543        1/1              if (`MEM_PORTA_READ &amp;&amp; `MEM_PORTB_READ &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; READ_DATA_WIDTH_A != READ_DATA_WIDTH_B)
544        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] READ_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_B (%0d) for this distributed memory configuration which uses port A and port B read operations, resulting in inefficient use of memory resources. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 22, READ_DATA_WIDTH_A, READ_DATA_WIDTH_B);</font>
                        MISSING_ELSE
545        1/1              if (`MEM_PORTA_READ &amp;&amp; `MEM_PORTA_RD_COMB &amp;&amp; READ_RESET_VALUE_A != &quot;0&quot;)
546        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default READ_RESET_VALUE_A value ignored for this configuration which uses port A read operations, because READ_LATENCY_A (%0d) specifies a combinatorial read output. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 23, READ_LATENCY_A);</font>
                        MISSING_ELSE
547        1/1              if (`MEM_PORTB_READ &amp;&amp; `MEM_PORTB_RD_COMB &amp;&amp; READ_RESET_VALUE_B != &quot;0&quot;)
548        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] Non-default READ_RESET_VALUE_B value ignored for this configuration which uses port B read operations, because READ_LATENCY_B (%0d) specifies a combinatorial read output. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 24, READ_LATENCY_B);</font>
                        MISSING_ELSE
549        1/1              if (`REPORT_MESSAGES &amp;&amp; (`MEM_TYPE_RAM_SDP || `MEM_TYPE_RAM_TDP) &amp;&amp; !(`MEM_PRIM_DISTRIBUTED || `MEM_PRIM_ULTRA))
550        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] MESSAGE_CONTROL (%0d) specifies simulation message reporting, but any potential collisions reported for this configuration should be further investigated in netlist timing simulations for improved accuracy. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 25, MESSAGE_CONTROL);</font>
                        MISSING_ELSE
551        1/1              if (WRITE_DATA_WIDTH_A &gt; 4608 || READ_DATA_WIDTH_A &gt; 4608)
552        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] This configuration has WRITE_DATA_WIDTH_A of (%0d) and  READ_DATA_WIDTH_A of (%0d), but in this release of XPM_MEMORY, the configurations having write/read data widths greater than 4608 are not completely verified. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 26, WRITE_DATA_WIDTH_A,READ_DATA_WIDTH_A);</font>
                        MISSING_ELSE
553        1/1              if (WRITE_DATA_WIDTH_B &gt; 4608 || READ_DATA_WIDTH_B &gt; 4608)
554        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] This configuration has WRITE_DATA_WIDTH_B of (%0d) and  READ_DATA_WIDTH_B (%0d), but in this release of XPM_MEMORY, the configurations having write/read data widths greater than 4608 are not completely verified. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 27 , WRITE_DATA_WIDTH_B,READ_DATA_WIDTH_B);</font>
                        MISSING_ELSE
555        1/1              if ( `MEM_TYPE_RAM_TDP &amp;&amp; (BYTE_WRITE_WIDTH_A == 8 || BYTE_WRITE_WIDTH_A == 9) &amp;&amp; (READ_DATA_WIDTH_B == BYTE_WRITE_WIDTH_B &amp;&amp; WRITE_DATA_WIDTH_B == BYTE_WRITE_WIDTH_B) &amp;&amp; (READ_DATA_WIDTH_B % BYTE_WRITE_WIDTH_A != 0 || WRITE_DATA_WIDTH_B % BYTE_WRITE_WIDTH_A != 0))
556        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] This configuration has byte wide writes on port-A and port-B does not have byte wide writes, but in this release of XPM_MEMORY, the configurations having byte wide writes on one port and other port not having byte wide writes is not completely verified. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 28);</font>
                        MISSING_ELSE
557        1/1              if ( `MEM_TYPE_RAM_TDP &amp;&amp; (BYTE_WRITE_WIDTH_B == 8 || BYTE_WRITE_WIDTH_B == 9) &amp;&amp; (READ_DATA_WIDTH_A == BYTE_WRITE_WIDTH_A &amp;&amp; WRITE_DATA_WIDTH_A == BYTE_WRITE_WIDTH_A) &amp;&amp; (READ_DATA_WIDTH_A % BYTE_WRITE_WIDTH_B != 0 || WRITE_DATA_WIDTH_A % BYTE_WRITE_WIDTH_B != 0))
558        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] This configuration has byte wide writes on port-B and port-A does not have byte wide writes, but in this release of XPM_MEMORY, the configurations having byte wide writes on one port and other port not having byte wide writes is not completely verified. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 29);</font>
                        MISSING_ELSE
559        1/1            if (AUTO_SLEEP_TIME != 0  &amp;&amp; `MEM_PORTA_READ &amp;&amp; READ_LATENCY_A == 2)
560        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] The configuration specified is having non-zero Auto Sleep latency value with READ_LATENCY_A parameter value set to 2; There could be simulation mismatches between behavioral and post-synthesis simulations, please run netlist simulations for improved accuracy. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 30);</font>
                        MISSING_ELSE
561        1/1            if (AUTO_SLEEP_TIME != 0  &amp;&amp; `MEM_PORTB_READ &amp;&amp; READ_LATENCY_B == 2)
562        <font color = "red">0/1     ==>        $warning(&quot;[%s %0d-%0d] The configuration specified is having non-zero Auto Sleep latency value with READ_LATENCY_B  parameter value set to 2; There could be simulation mismatches between behavioral and post-synthesis simulations, please run netlist simulations for improved accuracy. %m&quot;, &quot;XPM_MEMORY&quot;, 30, 31);</font>
                        MISSING_ELSE
563                     
564                         // Errors
565        1/1              if ((`MEM_TYPE_RAM_SP || `MEM_TYPE_ROM_SP) &amp;&amp; `INDEPENDENT_CLOCKS) begin
566        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CLOCKING_MODE (%0d) specifies independent clocks, but single port RAM or single port ROM configurations require a common clock. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 2, CLOCKING_MODE);</font>
567        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
568                         end
                        MISSING_ELSE
569        1/1              if (`MEM_PRIM_ULTRA &amp;&amp; `INDEPENDENT_CLOCKS) begin
570        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] CLOCKING_MODE (%0d) specifies independent clocks, but UltraRAM configurations require a common clock. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 3, CLOCKING_MODE);</font>
571        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
572                         end
                        MISSING_ELSE
573        1/1              if (`MEM_PORTA_READ &amp;&amp; (`MEM_PRIM_BLOCK || `MEM_PRIM_ULTRA) &amp;&amp; `MEM_PORTA_RD_COMB) begin
574        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_LATENCY_A (%0d) specifies a combinatorial read output for this configuration which uses port A read operations, but at least one register stage is required for block memory or UltraRAM configurations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 5, READ_LATENCY_A);</font>
575        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
576                         end
                        MISSING_ELSE
577        1/1              if (`MEM_PORTB_READ &amp;&amp; (`MEM_PRIM_BLOCK || `MEM_PRIM_ULTRA) &amp;&amp; `MEM_PORTB_RD_COMB) begin
578        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_LATENCY_B (%0d) specifies a combinatorial read output for this configuration which uses port B read operations, but at least one register stage is required for block memory or UltraRAM configurations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 6, READ_LATENCY_B);</font>
579        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
580                         end
                        MISSING_ELSE
581        1/1              if (`MEM_TYPE_RAM_SDP &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; !`MEM_PORTB_RF &amp;&amp; !`MEM_PORTB_WF) begin
582        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_MODE_B (%0d) specifies no-change mode, but simple dual port RAM configurations targeting UltraRAM can only mimic read-first mode or write-first mode behaviour for port B. Please change WRITE_MODE_B to either read-first mode or write-first mode. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 8, WRITE_MODE_B);</font>
583        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
584                         end
                        MISSING_ELSE
585        1/1              if (`MEM_TYPE_RAM_SDP &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; `MEM_PORTB_WF &amp;&amp; !`MEM_PORTB_URAM_LAT) begin
586        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_LATENCY_B (%0d) specifies fewer than 3 stages, but simple dual port RAM configurations targeting UltraRAM and using write-first mode for port B must use a read latency of at least 3 for port B. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 9, READ_LATENCY_B);</font>
587        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
588                         end
                        MISSING_ELSE
589        1/1              if (`MEM_TYPE_ROM &amp;&amp; !`MEM_PORTA_RF) begin
590        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_MODE_A (%0d) specifies write-first mode or no-change mode, but ROM configurations must use read-first mode for port A. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 10, WRITE_MODE_A);</font>
591        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
592                         end
                        MISSING_ELSE
593        1/1              if (`MEM_TYPE_ROM_DP &amp;&amp; !`MEM_PORTB_RF) begin
594        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_MODE_B (%0d) specifies write-first mode or no-change mode, but dual port ROM configurations must use read-first mode for port B. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 11, WRITE_MODE_B);</font>
595        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
596                         end
                        MISSING_ELSE
597        1/1              if ((`MEM_TYPE_RAM_SP || `MEM_TYPE_RAM_TDP) &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; !`MEM_PORTA_RF) begin
598        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_MODE_A (%0d) specifies write-first mode or no-change mode, but single port and dual port distributed RAM configurations must use read-first mode for port A. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 12, WRITE_MODE_A);</font>
599        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
600                         end
                        MISSING_ELSE
601        1/1              if (`MEM_TYPE_RAM_TDP &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; !`MEM_PORTB_RF) begin
602        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_MODE_B (%0d) specifies write-first mode or no-change mode, but dual port distributed RAM configurations must use read-first mode for port B. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 13, WRITE_MODE_B);</font>
603        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
604                         end
                        MISSING_ELSE
605        1/1              if (`MEM_TYPE_RAM_TDP &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; !`MEM_PORTA_NC) begin
606        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_MODE_A (%0d) specifies read-first mode or write-first mode, but true dual port UltraRAM configurations must use no-change mode for port A. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 14, WRITE_MODE_A);</font>
607        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
608                         end
                        MISSING_ELSE
609        1/1              if (`MEM_TYPE_RAM_TDP &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; !`MEM_PORTB_NC) begin
610        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_MODE_B (%0d) specifies read-first mode or write-first mode, but true dual port UltraRAM configurations must use no-change mode for port B. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 15, WRITE_MODE_B);</font>
611        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
612                         end
                        MISSING_ELSE
613        1/1              if (`MEM_PORTA_WRITE &amp;&amp; MEMORY_SIZE % WRITE_DATA_WIDTH_A != 0 &amp;&amp; `NO_ECC) begin
614        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of WRITE_DATA_WIDTH_A (%0d) for this configuration which uses port A write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 16, MEMORY_SIZE, WRITE_DATA_WIDTH_A);</font>
615        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
616                         end
                        MISSING_ELSE
617        1/1              if (`MEM_PORTA_READ &amp;&amp; MEMORY_SIZE % READ_DATA_WIDTH_A != 0 &amp;&amp; `NO_ECC) begin
618        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of READ_DATA_WIDTH_A (%0d) for this configuration which uses port A read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 17, MEMORY_SIZE, READ_DATA_WIDTH_A);</font>
619        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
620                         end
                        MISSING_ELSE
621        1/1              if (`MEM_PORTB_WRITE &amp;&amp; MEMORY_SIZE % WRITE_DATA_WIDTH_B != 0 &amp;&amp; `NO_ECC) begin
622        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of WRITE_DATA_WIDTH_B (%0d) for this configuration which uses port B write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 18, MEMORY_SIZE, WRITE_DATA_WIDTH_B);</font>
623        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
624                         end
                        MISSING_ELSE
625        1/1              if (`MEM_PORTB_READ &amp;&amp; MEMORY_SIZE % READ_DATA_WIDTH_B != 0 &amp;&amp; `NO_ECC) begin
626        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of READ_DATA_WIDTH_B (%0d) for this configuration which uses port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 19, MEMORY_SIZE, READ_DATA_WIDTH_B);</font>
627        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
628                         end
                        MISSING_ELSE
629        1/1              if (`MEM_PORTA_WRITE &amp;&amp; $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_A) &gt; ADDR_WIDTH_A &amp;&amp; `NO_ECC) begin
630        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), WRITE_DATA_WIDTH_A (%0d), and ADDR_WIDTH_A (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port A write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 20, MEMORY_SIZE, WRITE_DATA_WIDTH_A, ADDR_WIDTH_A);</font>
631        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
632                         end
                        MISSING_ELSE
633        1/1              if (`MEM_PORTA_READ &amp;&amp; $clog2(MEMORY_SIZE/READ_DATA_WIDTH_A) &gt; ADDR_WIDTH_A &amp;&amp; `NO_ECC) begin
634        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), READ_DATA_WIDTH_A (%0d), and ADDR_WIDTH_A (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port A read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 21, MEMORY_SIZE, READ_DATA_WIDTH_A, ADDR_WIDTH_A);</font>
635        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
636                         end
                        MISSING_ELSE
637        1/1              if (`MEM_PORTA_WRITE &amp;&amp; MEMORY_SIZE/WRITE_DATA_WIDTH_A &lt; 2 &amp;&amp; `NO_ECC) begin
638        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and WRITE_DATA_WIDTH_A (%0d) imply that the memory is not at least two words from the perspective of port A write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 22, MEMORY_SIZE, WRITE_DATA_WIDTH_A);</font>
639        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
640                         end
                        MISSING_ELSE
641        1/1              if (`MEM_PORTA_READ &amp;&amp; MEMORY_SIZE/READ_DATA_WIDTH_A &lt; 2 &amp;&amp; `NO_ECC) begin
642        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and READ_DATA_WIDTH_A (%0d) imply that the memory is not at least two words from the perspective of port A read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 23, MEMORY_SIZE, READ_DATA_WIDTH_A);</font>
643        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
644                         end
                        MISSING_ELSE
645        1/1              if (`MEM_PORTB_WRITE &amp;&amp; $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_B) &gt; ADDR_WIDTH_B &amp;&amp; `NO_ECC) begin
646        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), WRITE_DATA_WIDTH_B (%0d), and ADDR_WIDTH_B (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port B write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 24, MEMORY_SIZE, WRITE_DATA_WIDTH_B, ADDR_WIDTH_B);</font>
647        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
648                         end
                        MISSING_ELSE
649        1/1              if (`MEM_PORTB_READ &amp;&amp; $clog2(MEMORY_SIZE/READ_DATA_WIDTH_B) &gt; ADDR_WIDTH_B &amp;&amp; `NO_ECC) begin
650        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), READ_DATA_WIDTH_B (%0d), and ADDR_WIDTH_B (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 25, MEMORY_SIZE, READ_DATA_WIDTH_B, ADDR_WIDTH_B);</font>
651        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
652                         end
                        MISSING_ELSE
653        1/1              if (`MEM_PORTB_WRITE &amp;&amp; MEMORY_SIZE/WRITE_DATA_WIDTH_B &lt; 2 &amp;&amp; `NO_ECC) begin
654        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and WRITE_DATA_WIDTH_B (%0d) imply that the memory is not at least two words from the perspective of port B write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 26, MEMORY_SIZE, WRITE_DATA_WIDTH_B);</font>
655        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
656                         end
                        MISSING_ELSE
657        1/1              if (`MEM_PORTB_READ &amp;&amp; MEMORY_SIZE/READ_DATA_WIDTH_B &lt; 2 &amp;&amp; `NO_ECC) begin
658        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and READ_DATA_WIDTH_B (%0d) imply that the memory is not at least two words from the perspective of port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 27, MEMORY_SIZE, READ_DATA_WIDTH_B);</font>
659        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
660                         end
                        MISSING_ELSE
661        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTA_READ &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_A &amp;&amp; `NO_ECC) begin
662        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_A (%0d) for this configuration which uses port A write and read operations, but symmetric port widths are required for UltraRAM configurations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 28, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_A);</font>
663        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
664                         end
                        MISSING_ELSE
665        1/1              if (`MEM_PORTB_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; WRITE_DATA_WIDTH_B != READ_DATA_WIDTH_B &amp;&amp; `NO_ECC) begin
666        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_B (%0d) does not equal READ_DATA_WIDTH_B (%0d) for this configuration which uses port B write and read operations, but symmetric port widths are required for UltraRAM configurations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 31, WRITE_DATA_WIDTH_B, READ_DATA_WIDTH_B);</font>
667        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
668                         end
                        MISSING_ELSE
669        1/1              if (`MEM_PORTA_READ &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; rst_val_conv_a(READ_RESET_VALUE_A) != 0) begin
670        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_RESET_VALUE_A is nonzero for this configuration which uses port A read operations, but UltraRAM configurations require a zero-valued output register reset. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 33);</font>
671        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
672                         end
                        MISSING_ELSE
673        1/1              if (`MEM_PORTB_READ &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; rst_val_conv_b(READ_RESET_VALUE_B) != 0) begin
674        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_RESET_VALUE_B is nonzero for this configuration which uses port B read operations, but UltraRAM configurations require a zero-valued output register reset. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 34);</font>
675        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
676                         end
                        MISSING_ELSE
677        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTA_READ  &amp;&amp; `NO_ECC &amp;&amp; !(WRITE_DATA_WIDTH_A == 32*READ_DATA_WIDTH_A || WRITE_DATA_WIDTH_A == 16*READ_DATA_WIDTH_A || WRITE_DATA_WIDTH_A == 8*READ_DATA_WIDTH_A || WRITE_DATA_WIDTH_A == 4*READ_DATA_WIDTH_A || WRITE_DATA_WIDTH_A == 2*READ_DATA_WIDTH_A || WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_A || 32*WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_A || 16*WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_A || 8*WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_A || 4*WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_A || 2*WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_A)) begin
678        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The ratio of WRITE_DATA_WIDTH_A (%0d) to READ_DATA_WIDTH_A (%0d) is not within the legal range of 32, 16, 8, 4, 2, 1, 1/2, 1/4, 1/8, 1/16, or 1/32 for this configuration which uses port A write and read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 35, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_A);</font>
679        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
680                         end
                        MISSING_ELSE
681        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `NO_ECC  &amp;&amp; !(WRITE_DATA_WIDTH_A == 32*READ_DATA_WIDTH_B || WRITE_DATA_WIDTH_A == 16*READ_DATA_WIDTH_B || WRITE_DATA_WIDTH_A == 8*READ_DATA_WIDTH_B || WRITE_DATA_WIDTH_A == 4*READ_DATA_WIDTH_B || WRITE_DATA_WIDTH_A == 2*READ_DATA_WIDTH_B || WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_B || 32*WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_B || 16*WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_B || 8*WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_B || 4*WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_B || 2*WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_B)) begin
682        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The ratio of WRITE_DATA_WIDTH_A (%0d) to READ_DATA_WIDTH_B (%0d) is not within the legal range of 32, 16, 8, 4, 2, 1, 1/2, 1/4, 1/8, 1/16, or 1/32 for this configuration which uses port A write and port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 36, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_B);</font>
683        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
684                         end
                        MISSING_ELSE
685        1/1              if (`MEM_PORTB_WRITE &amp;&amp; `MEM_PORTA_READ &amp;&amp; `NO_ECC  &amp;&amp; !(WRITE_DATA_WIDTH_B == 32*READ_DATA_WIDTH_A || WRITE_DATA_WIDTH_B == 16*READ_DATA_WIDTH_A || WRITE_DATA_WIDTH_B == 8*READ_DATA_WIDTH_A || WRITE_DATA_WIDTH_B == 4*READ_DATA_WIDTH_A || WRITE_DATA_WIDTH_B == 2*READ_DATA_WIDTH_A || WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_A || 32*WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_A || 16*WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_A || 8*WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_A || 4*WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_A || 2*WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_A)) begin
686        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The ratio of WRITE_DATA_WIDTH_B (%0d) to READ_DATA_WIDTH_A (%0d) is not within the legal range of 32, 16, 8, 4, 2, 1, 1/2, 1/4, 1/8, 1/16, or 1/32 for this configuration which uses port B write and port A read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 37, WRITE_DATA_WIDTH_B, READ_DATA_WIDTH_A);</font>
687        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
688                         end
                        MISSING_ELSE
689        1/1              if (`MEM_PORTB_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `NO_ECC  &amp;&amp; !(WRITE_DATA_WIDTH_B == 32*READ_DATA_WIDTH_B || WRITE_DATA_WIDTH_B == 16*READ_DATA_WIDTH_B || WRITE_DATA_WIDTH_B == 8*READ_DATA_WIDTH_B || WRITE_DATA_WIDTH_B == 4*READ_DATA_WIDTH_B || WRITE_DATA_WIDTH_B == 2*READ_DATA_WIDTH_B || WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_B || 32*WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_B || 16*WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_B || 8*WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_B || 4*WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_B || 2*WRITE_DATA_WIDTH_B == READ_DATA_WIDTH_B)) begin
690        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The ratio of WRITE_DATA_WIDTH_B (%0d) to READ_DATA_WIDTH_B (%0d) is not within the legal range of 32, 16, 8, 4, 2, 1, 1/2, 1/4, 1/8, 1/16, or 1/32 for this configuration which uses port B write and read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 38, WRITE_DATA_WIDTH_B, READ_DATA_WIDTH_B);</font>
691        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
692                         end
                        MISSING_ELSE
693        1/1              if (`MEM_PORTA_READ &amp;&amp; `MEM_PORTB_READ &amp;&amp; `NO_ECC  &amp;&amp; !(READ_DATA_WIDTH_A == 32*READ_DATA_WIDTH_A || READ_DATA_WIDTH_A == 16*READ_DATA_WIDTH_A || READ_DATA_WIDTH_A == 8*READ_DATA_WIDTH_A || READ_DATA_WIDTH_A == 4*READ_DATA_WIDTH_A || READ_DATA_WIDTH_A == 2*READ_DATA_WIDTH_A || READ_DATA_WIDTH_A == READ_DATA_WIDTH_A || 32*READ_DATA_WIDTH_A == READ_DATA_WIDTH_A || 16*READ_DATA_WIDTH_A == READ_DATA_WIDTH_A || 8*READ_DATA_WIDTH_A == READ_DATA_WIDTH_A || 4*READ_DATA_WIDTH_A == READ_DATA_WIDTH_A || 2*READ_DATA_WIDTH_A == READ_DATA_WIDTH_A)) begin
694        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The ratio of READ_DATA_WIDTH_A (%0d) to READ_DATA_WIDTH_B (%0d) is not within the legal range of 32, 16, 8, 4, 2, 1, 1/2, 1/4, 1/8, 1/16, or 1/32 for this configuration which uses port A and port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 39, READ_DATA_WIDTH_A, READ_DATA_WIDTH_B);</font>
695        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
696                         end
                        MISSING_ELSE
697        1/1              if (`MEM_PORTA_WRITE &amp;&amp; WRITE_DATA_WIDTH_A % BYTE_WRITE_WIDTH_A != 0) begin
698        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] BYTE_WRITE_WIDTH_A (%0d) does not result in an integer number of bytes within the specified WRITE_DATA_WIDTH_A (%0d) for this configuration which uses port A write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 40, BYTE_WRITE_WIDTH_A, WRITE_DATA_WIDTH_A);</font>
699        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
700                         end
                        MISSING_ELSE
701        1/1              if (`MEM_PORTB_WRITE &amp;&amp; WRITE_DATA_WIDTH_B % BYTE_WRITE_WIDTH_B != 0) begin
702        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] BYTE_WRITE_WIDTH_B (%0d) does not result in an integer number of bytes within the specified WRITE_DATA_WIDTH_B (%0d) for this configuration which uses port B write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 41, BYTE_WRITE_WIDTH_B, WRITE_DATA_WIDTH_B);</font>
703        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
704                         end
                        MISSING_ELSE
705        1/1              if (32'(MEMORY_INIT_FILE) == &quot;.coe&quot; || 32'(MEMORY_INIT_FILE) == &quot;.COE&quot;) begin
706        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_INIT_FILE (%0s) specifies a file with a .coe extension, but XPM_MEMORY does not support the COE file format. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 43, MEMORY_INIT_FILE);</font>
707        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
708                         end
                        MISSING_ELSE
709        1/1              if ( (`MEM_PRIM_AUTO || `MEM_PRIM_DISTRIBUTED) &amp;&amp;  (WAKEUP_TIME != 0)) begin
710        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Wake up time of (%0d) is not valid when the Memory Primitive is set to %d.&quot;, &quot;XPM_MEMORY&quot;, 40, 42, WAKEUP_TIME,MEMORY_PRIMITIVE);</font>
711        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
712                         end 
                        MISSING_ELSE
713        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTA_READ &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_A) begin
714        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_A (%0d) for this configuration which uses port A write and read operations, but symmetric port widths are required for Distributed RAM configurations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 44, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_A);</font>
715        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
716                         end
                        MISSING_ELSE
717        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_B) begin
718        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_B (%0d) for this configuration which uses port A write and port B read operations, but symmetric port widths are required for Distributed RAM configurations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 45, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_B);</font>
719        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
720                         end
                        MISSING_ELSE
721        1/1              if (`MEM_PORTB_WRITE &amp;&amp; `MEM_PORTA_READ &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; WRITE_DATA_WIDTH_B != READ_DATA_WIDTH_A) begin
722        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_B (%0d) does not equal READ_DATA_WIDTH_A (%0d) for this configuration which uses port B write and port A read operations, but symmetric port widths are required for Distributed RAM configurations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 46, WRITE_DATA_WIDTH_B, READ_DATA_WIDTH_A);</font>
723        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
724                         end
                        MISSING_ELSE
725        1/1              if (`MEM_PORTB_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; WRITE_DATA_WIDTH_B != READ_DATA_WIDTH_B) begin
726        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_B (%0d) does not equal READ_DATA_WIDTH_B (%0d) for this configuration which uses port B write and read operations, but symmetric port widths are required for Distributed RAM configurations. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 47, WRITE_DATA_WIDTH_B, READ_DATA_WIDTH_B);</font>
727        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
728                         end
                        MISSING_ELSE
729        1/1              if ((MEMORY_INIT_FILE != &quot;none&quot; &amp;&amp; MEMORY_INIT_FILE != &quot;NONE&quot; &amp;&amp; MEMORY_INIT_FILE != &quot;None&quot;) &amp;&amp; MEMORY_SIZE &gt; 192*1024*1024) begin
730        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Memory size of (%0d) is specified for this configuration with memory initialization, but XPM_MEMORY supports initialization up to 5 million bits only. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 48, MEMORY_SIZE);</font>
731        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
732                         end
                        MISSING_ELSE
733        1/1              if (`MEM_TYPE_RAM_SDP &amp;&amp; `MEM_PRIM_DISTRIBUTED &amp;&amp; !`MEM_PORTB_RF) begin
734        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_MODE_B (%0d) specifies write-first or no-change mode , but Simple Dual port distributed RAM configurations must use read-first mode for port B. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 49, WRITE_MODE_B);</font>
735        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
736                         end
                        MISSING_ELSE
737        1/1              if (`MEM_TYPE_RAM_SDP &amp;&amp; `MEM_PRIM_BLOCK &amp;&amp; !(`MEM_PORTB_RF || `MEM_PORTB_NC)) begin
738        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_MODE_B (%0d) specifies write-first mode , but Simple Dual port block RAM configurations must use read-first mode for port B. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 50, WRITE_MODE_B);</font>
739        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
740                         end
                        MISSING_ELSE
741        1/1              if ((MEMORY_INIT_PARAM != &quot;&quot; &amp;&amp; MEMORY_INIT_PARAM != &quot;0&quot;) &amp;&amp; MEMORY_SIZE &gt; 4*1024) begin
742        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Memory size of (%0d) is specified for this configuration with memory initialization through parameter, but XPM_MEMORY supports initialization through parameter up to memory size of 4k bits only. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 51, MEMORY_SIZE);</font>
743        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
744                         end
                        MISSING_ELSE
745        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTB_WRITE &amp;&amp; `MEM_PORTA_WR_BYTE &amp;&amp; `MEM_PORTB_WR_BYTE &amp;&amp; (BYTE_WRITE_WIDTH_A != BYTE_WRITE_WIDTH_B)) begin
746        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] BYTE_WRITE_WIDTH_A (%0d) does not equal BYTE_WRITE_WIDTH_B (%0d) for this configuration which uses port A byte wide write and port B byte wide write operations, but symmetric byte write widths are required for this configuration. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 52, BYTE_WRITE_WIDTH_A, BYTE_WRITE_WIDTH_B);</font>
747        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
748                         end
                        MISSING_ELSE
749                     
750        1/1              if (!(32'(MEMORY_INIT_FILE) == &quot;.mem&quot; || 32'(MEMORY_INIT_FILE) == &quot;.MEM&quot;) &amp;&amp; (MEMORY_INIT_FILE != &quot;none&quot; &amp;&amp; MEMORY_INIT_FILE != &quot;NONE&quot; &amp;&amp; MEMORY_INIT_FILE != &quot;None&quot;) ) begin
751        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_INIT_FILE (%0s) specified a file without .mem extension, but XPM_MEMORY supports Initialization files with MEM file format only. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 53, MEMORY_INIT_FILE);</font>
752        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
753                         end
                        MISSING_ELSE
754                     
755                     // DRCs related to ECC
756        1/1              if (!(`NO_ECC) &amp;&amp; !(`MEM_PRIM_BLOCK || `MEM_PRIM_ULTRA)) begin
757        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has ECC_MODE(%0d) parameter is set to a non-zero value and the MEMORY_PRIMITIVE(%0d) specified is other than BlockRAM or UltraRAM, but ECC feature is supported only when the MEMORY_PRIMITIVE is set to either BlockRAM or UltraRAM . %m&quot;, &quot;XPM_MEMORY&quot;, 41, 1, ECC_MODE, MEMORY_PRIMITIVE);</font>
758        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
759                         end
                        MISSING_ELSE
760                     
761        1/1              if (!(`NO_ECC) &amp;&amp; `MEM_PRIM_BLOCK &amp;&amp; !`MEM_TYPE_RAM_SDP) begin
762        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has ECC_MODE(%0d) parameter is set to a non-zero value, MEMORY_PRIMITIVE(%0d) set to BlockRAM and MEMORY_TYPE(%0d) specified is other than Simple Dual port RAM , but ECC feature is supported only when the MEMORY_TYPE is set to simple Dual port RAM . %m&quot;, &quot;XPM_MEMORY&quot;, 41, 2, ECC_MODE, MEMORY_PRIMITIVE, MEMORY_TYPE);</font>
763        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
764                         end
                        MISSING_ELSE
765                     
766        1/1              if (!(`NO_ECC) &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; !(`MEM_TYPE_RAM_SP || `MEM_TYPE_RAM_SDP || `MEM_TYPE_RAM_TDP)) begin
767        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has ECC_MODE(%0d) parameter is set to a non-zero value, MEMORY_PRIMITIVE(%0d) set to  ultraRAM and MEMORY_TYPE(%0d) specified is other than Simple Dual port RAM , but ECC feature is supported only when the MEMORY_TYPE is set to simple Dual port RAM . %m&quot;, &quot;XPM_MEMORY&quot;, 41, 3, ECC_MODE, MEMORY_PRIMITIVE, MEMORY_TYPE);</font>
768        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
769                         end
                        MISSING_ELSE
770                     
771                     // Both_Enc_Dec
772        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTA_READ &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_A &amp;&amp; `BOTH_ENC_DEC) begin
773        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_A (%0d) for this configuration which uses port A write and read operations with ECC mode(both encode and decode) enabled, but this configuration requires symmetric write and read data widths within each enabled port. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 4, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_A);</font>
774        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
775                         end
                        MISSING_ELSE
776        1/1              if (`MEM_PORTB_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; WRITE_DATA_WIDTH_B != READ_DATA_WIDTH_B &amp;&amp; `BOTH_ENC_DEC) begin
777        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_B (%0d) does not equal READ_DATA_WIDTH_B (%0d) for this configuration which uses port B write and read operations with ECC(both encode and decode) enabled, but this configuration requires symmetric write and read data widths within each enabled port. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 5, WRITE_DATA_WIDTH_B, READ_DATA_WIDTH_B);</font>
778        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
779                         end
                        MISSING_ELSE
780        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `MEM_TYPE_RAM_SDP &amp;&amp; WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_B &amp;&amp; `BOTH_ENC_DEC) begin
781        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_B (%0d) for this configuration which uses port A write and port B read operations with ECC(both encode and decode) enabled, but this configuration requires symmetric write and read data widths across each enabled port. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 6, WRITE_DATA_WIDTH_A, READ_DATA_WIDTH_B);</font>
782        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
783                         end
                        MISSING_ELSE
784                     
785        1/1              if (`MEM_PORTA_WRITE &amp;&amp; WRITE_DATA_WIDTH_A%64 != 0 &amp;&amp; `BOTH_ENC_DEC) begin
786        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) is not a multiple of 64 for this configuration which uses port A write with ECC mode(both encode and decode) enabled, but this configuration requires write ddata width to be multiple of 64. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 7, WRITE_DATA_WIDTH_A);</font>
787        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
788                         end
                        MISSING_ELSE
789        1/1              if (`MEM_PORTA_READ &amp;&amp; READ_DATA_WIDTH_A%64 != 0 &amp;&amp; `BOTH_ENC_DEC) begin
790        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_A (%0d) is not a multiple of 64 for this configuration which uses port A write with ECC mode(both encode and decode) enabled, but this configuration requires write ddata width to be multiple of 64. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 8, READ_DATA_WIDTH_A);</font>
791        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
792                         end
                        MISSING_ELSE
793        1/1              if (`MEM_PORTB_WRITE &amp;&amp; WRITE_DATA_WIDTH_B%64 != 0 &amp;&amp; `BOTH_ENC_DEC) begin
794        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_B (%0d) is not a multiple of 64 for this configuration which uses port A write with ECC mode(both encode and decode) enabled, but this configuration requires write ddata width to be multiple of 64. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 9, WRITE_DATA_WIDTH_B);</font>
795        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
796                         end
                        MISSING_ELSE
797        1/1              if (`MEM_PORTB_READ &amp;&amp; READ_DATA_WIDTH_B%64 != 0 &amp;&amp; `BOTH_ENC_DEC) begin
798        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_B (%0d) is not a multiple of 64 for this configuration which uses port A write with ECC mode(both encode and decode) enabled, but this configuration requires write ddata width to be multiple of 64. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 10, READ_DATA_WIDTH_B);</font>
799        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
800                         end
                        MISSING_ELSE
801                     
802        1/1              if (`MEM_PORTA_WRITE &amp;&amp; MEMORY_SIZE % WRITE_DATA_WIDTH_A != 0 &amp;&amp; `BOTH_ENC_DEC) begin
803        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of WRITE_DATA_WIDTH_A (%0d) for this configuration which uses port A write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 11, MEMORY_SIZE, WRITE_DATA_WIDTH_A);</font>
804        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
805                         end
                        MISSING_ELSE
806        1/1              if (`MEM_PORTA_READ &amp;&amp; MEMORY_SIZE % READ_DATA_WIDTH_A != 0 &amp;&amp; `BOTH_ENC_DEC) begin
807        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of READ_DATA_WIDTH_A (%0d) for this configuration which uses port A read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 12, MEMORY_SIZE, READ_DATA_WIDTH_A);</font>
808        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
809                         end
                        MISSING_ELSE
810        1/1              if (`MEM_PORTB_WRITE &amp;&amp; MEMORY_SIZE % WRITE_DATA_WIDTH_B != 0 &amp;&amp; `BOTH_ENC_DEC) begin
811        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of WRITE_DATA_WIDTH_B (%0d) for this configuration which uses port B write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 13, MEMORY_SIZE, WRITE_DATA_WIDTH_B);</font>
812        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
813                         end
                        MISSING_ELSE
814        1/1              if (`MEM_PORTB_READ &amp;&amp; MEMORY_SIZE % READ_DATA_WIDTH_B != 0 &amp;&amp; `BOTH_ENC_DEC) begin
815        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of READ_DATA_WIDTH_B (%0d) for this configuration which uses port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 14, MEMORY_SIZE, READ_DATA_WIDTH_B);</font>
816        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
817                         end
                        MISSING_ELSE
818        1/1              if (`MEM_PORTA_WRITE &amp;&amp; $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_A) &gt; ADDR_WIDTH_A &amp;&amp; `BOTH_ENC_DEC) begin
819        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), WRITE_DATA_WIDTH_A (%0d), and ADDR_WIDTH_A (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port A write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 15, MEMORY_SIZE, WRITE_DATA_WIDTH_A, ADDR_WIDTH_A);</font>
820        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
821                         end
                        MISSING_ELSE
822        1/1              if (`MEM_PORTA_READ &amp;&amp; $clog2(MEMORY_SIZE/READ_DATA_WIDTH_A) &gt; ADDR_WIDTH_A &amp;&amp; `BOTH_ENC_DEC) begin
823        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), READ_DATA_WIDTH_A (%0d), and ADDR_WIDTH_A (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port A read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 16, MEMORY_SIZE, READ_DATA_WIDTH_A, ADDR_WIDTH_A);</font>
824        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
825                         end
                        MISSING_ELSE
826        1/1              if (`MEM_PORTA_WRITE &amp;&amp; MEMORY_SIZE/WRITE_DATA_WIDTH_A &lt; 2 &amp;&amp; `BOTH_ENC_DEC) begin
827        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and WRITE_DATA_WIDTH_A (%0d) imply that the memory is not at least two words from the perspective of port A write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 17, MEMORY_SIZE, WRITE_DATA_WIDTH_A);</font>
828        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
829                         end
                        MISSING_ELSE
830        1/1              if (`MEM_PORTA_READ &amp;&amp; MEMORY_SIZE/READ_DATA_WIDTH_A &lt; 2 &amp;&amp; `BOTH_ENC_DEC) begin
831        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and READ_DATA_WIDTH_A (%0d) imply that the memory is not at least two words from the perspective of port A read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 18, MEMORY_SIZE, READ_DATA_WIDTH_A);</font>
832        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
833                         end
                        MISSING_ELSE
834        1/1              if (`MEM_PORTB_WRITE &amp;&amp; $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_B) &gt; ADDR_WIDTH_B &amp;&amp; `BOTH_ENC_DEC) begin
835        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), WRITE_DATA_WIDTH_B (%0d), and ADDR_WIDTH_B (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port B write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 19, MEMORY_SIZE, WRITE_DATA_WIDTH_B, ADDR_WIDTH_B);</font>
836        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
837                         end
                        MISSING_ELSE
838        1/1              if (`MEM_PORTB_READ &amp;&amp; $clog2(MEMORY_SIZE/READ_DATA_WIDTH_B) &gt; ADDR_WIDTH_B &amp;&amp; `BOTH_ENC_DEC) begin
839        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), READ_DATA_WIDTH_B (%0d), and ADDR_WIDTH_B (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 20, MEMORY_SIZE, READ_DATA_WIDTH_B, ADDR_WIDTH_B);</font>
840        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
841                         end
                        MISSING_ELSE
842        1/1              if (`MEM_PORTB_WRITE &amp;&amp; MEMORY_SIZE/WRITE_DATA_WIDTH_B &lt; 2 &amp;&amp; `BOTH_ENC_DEC) begin
843        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and WRITE_DATA_WIDTH_B (%0d) imply that the memory is not at least two words from the perspective of port B write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 21, MEMORY_SIZE, WRITE_DATA_WIDTH_B);</font>
844        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
845                         end
                        MISSING_ELSE
846        1/1              if (`MEM_PORTB_READ &amp;&amp; MEMORY_SIZE/READ_DATA_WIDTH_B &lt; 2 &amp;&amp; `BOTH_ENC_DEC) begin
847        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and READ_DATA_WIDTH_B (%0d) imply that the memory is not at least two words from the perspective of port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 22, MEMORY_SIZE, READ_DATA_WIDTH_B);</font>
848        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
849                         end
                        MISSING_ELSE
850                     
851                     // Enc_Only
852        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTA_READ &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; READ_DATA_WIDTH_A != (WRITE_DATA_WIDTH_A + (WRITE_DATA_WIDTH_A/64)*8) &amp;&amp; `ENC_ONLY) begin
853        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_A (%0d) does not equal WRITE_DATA_WIDTH_A + number of syndrome bits (%0d) for this configuration which uses port A write and read operations with ECC mode(encode only) enabled, but this configuration requires symmetric write and read data widths within each enabled port. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 50, READ_DATA_WIDTH_A, (WRITE_DATA_WIDTH_A + (WRITE_DATA_WIDTH_A/64)*8));</font>
854        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
855                         end
                        MISSING_ELSE
856        1/1              if (`MEM_PORTB_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; READ_DATA_WIDTH_B != (WRITE_DATA_WIDTH_B + (WRITE_DATA_WIDTH_B/64)*8) &amp;&amp; `ENC_ONLY) begin
857        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_B (%0d) does not equal WRITE_DATA_WIDTH_B + number of syndrome bits (%0d) for this configuration which uses port B write and read operations with ECC(encode only) enabled, but this configuration requires symmetric write and read data widths within each enabled port. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 51, READ_DATA_WIDTH_B, (WRITE_DATA_WIDTH_B + (WRITE_DATA_WIDTH_B/64)*8));</font>
858        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
859                         end
                        MISSING_ELSE
860        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `MEM_TYPE_RAM_SDP &amp;&amp; READ_DATA_WIDTH_B != (WRITE_DATA_WIDTH_A + (WRITE_DATA_WIDTH_A/64)*8) &amp;&amp; `ENC_ONLY) begin
861        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_B (%0d) does not equal WRITE_DATA_WIDTH_A + number of syndrome bits (%0d) for this configuration which uses port A write and port B read operations with ECC(encode only) enabled, but this configuration requires symmetric write and read data widths across each enabled port. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 52, READ_DATA_WIDTH_B, (WRITE_DATA_WIDTH_A + (WRITE_DATA_WIDTH_A/64)*8));</font>
862        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
863                         end
                        MISSING_ELSE
864                     
865        1/1              if (`MEM_PORTA_WRITE &amp;&amp; WRITE_DATA_WIDTH_A%64 != 0 &amp;&amp; `ENC_ONLY) begin
866        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) is not a multiple of 64 for this configuration which uses port A write with ECC mode(encode only) enabled, but this configuration requires write data width to be multiple of 64. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 53, WRITE_DATA_WIDTH_A);</font>
867        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
868                         end
                        MISSING_ELSE
869        1/1              if (`MEM_PORTA_READ &amp;&amp; READ_DATA_WIDTH_A%72 != 0 &amp;&amp; `ENC_ONLY) begin
870        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_A (%0d) is not a multiple of 72 for this configuration which uses port A read with ECC mode(encode only) enabled, but this configuration requires read data width to be multiple of 72. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 54, READ_DATA_WIDTH_A);</font>
871        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
872                         end
                        MISSING_ELSE
873        1/1              if (`MEM_PORTB_WRITE &amp;&amp; WRITE_DATA_WIDTH_B%64 != 0 &amp;&amp; `ENC_ONLY) begin
874        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_B (%0d) is not a multiple of 64 for this configuration which uses port B write with ECC mode(encode only) enabled, but this configuration requires write data width to be multiple of 64. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 55, WRITE_DATA_WIDTH_B);</font>
875        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
876                         end
                        MISSING_ELSE
877        1/1              if (`MEM_PORTB_READ &amp;&amp; READ_DATA_WIDTH_B%72 != 0 &amp;&amp; `ENC_ONLY) begin
878        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_B (%0d) is not a multiple of 72 for this configuration which uses port B read with ECC mode(encode only) enabled, but this configuration requires write data width to be multiple of 72. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 56, READ_DATA_WIDTH_B);</font>
879        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
880                         end
                        MISSING_ELSE
881                     
882        1/1              if (`MEM_PORTA_READ &amp;&amp; MEMORY_SIZE % READ_DATA_WIDTH_A != 0 &amp;&amp; `ENC_ONLY) begin
883        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of READ_DATA_WIDTH_A (%0d) for this configuration which uses port A read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 57, MEMORY_SIZE, READ_DATA_WIDTH_A);</font>
884        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
885                         end
                        MISSING_ELSE
886        1/1              if (`MEM_PORTB_READ &amp;&amp; MEMORY_SIZE % READ_DATA_WIDTH_B != 0 &amp;&amp; `ENC_ONLY) begin
887        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of READ_DATA_WIDTH_B (%0d) for this configuration which uses port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 58, MEMORY_SIZE, READ_DATA_WIDTH_B);</font>
888        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
889                         end
                        MISSING_ELSE
890        1/1              if (`MEM_PORTA_READ &amp;&amp; $clog2(MEMORY_SIZE/READ_DATA_WIDTH_A) &gt; ADDR_WIDTH_A &amp;&amp; `ENC_ONLY) begin
891        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), READ_DATA_WIDTH_A (%0d), and ADDR_WIDTH_A (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port A read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 59, MEMORY_SIZE, READ_DATA_WIDTH_A, ADDR_WIDTH_A);</font>
892        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
893                         end
                        MISSING_ELSE
894        1/1              if (`MEM_PORTA_READ &amp;&amp; MEMORY_SIZE/READ_DATA_WIDTH_A &lt; 2 &amp;&amp; `ENC_ONLY) begin
895        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and READ_DATA_WIDTH_A (%0d) imply that the memory is not at least two words from the perspective of port A read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 60, MEMORY_SIZE, READ_DATA_WIDTH_A);</font>
896        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
897                         end
                        MISSING_ELSE
898        1/1              if (`MEM_PORTB_READ &amp;&amp; $clog2(MEMORY_SIZE/READ_DATA_WIDTH_B) &gt; ADDR_WIDTH_B &amp;&amp; `ENC_ONLY) begin
899        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), READ_DATA_WIDTH_B (%0d), and ADDR_WIDTH_B (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 62, MEMORY_SIZE, READ_DATA_WIDTH_B, ADDR_WIDTH_B);</font>
900        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
901                         end
                        MISSING_ELSE
902        1/1              if (`MEM_PORTB_READ &amp;&amp; MEMORY_SIZE/READ_DATA_WIDTH_B &lt; 2 &amp;&amp; `ENC_ONLY) begin
903        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and READ_DATA_WIDTH_B (%0d) imply that the memory is not at least two words from the perspective of port B read operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 63, MEMORY_SIZE, READ_DATA_WIDTH_B);</font>
904        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
905                         end
                        MISSING_ELSE
906                     
907                     // Dec_Only
908        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTA_READ &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; WRITE_DATA_WIDTH_A != (READ_DATA_WIDTH_A + (READ_DATA_WIDTH_A/64)*8) &amp;&amp; `DEC_ONLY) begin
909        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_A + number of syndrome bits (%0d) for this configuration which uses port A write and read operations with ECC mode(decode only) enabled, but this configuration requires symmetric write and read data widths within each enabled port. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 100, WRITE_DATA_WIDTH_A, (READ_DATA_WIDTH_A + (READ_DATA_WIDTH_A/64)*8));</font>
910        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
911                         end
                        MISSING_ELSE
912        1/1              if (`MEM_PORTB_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; WRITE_DATA_WIDTH_B != (READ_DATA_WIDTH_B + (READ_DATA_WIDTH_B/64)*8) &amp;&amp; `DEC_ONLY) begin
913        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_B (%0d) does not equal READ_DATA_WIDTH_B + number of syndrome bits (%0d) for this configuration which uses port B write and read operations with ECC(decode only) enabled, but this configuration requires symmetric write and read data widths within each enabled port. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 101, WRITE_DATA_WIDTH_B, (READ_DATA_WIDTH_B + (READ_DATA_WIDTH_B/64)*8));</font>
914        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
915                         end
                        MISSING_ELSE
916        1/1              if (`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTB_READ &amp;&amp; `MEM_TYPE_RAM_SDP &amp;&amp; WRITE_DATA_WIDTH_A != (READ_DATA_WIDTH_B + (READ_DATA_WIDTH_B/64)*8) &amp;&amp; `DEC_ONLY) begin
917        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) does not equal READ_DATA_WIDTH_B + number of syndrome bits (%0d) for this configuration which uses port A write and port B read operations with ECC(decode only) enabled, but this configuration requires symmetric write and read data widths across each enabled port. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 102, WRITE_DATA_WIDTH_A, (READ_DATA_WIDTH_B + (READ_DATA_WIDTH_B/64)*8));</font>
918        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
919                         end
                        MISSING_ELSE
920                     
921        1/1              if (`MEM_PORTA_WRITE &amp;&amp; WRITE_DATA_WIDTH_A%72 != 0 &amp;&amp; `DEC_ONLY) begin
922        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_A (%0d) is not a multiple of 72 for this configuration which uses port A write with ECC mode(decode only) enabled, but this configuration requires write data width to be multiple of 72. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 103, WRITE_DATA_WIDTH_A);</font>
923        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
924                         end
                        MISSING_ELSE
925        1/1              if (`MEM_PORTA_READ &amp;&amp; READ_DATA_WIDTH_A%64 != 0 &amp;&amp; `DEC_ONLY) begin
926        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_A (%0d) is not a multiple of 64 for this configuration which uses port A read with ECC mode(decode only) enabled, but this configuration requires write data width to be multiple of 64. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 104, READ_DATA_WIDTH_A);</font>
927        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
928                         end
                        MISSING_ELSE
929        1/1              if (`MEM_PORTB_WRITE &amp;&amp; WRITE_DATA_WIDTH_B%72 != 0 &amp;&amp; `DEC_ONLY) begin
930        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] WRITE_DATA_WIDTH_B (%0d) is not a multiple of 72 for this configuration which uses port B write with ECC mode(decode only) enabled, but this configuration requires write data width to be multiple of 72. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 105, WRITE_DATA_WIDTH_B);</font>
931        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
932                         end
                        MISSING_ELSE
933        1/1              if (`MEM_PORTB_READ &amp;&amp; READ_DATA_WIDTH_B%64 != 0 &amp;&amp; `DEC_ONLY) begin
934        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] READ_DATA_WIDTH_B (%0d) is not a multiple of 64 for this configuration which uses port B write with ECC mode(decode only) enabled, but this configuration requires write data width to be multiple of 64. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 106, READ_DATA_WIDTH_B);</font>
935        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
936                         end
                        MISSING_ELSE
937                     
938        1/1              if (`MEM_PORTA_WRITE &amp;&amp; MEMORY_SIZE % WRITE_DATA_WIDTH_A != 0 &amp;&amp; `DEC_ONLY) begin
939        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of WRITE_DATA_WIDTH_A (%0d) for this configuration which uses port A write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 107, MEMORY_SIZE, WRITE_DATA_WIDTH_A);</font>
940        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
941                         end
                        MISSING_ELSE
942        1/1              if (`MEM_PORTB_WRITE &amp;&amp; MEMORY_SIZE % WRITE_DATA_WIDTH_B != 0 &amp;&amp; `DEC_ONLY) begin
943        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) is not an integer multiple of WRITE_DATA_WIDTH_B (%0d) for this configuration which uses port B write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 108, MEMORY_SIZE, WRITE_DATA_WIDTH_B);</font>
944        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
945                         end
                        MISSING_ELSE
946        1/1              if (`MEM_PORTA_WRITE &amp;&amp; $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_A) &gt; ADDR_WIDTH_A &amp;&amp; `DEC_ONLY) begin
947        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), WRITE_DATA_WIDTH_A (%0d), and ADDR_WIDTH_A (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port A write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 109, MEMORY_SIZE, WRITE_DATA_WIDTH_A, ADDR_WIDTH_A);</font>
948        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
949                         end
                        MISSING_ELSE
950        1/1              if (`MEM_PORTA_WRITE &amp;&amp; MEMORY_SIZE/WRITE_DATA_WIDTH_A &lt; 2 &amp;&amp; `DEC_ONLY) begin
951        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and WRITE_DATA_WIDTH_A (%0d) imply that the memory is not at least two words from the perspective of port A write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 110, MEMORY_SIZE, WRITE_DATA_WIDTH_A);</font>
952        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
953                         end
                        MISSING_ELSE
954        1/1              if (`MEM_PORTB_WRITE &amp;&amp; $clog2(MEMORY_SIZE/WRITE_DATA_WIDTH_B) &gt; ADDR_WIDTH_B &amp;&amp; `DEC_ONLY) begin
955        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d), WRITE_DATA_WIDTH_B (%0d), and ADDR_WIDTH_B (%0d) together imply that the memory size exceeds its addressable range for this configuration which uses port B write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 111, MEMORY_SIZE, WRITE_DATA_WIDTH_B, ADDR_WIDTH_B);</font>
956        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
957                         end
                        MISSING_ELSE
958        1/1              if (`MEM_PORTB_WRITE &amp;&amp; MEMORY_SIZE/WRITE_DATA_WIDTH_B &lt; 2 &amp;&amp; `DEC_ONLY) begin
959        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] MEMORY_SIZE (%0d) and WRITE_DATA_WIDTH_B (%0d) imply that the memory is not at least two words from the perspective of port B write operations. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 112, MEMORY_SIZE, WRITE_DATA_WIDTH_B);</font>
960        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
961                         end
                        MISSING_ELSE
962                     
963        1/1              if (!(`NO_ECC) &amp;&amp; `MEM_PORTA_WRITE &amp;&amp; (WRITE_DATA_WIDTH_A != BYTE_WRITE_WIDTH_A)) begin
964        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has ECC_MODE(%0d) parameter is set to a non-zero value, WRITE_DATA_WIDTH_A(%0d) is not equal to BYTE_WRITE_WIDTH_A(%0d) specified, but byte wide write operations are not allowed when ECC feature is enabled . %m&quot;, &quot;XPM_MEMORY&quot;, 41, 113, ECC_MODE, WRITE_DATA_WIDTH_A, BYTE_WRITE_WIDTH_A);</font>
965        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
966                         end
                        MISSING_ELSE
967                     
968        1/1              if (!(`NO_ECC) &amp;&amp; `MEM_PORTB_WRITE &amp;&amp; (WRITE_DATA_WIDTH_B != BYTE_WRITE_WIDTH_B)) begin
969        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has ECC_MODE(%0d) parameter is set to a non-zero value, WRITE_DATA_WIDTH_B(%0d) is not equal to BYTE_WRITE_WIDTH_B(%0d) specified, but byte wide write operations are not allowed when ECC feature is enabled . %m&quot;, &quot;XPM_MEMORY&quot;, 41, 114, ECC_MODE, WRITE_DATA_WIDTH_B, BYTE_WRITE_WIDTH_B);</font>
970        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
971                         end
                        MISSING_ELSE
972                     
973        1/1              if (!(`NO_ECC) &amp;&amp; `MEM_PORTA_READ &amp;&amp; rst_val_conv_a(READ_RESET_VALUE_A) != 0) begin
974        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has ECC_MODE(%0d) enabled and non-zero READ_RESET_VALUE_A (%0h) value is specified, but non-zero reset value is not supported when ECC_MODE is enabled. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 115, ECC_MODE, READ_RESET_VALUE_A);</font>
975        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
976                         end
                        MISSING_ELSE
977                     
978        1/1              if (!(`NO_ECC) &amp;&amp; `MEM_PORTB_READ &amp;&amp; rst_val_conv_b(READ_RESET_VALUE_B) != 0) begin
979        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has ECC_MODE(%0d) enabled and non-zero READ_RESET_VALUE_B (%0h) value is specified, but non-zero reset value is not supported when ECC_MODE is enabled. %m&quot;, &quot;XPM_MEMORY&quot;, 41, 116, ECC_MODE, READ_RESET_VALUE_B);</font>
980        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
981                         end
                        MISSING_ELSE
982                     
983                     // DRCs related to Auto Sleep
984        1/1              if (AUTO_SLEEP_TIME != 0 &amp;&amp; !`MEM_PRIM_ULTRA) begin
985        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] AUTO_SLEEP_TIME (%0d) value specified is non-zero for this configuration which has MEMORY_PRIMITIVE (%0d) value other than ultraRAM, but the auto sleep feature is supported only by UltraRAM primitive. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 52, AUTO_SLEEP_TIME,MEMORY_PRIMITIVE);</font>
986        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
987                         end
                        MISSING_ELSE
988        1/1              if (AUTO_SLEEP_TIME != 0 &amp;&amp; WAKEUP_TIME != 0) begin
989        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has non-zero AUTO_SLEEP_TIME (%0d) and WAKEUP_TIME (%0d), but both of these features cannot co-exist. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 53, AUTO_SLEEP_TIME,WAKEUP_TIME);</font>
990        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
991                         end
                        MISSING_ELSE
992                     
993                     // DRCs related to Reset Mode
994        1/1              if (`ASYNC_RESET_A &amp;&amp; !(`MEM_PRIM_BLOCK || `MEM_PRIM_ULTRA)) begin
995        <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has RST_MODE_A parameter is set ASYNC and the MEMORY_PRIMITIVE(%0d) specified is other than BlockRAM or UltraRAM, but Asynchronous Reset is supported only when the MEMORY_PRIMITIVE is set to either BlockRAM or UltraRAM . %m&quot;, &quot;XPM_MEMORY&quot;, 40, 54, MEMORY_PRIMITIVE);</font>
996        <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
997                         end
                        MISSING_ELSE
998                     
999        1/1              if (`ASYNC_RESET_B &amp;&amp; !(`MEM_PRIM_BLOCK || `MEM_PRIM_ULTRA)) begin
1000       <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has RST_MODE_B parameter is set ASYNC and the MEMORY_PRIMITIVE(%0d) specified is other than BlockRAM or UltraRAM, but Asynchronous Reset is supported only when the MEMORY_PRIMITIVE is set to either BlockRAM or UltraRAM . %m&quot;, &quot;XPM_MEMORY&quot;, 40, 54, MEMORY_PRIMITIVE);</font>
1001       <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
1002                        end
                        MISSING_ELSE
1003                    
1004                    // DRCs related to Read Reset Value
1005       1/1              if (`ASYNC_RESET_A &amp;&amp; (READ_RESET_VALUE_A != &quot;0&quot;)) begin
1006       <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has RST_MODE_A parameter is set ASYNC and the READ_RESET_VALUE_A specified is Non-Zero value, but Non-Zero Reset value not allowed when RST_MODE_A is Asynchronous. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 55);</font>
1007       <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
1008                        end
                        MISSING_ELSE
1009                    
1010       1/1              if (`ASYNC_RESET_B &amp;&amp; (READ_RESET_VALUE_B != &quot;0&quot;)) begin
1011       <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] The configuration specified has RST_MODE_B parameter is set ASYNC and the READ_RESET_VALUE_B specified is Non-Zero value, but Non-Zero Reset value not allowed when RST_MODE_B is Asynchronous. %m&quot;, &quot;XPM_MEMORY&quot;, 40, 56);</font>
1012       <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
1013                        end
                        MISSING_ELSE
1014                    
1015                    // DRCs related to Mixed Mode Primitives
1016       1/1              if (`MEM_PRIM_MIXED &amp;&amp; (!`NO_ECC || AUTO_SLEEP_TIME != 0)) begin
1017       <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] ECC and Auto Sleep features not supported for Mixed Mode Primitives. %m&quot;, &quot;XPM_MEMORY&quot;, 4, 1);</font>
1018       <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
1019                        end
                        MISSING_ELSE
1020                    
1021       1/1              if (`MEM_PRIM_MIXED &amp;&amp; (`MEM_TYPE_ROM_SP || `MEM_TYPE_ROM_DP)) begin
1022       <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Mixed Mode Primitives does not support ROM configurations. %m&quot;, &quot;XPM_MEMORY&quot;, 4, 2);</font>
1023       <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
1024                        end
                        MISSING_ELSE
1025                    
1026       1/1              if (`MEM_PRIM_MIXED &amp;&amp; ((`MEM_PORTA_WRITE &amp;&amp; `MEM_PORTA_NC) || (`MEM_PORTB_WRITE &amp;&amp; `MEM_PORTB_NC))) begin
1027       <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Mixed Mode Primitives does not support No_Change on Write Mode. %m&quot;, &quot;XPM_MEMORY&quot;, 4, 3);</font>
1028       <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
1029                        end
                        MISSING_ELSE
1030                    
1031       1/1              if (`MEM_PRIM_MIXED &amp;&amp; ((`MEM_TYPE_RAM_TDP &amp;&amp; (WRITE_DATA_WIDTH_A != WRITE_DATA_WIDTH_B)) || (`MEM_TYPE_RAM_SDP &amp;&amp; (WRITE_DATA_WIDTH_A != READ_DATA_WIDTH_B)))) begin
1032       <font color = "red">0/1     ==>        $error(&quot;[%s %0d-%0d] Mixed Mode Primitives does not support Asymmetric Data Width. %m&quot;, &quot;XPM_MEMORY&quot;, 4, 4);</font>
1033       <font color = "red">0/1     ==>        drc_err_flag = 1;</font>
1034                        end
                        MISSING_ELSE
1035                    
1036       1/1              if (drc_err_flag == 1)
1037       <font color = "red">0/2     ==>        #1 $finish;</font>
                        MISSING_ELSE
1038                      end : config_drc
1039                    
1040                      // -------------------------------------------------------------------------------------------------------------------
1041                      // Memory array declaration and initialization
1042                      // -------------------------------------------------------------------------------------------------------------------
1043                      
1044                      (* ram_style = P_MEMORY_PRIMITIVE,
1045                         rom_style = P_MEMORY_PRIMITIVE,
1046                         rw_addr_collision = P_SDP_WRITE_MODE,
1047                         ram_ecc = P_ECC_MODE,
1048                         cascade_height = CASCADE_HEIGHT,
1049                         ram_optimization = P_MEMORY_OPT *) reg [P_MIN_WIDTH_DATA_ECC-1:0] mem [0:P_MAX_DEPTH_DATA-1];
1050                    
1051                      // Initialization through parameter
1052                      // Parameter and variable declarations
1053                        localparam NUM_CHAR_LOC = (MEMORY_INIT_PARAM == &quot;&quot; || MEMORY_INIT_PARAM == &quot;0&quot;) ? 0 : (P_MIN_WIDTH_DATA%4 == 0) ? (P_MIN_WIDTH_DATA/4) : ((P_MIN_WIDTH_DATA/4)+1);
1054                        localparam MAX_NUM_CHAR = (MEMORY_INIT_PARAM == &quot;&quot; || MEMORY_INIT_PARAM == &quot;0&quot;) ? 0 : P_MAX_DEPTH_DATA * NUM_CHAR_LOC + P_MAX_DEPTH_DATA;
1055                      // constants declared to eliminate the eloboration warnings in modelsim, vcs and ies
1056                        localparam P_MIN_WIDTH_DATA_SHFT = (P_MIN_WIDTH_DATA &lt;= 4) ? 5 : P_MIN_WIDTH_DATA;
1057                        localparam P_MIN_WIDTH_DATA_LDW  = (P_MIN_WIDTH_DATA &lt;= 4) ? P_MIN_WIDTH_DATA : 4;
1058                        integer num_char_in_param=0;
1059                      
1060                      // Function to calculate the number of characters in the string
1061                        function integer num_char_init;
1062                          input [(MAX_NUM_CHAR+1)*8-1:0]    str_i;
1063       <font color = "red">0/1     ==>        num_char_init = 0;</font>
1064       <font color = "red">0/1     ==>        for(integer char_cnt=0; char_cnt&lt;=MAX_NUM_CHAR; char_cnt=char_cnt+1)</font>
1065                            begin
1066       <font color = "red">0/1     ==>            if(str_i[(char_cnt*8)+7 -: 8] != &quot;&quot;)</font>
1067       <font color = "red">0/1     ==>               num_char_init = num_char_init+1;</font>
                   <font color = "red">==>  MISSING_ELSE</font>
1068                            end
1069                        endfunction
1070                      
1071                      // Function that parses the string and returns the initialized array to the memory
1072                        function [P_MAX_DEPTH_DATA-1:0] [P_MIN_WIDTH_DATA-1:0] init_param_memory;
1073                          input         [(MAX_NUM_CHAR+1)*8-1:0]  mem_init_param_reg;
1074                          reg [3:0]                               ascii_to_binary_reg;
1075                          reg [P_MIN_WIDTH_DATA-1:0]              conv_bin_val;
1076                          integer                                 mem_location;
1077                          integer                                 num_char;
1078       <font color = "red">0/1     ==>          conv_bin_val = {P_MIN_WIDTH_DATA{1'b0}};</font>
1079       <font color = "red">0/1     ==>          mem_location = 0;</font>
1080       <font color = "red">0/1     ==>          num_char = 0;</font>
1081       <font color = "red">0/1     ==>          for (integer init_char=MAX_NUM_CHAR+1; init_char&gt;0; init_char = init_char-1) begin : ascii_to_bin_loop</font>
1082       <font color = "red">0/1     ==>            if((mem_init_param_reg[(init_char*8)-1 -: 8] == 8'h2c) || (mem_init_param_reg[(init_char*8)-1 -: 8] == 8'h3b) || </font>
1083                                   (mem_init_param_reg[(init_char*8)-1 -: 8] == 8'h00)) begin
1084       <font color = "red">0/1     ==>              ascii_to_binary_reg = 4'h0;</font>
1085       <font color = "red">0/1     ==>              if (num_char &gt; 0) // Check at least for one valid character before encountering the delimiter or NULL</font>
1086                                  begin
1087       <font color = "red">0/1     ==>                  init_param_memory[mem_location] = conv_bin_val[P_MIN_WIDTH_DATA-1:0];</font>
1088       <font color = "red">0/1     ==>                  mem_location = mem_location+1;</font>
1089                                  end
                   <font color = "red">==>  MISSING_ELSE</font>
1090       <font color = "red">0/1     ==>              conv_bin_val = {P_MIN_WIDTH_DATA{1'b0}};</font>
1091       <font color = "red">0/1     ==>              num_char = 0;</font>
1092                              end
1093       <font color = "red">0/1     ==>            else if(mem_init_param_reg[(init_char*8)-1 -: 8] != 8'h00) begin</font>
1094       <font color = "red">0/1     ==>              ascii_to_binary_reg = str_val_binary(mem_init_param_reg[(init_char*8)-1 -: 8]);</font>
1095       <font color = "red">0/1     ==>              if (P_MIN_WIDTH_DATA &lt;= 4)</font>
1096       <font color = "red">0/1     ==>                conv_bin_val = ascii_to_binary_reg[P_MIN_WIDTH_DATA_LDW-1:0]; // converted 4-bit value from ASCII</font>
1097                                else begin
1098       <font color = "red">0/1     ==>                conv_bin_val = {conv_bin_val[P_MIN_WIDTH_DATA_SHFT-5:0], ascii_to_binary_reg}; // Store the converted value in shift register</font>
1099                                  //conv_bin_val = conv_bin_val&lt;&lt;4 | ascii_to_binary_reg; // Store the converted value in shift register
1100                                end
1101       <font color = "red">0/1     ==>              num_char = num_char+1; // Increment number of characters parsed</font>
1102       <font color = "red">0/1     ==>              if(num_char &gt; NUM_CHAR_LOC)</font>
1103       <font color = "red">0/1     ==>                $error(&quot;Number of characters given in the Initialization string exceeded the memory width, Please enter a valid string&quot;);</font>
                   <font color = "red">==>  MISSING_ELSE</font>
1104                              end
                   <font color = "red">==>  MISSING_ELSE</font>
1105                            end : ascii_to_bin_loop
1106                        endfunction
1107                    
1108                    generate 
1109                    if(IGNORE_INIT_SYNTH == 0) begin : gen_no_ignore_init_synth
1110                      // Initialize memory array to the data file content if file name is specified, or to all zeroes if it is not specified
1111                      initial begin
1112       1/1              if (`NO_MEMORY_INIT) begin : init_zeroes
1113                          integer initword;
1114       <font color = "red">0/1     ==>        for (initword=0; initword&lt;P_MAX_DEPTH_DATA; initword=initword+1) begin</font>
1115       <font color = "red">0/1     ==>          mem[initword] = {P_MIN_WIDTH_DATA{1'b0}};</font>
1116                          end
1117                        end : init_zeroes
1118       1/1              else if (!(MEMORY_INIT_PARAM == &quot;0&quot; || MEMORY_INIT_PARAM == &quot;&quot;)) begin : init_param
1119                          reg [P_MAX_DEPTH_DATA-1:0] [P_MIN_WIDTH_DATA-1:0] mem_param;
1120       <font color = "red">0/1     ==>        num_char_in_param = num_char_init(MEMORY_INIT_PARAM);</font>
1121                          assert (num_char_in_param &lt;= MAX_NUM_CHAR) // Check if the string length exceeds the depth of the memory size
1122                          else
1123                            $error(&quot;No.of characters given in the Initialization Parameter string exceeds the Memory Size&quot;);
1124       <font color = "red">0/1     ==>        mem_param = init_param_memory({MEMORY_INIT_PARAM, 8'h0}); //Append NULL to identify the end of string</font>
1125       <font color = "red">0/1     ==>        for(integer mem_location=0; mem_location&lt;P_MAX_DEPTH_DATA; mem_location=mem_location+1)</font>
1126       <font color = "red">0/1     ==>          mem[mem_location] = mem_param[mem_location]; //assign the initial value to the memory</font>
1127                        end : init_param    
1128                        else begin : init_datafile
1129       2/2                  #10;
1130       1/1                $readmemh(MEMORY_INIT_FILE, mem, 0, P_MAX_DEPTH_DATA-1);
1131                        end : init_datafile
1132                      end
1133                    end : gen_no_ignore_init_synth
1134                    if(IGNORE_INIT_SYNTH == 1) begin : gen_ignore_init_synth
1135                      // Initialize memory array to the data file content if file name is specified, or to all zeroes if it is not specified
1136                      initial begin
1137                        if (`NO_MEMORY_INIT) begin : init_zeroes
1138                          integer initword;
1139                          for (initword=0; initword&lt;P_MAX_DEPTH_DATA; initword=initword+1) begin
1140                            mem[initword] = {P_MIN_WIDTH_DATA{1'b0}};
1141                          end
1142                        end : init_zeroes
1143                        else if (!(MEMORY_INIT_PARAM == &quot;0&quot; || MEMORY_INIT_PARAM == &quot;&quot;)) begin : init_param
1144                          reg [P_MAX_DEPTH_DATA-1:0] [P_MIN_WIDTH_DATA-1:0] mem_param;
1145                          num_char_in_param = num_char_init(MEMORY_INIT_PARAM);
1146                          assert (num_char_in_param &lt;= MAX_NUM_CHAR) // Check if the string length exceeds the depth of the memory size
1147                          else
1148                            $error(&quot;No.of characters given in the Initialization Parameter string exceeds the Memory Size&quot;);
1149                          mem_param = init_param_memory({MEMORY_INIT_PARAM, 8'h0}); //Append NULL to identify the end of string
1150                          for(integer mem_location=0; mem_location&lt;P_MAX_DEPTH_DATA; mem_location=mem_location+1)
1151                            mem[mem_location] = mem_param[mem_location]; //assign the initial value to the memory
1152                        end : init_param    
1153                      // synthesis translate_off
1154                        else begin : init_datafile
1155                            #10;
1156                          $readmemh(MEMORY_INIT_FILE, mem, 0, P_MAX_DEPTH_DATA-1);
1157                        end : init_datafile
1158                      // synthesis translate_on
1159                      end
1160                    end : gen_ignore_init_synth
1161                    endgenerate
1162                    
1163                      generate
1164                        // Function to convert ASCII value to binary 
1165                        function [3:0] str_val_binary;
1166                          input [7:0] str_val_ascii;
1167       <font color = "red">0/1     ==>          if((str_val_ascii == 8'h30) || (str_val_ascii == 8'h31) || </font>
1168                                (str_val_ascii == 8'h32) || (str_val_ascii == 8'h33) || 
1169                                 (str_val_ascii == 8'h34) || (str_val_ascii == 8'h35) || 
1170                                  (str_val_ascii == 8'h36) || (str_val_ascii == 8'h37) || 
1171                                   (str_val_ascii == 8'h38) || (str_val_ascii == 8'h39) || 
1172                                    (str_val_ascii == 8'h41) || (str_val_ascii == 8'h42) || 
1173                                     (str_val_ascii == 8'h43) || (str_val_ascii == 8'h44) || 
1174                                      (str_val_ascii == 8'h45) || (str_val_ascii == 8'h46) || 
1175                                       (str_val_ascii == 8'h61) || (str_val_ascii == 8'h62) || 
1176                                        (str_val_ascii == 8'h63) || (str_val_ascii == 8'h64) || 
1177                                         (str_val_ascii == 8'h65) || (str_val_ascii == 8'h66) || 
1178                                          (str_val_ascii == 8'h00)) begin
1179       <font color = "red">0/1     ==>             if (!str_val_ascii[6])</font>
1180       <font color = "red">0/1     ==>                str_val_binary = str_val_ascii[3:0];</font>
1181                               else begin
1182       <font color = "red">0/1     ==>               str_val_binary [3] = 1'b1;</font>
1183       <font color = "red">0/1     ==>               str_val_binary [2] = str_val_ascii[2] | (str_val_ascii[1] &amp; str_val_ascii[0]);</font>
1184       <font color = "red">0/1     ==>               str_val_binary [1] = str_val_ascii[0] ^ str_val_ascii[1];</font>
1185       <font color = "red">0/1     ==>               str_val_binary [0] = !str_val_ascii[0];</font>
1186                               end
1187                            end
1188                            else
1189       <font color = "red">0/1     ==>            $error(&quot;Found Invalid character while parsing the string, please cross check the value specified for either READ_RESET_VALUE_A|B or MEMORY_INIT_PARAM (if initialization of memory through parameter is used). XPM_MEMORY supports strings (hex) that contains characters 0-9, A-F and a-f.&quot;);</font>
1190                        endfunction
1191                        // Function that parses the complete reset value string
1192                        function logic [READ_DATA_WIDTH_A-1 :0] rst_val_conv_a;
1193                          input [READ_DATA_WIDTH_A*8-1 : 0] rst_val_reg_a;
1194                          integer rst_loop_a;
1195                          logic [rsta_loop_iter-1 : 0] rst_val_conv_a_i;
1196       <font color = "red">0/1     ==>        for (rst_loop_a=1; rst_loop_a &lt;= rsta_loop_iter/4; rst_loop_a = rst_loop_a+1) begin</font>
1197       <font color = "red">0/1     ==>          rst_val_conv_a_i[(rst_loop_a*4)-1 -: 4] =  str_val_binary(rst_val_reg_a[(rst_loop_a*8)-1 -: 8]);</font>
1198                          end
1199       <font color = "red">0/1     ==>        return rst_val_conv_a_i[READ_DATA_WIDTH_A-1 :0];</font>
1200                        endfunction
1201                    
1202                        function logic [READ_DATA_WIDTH_B-1 :0] rst_val_conv_b;
1203                          input [READ_DATA_WIDTH_B*8-1 : 0] rst_val_reg_b;
1204                          integer rst_loop_b;
1205                          logic [rstb_loop_iter-1 : 0] rst_val_conv_b_i;
1206       <font color = "red">0/1     ==>        for (rst_loop_b=1; rst_loop_b&lt;= rstb_loop_iter/4; rst_loop_b = rst_loop_b+1) begin</font>
1207       <font color = "red">0/1     ==>          rst_val_conv_b_i[(rst_loop_b*4)-1 -: 4] =  str_val_binary(rst_val_reg_b[(rst_loop_b*8)-1 -: 8]);</font>
1208                          end
1209       <font color = "red">0/1     ==>        return rst_val_conv_b_i[READ_DATA_WIDTH_B-1 :0];</font>
1210                        endfunction
1211                    
1212                        wire  [READ_DATA_WIDTH_A-1 : 0] douta_bb;
1213                        wire  [READ_DATA_WIDTH_B-1 : 0] doutb_bb;
1214                    
1215                      // -------------------------------------------------------------------------------------------------------------------
1216                      // Auto Sleep delays for port-A
1217                      // -------------------------------------------------------------------------------------------------------------------
1218                    
1219                      wire ena_i;
1220                      wire [(WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A)-1:0] wea_i;
1221                      wire [P_WIDTH_ADDR_WRITE_A-1:0] addra_i;
1222                      wire [WRITE_DATA_WIDTH_A-1:0] dina_i;
1223                      wire ena_o_pipe_ctrl;
1224                      wire regcea_i;
1225                    
1226                      if(`MEM_AUTO_SLP_EN) begin : gen_auto_slp_dly_a
1227                        reg [P_WIDTH_ADDR_WRITE_A-1:0] addra_aslp_pipe [AUTO_SLEEP_TIME-1:0];
1228                    
1229                        // Check if write operation is allowed on Port-A, if yes then
1230                        // generate the pipeline register stages on write enable and input data
1231                        if (`MEM_PORTA_WRITE) begin : gen_aslp_wr_a
1232                        reg [(WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A)-1:0] wea_aslp_pipe [AUTO_SLEEP_TIME-1:0];
1233                        reg [WRITE_DATA_WIDTH_A-1:0] dina_aslp_pipe [AUTO_SLEEP_TIME-1:0];
1234                          // Initialize the wea and dina pipelines
1235                          initial begin
1236                            integer aslp_initstage_a;
1237                            for (aslp_initstage_a=0; aslp_initstage_a &lt; AUTO_SLEEP_TIME; aslp_initstage_a=aslp_initstage_a+1) begin : for_wr_en_pipe_init
1238                              wea_aslp_pipe[aslp_initstage_a] = {(WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A){1'b0}};
1239                              dina_aslp_pipe[aslp_initstage_a] = {WRITE_DATA_WIDTH_A{1'b0}};
1240                            end : for_wr_en_pipe_init
1241                          end
1242                          // Connect the user inputs to the pipeline
1243                          always @(posedge clka) begin
1244                              wea_aslp_pipe[0]    &lt;= wea;
1245                              dina_aslp_pipe[0]   &lt;= dina;
1246                          end
1247                          for (genvar aslp_stage=1; aslp_stage &lt; AUTO_SLEEP_TIME; aslp_stage = aslp_stage+1) begin : gen_aslp_inp_pipe
1248                            always @(posedge clka) begin
1249                              wea_aslp_pipe[aslp_stage]   &lt;= wea_aslp_pipe[aslp_stage-1];
1250                              dina_aslp_pipe[aslp_stage]  &lt;= dina_aslp_pipe[aslp_stage-1];
1251                            end
1252                          end : gen_aslp_inp_pipe
1253                          // Assign the last stage register outputs to appropriate internal signals
1254                          assign wea_i  = wea_aslp_pipe[AUTO_SLEEP_TIME-1];
1255                          assign dina_i = dina_aslp_pipe[AUTO_SLEEP_TIME-1];
1256                        end : gen_aslp_wr_a
1257                        // If write operation is not allowed, then connect the write control signals
1258                        // to zero
1259                        else begin : gnd_wr_a_ctrls
1260                          assign  wea_i  = {(WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A){1'b0}};
1261                          assign  dina_i = {(WRITE_DATA_WIDTH_A){1'b0}};
1262                        end : gnd_wr_a_ctrls
1263                        // Generate the pipeline register stages on addra
1264                        // Initialize the addra pipeline
1265                        initial begin
1266                          integer aslp_initstage_a;
1267                          for (aslp_initstage_a=0; aslp_initstage_a &lt; AUTO_SLEEP_TIME; aslp_initstage_a=aslp_initstage_a+1) begin : for_addr_pipe_init
1268                            addra_aslp_pipe[aslp_initstage_a] = {P_WIDTH_ADDR_WRITE_A{1'b0}};
1269                          end : for_addr_pipe_init
1270                        end
1271                        // Connect the user inputs to the pipeline
1272                        always @(posedge clka) begin
1273                            addra_aslp_pipe[0]  &lt;= addra;
1274                        end
1275                        for (genvar aslp_stage=1; aslp_stage &lt; AUTO_SLEEP_TIME; aslp_stage = aslp_stage+1) begin : gen_aslp_inp_pipe
1276                          always @(posedge clka) begin
1277                            addra_aslp_pipe[aslp_stage] &lt;= addra_aslp_pipe[aslp_stage-1];
1278                          end
1279                        end : gen_aslp_inp_pipe
1280                        // Assign the last stage register outputs to internal address
1281                        assign addra_i = addra_aslp_pipe[AUTO_SLEEP_TIME-1];
1282                        // Check if Read Operations are allowed on Port-A and if output pipeline
1283                        // exists
1284                        if(`MEM_PORTA_READ) begin : gen_aslp_rd_a
1285                          if(READ_LATENCY_A &gt;= 2) begin : gen_aslp_dly_regce
1286                            reg regcea_aslp_pipe [AUTO_SLEEP_TIME-1:0];
1287                            // Initialize the regcea pipeline
1288                            initial begin
1289                              integer aslp_initstage_a;
1290                              for (aslp_initstage_a=0; aslp_initstage_a &lt; AUTO_SLEEP_TIME; aslp_initstage_a=aslp_initstage_a+1) begin : for_regce_pipe_init
1291                                regcea_aslp_pipe[aslp_initstage_a] = 1'b0;
1292                              end : for_regce_pipe_init
1293                            end
1294                            // Connect the user inputs to the pipeline
1295                            always @(posedge clka) begin
1296                              regcea_aslp_pipe[0] &lt;= regcea;
1297                            end
1298                            for (genvar aslp_stage=1; aslp_stage &lt; AUTO_SLEEP_TIME; aslp_stage = aslp_stage+1) begin : gen_aslp_inp_pipe
1299                              always @(posedge clka) begin
1300                                regcea_aslp_pipe[aslp_stage]  &lt;= regcea_aslp_pipe[aslp_stage-1];
1301                              end
1302                            end : gen_aslp_inp_pipe
1303                            // Assign the final pipeline output to internal regce
1304                            assign  regcea_i = regcea_aslp_pipe[AUTO_SLEEP_TIME-1];
1305                          end : gen_aslp_dly_regce
1306                          else begin : gnd_regce_ctrl
1307                            // If there are no output pipe lines, then connect to zero
1308                            assign  regcea_i = 1'b0;
1309                          end : gnd_regce_ctrl
1310                          if(READ_LATENCY_A &gt; 2) begin : gen_aslp_dly_out_pipe
1311                            reg ena_aslp_pipe    [AUTO_SLEEP_TIME-1:0];
1312                            // Initialize the ena pipeline
1313                            initial begin
1314                              integer aslp_initstage_a;
1315                              for (aslp_initstage_a=0; aslp_initstage_a &lt; AUTO_SLEEP_TIME; aslp_initstage_a=aslp_initstage_a+1) begin : for_en_pipe_init
1316                                ena_aslp_pipe[aslp_initstage_a] = 1'b0;
1317                              end : for_en_pipe_init
1318                            end
1319                            // Connect the user inputs to the pipeline
1320                            always @(posedge clka) begin
1321                              ena_aslp_pipe[0]    &lt;= ena;
1322                            end
1323                            for (genvar aslp_stage=1; aslp_stage &lt; AUTO_SLEEP_TIME; aslp_stage = aslp_stage+1) begin : gen_aslp_inp_pipe
1324                              always @(posedge clka) begin
1325                                ena_aslp_pipe[aslp_stage]   &lt;= ena_aslp_pipe[aslp_stage-1];
1326                              end
1327                            end : gen_aslp_inp_pipe
1328                            // Assign the final pipeline output to internal enable that controls the
1329                            // output pipeline
1330                            assign  ena_o_pipe_ctrl  = ena_aslp_pipe[AUTO_SLEEP_TIME-1];
1331                          end : gen_aslp_dly_out_pipe
1332                          else begin : gnd_pipe_en_ctrl
1333                            // If there are no output pipe lines, then connect to zero
1334                            assign ena_o_pipe_ctrl = 0;
1335                          end : gnd_pipe_en_ctrl
1336                        end : gen_aslp_rd_a
1337                      end : gen_auto_slp_dly_a
1338                      else begin : gen_nauto_slp_dly_a
1339                        // connect all the internal control signals to the ports when auto sleep is
1340                        // not enabled
1341                        assign addra_i = addra;
1342                        assign wea_i   = wea;
1343                        assign dina_i  = dina;
1344                        assign ena_o_pipe_ctrl  = ena;
1345                        assign regcea_i = regcea;
1346                      end : gen_nauto_slp_dly_a
1347                      // Enable needs to reach URAM early compared to other inputs in Auto Sleep
1348                      // Mode, so no pipe line stages on enable irrespective auto sleep mode
1349                      // enabled/disabled
1350                      assign ena_i    = ena;
1351                    
1352                      // -------------------------------------------------------------------------------------------------------------------
1353                      // Port A write
1354                      // -------------------------------------------------------------------------------------------------------------------
1355                    
1356                      // If the memory is any type of RAM, generate a port A write process
1357                      if (`MEM_PORTA_WRITE &amp;&amp; !`DISABLE_SYNTH_TEMPL) begin : gen_wr_a
1358                        wire [P_WIDTH_ADDR_WRITE_A-1:0] addra_int = addra_i;
1359                    
1360                        // Synchronous port A write; word-wide write; port width is the narrowest of the data ports
1361                        if (`MEM_PORTA_WR_WORD &amp;&amp; `MEM_PORTA_WR_NARROW &amp;&amp; `WRITE_PROT_ENABLED) begin : gen_word_narrow
1362                          always @(posedge clka) begin
1363       1/1                  if (ena_i) begin
1364       1/1                    if (wea_i)
1365       <font color = "red">0/1     ==>              mem[addra_int] &lt;= dina_i;</font>
                        MISSING_ELSE
1366                            end
                        MISSING_ELSE
1367                          end
1368                        end : gen_word_narrow
1369                        else if (`MEM_PORTA_WR_WORD &amp;&amp; `MEM_PORTA_WR_NARROW &amp;&amp; `WRITE_PROT_DISABLED) begin : gen_word_narrow_wp
1370                          always @(posedge clka) begin
1371                              if (wea_i)
1372                                mem[addra_int] &lt;= dina_i;
1373                          end
1374                        end : gen_word_narrow_wp
1375                    
1376                        // Synchronous port A write; word-wide write; port width is wider than at least one other data port;
1377                        // not generated in port A write-first read with wide data width special case
1378                        else if (`MEM_PORTA_WR_WORD &amp;&amp; `MEM_PORTA_WR_WIDE &amp;&amp;
1379                              !((`MEM_TYPE_RAM_SP || `MEM_TYPE_RAM_TDP) &amp;&amp; `MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_WIDE) &amp;&amp; `WRITE_PROT_ENABLED) begin : gen_word_wide
1380                          always @(posedge clka) begin : wr_sync
1381                            integer row;
1382                            reg [P_WIDTH_ADDR_LSB_WRITE_A-1:0] addralsb;
1383                            for (row=0; row&lt;P_NUM_ROWS_WRITE_A; row=row+1) begin : for_mem_rows
1384                              addralsb = row;
1385                              if (ena_i) begin
1386                                if (wea_i)
1387                                  mem[{addra_int, addralsb}] &lt;= dina_i[`ONE_ROW_OF_DIN];
1388                              end
1389                            end : for_mem_rows
1390                          end : wr_sync
1391                        end : gen_word_wide
1392                        else if (`MEM_PORTA_WR_WORD &amp;&amp; `MEM_PORTA_WR_WIDE &amp;&amp;
1393                              !((`MEM_TYPE_RAM_SP || `MEM_TYPE_RAM_TDP) &amp;&amp; `MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_WIDE) &amp;&amp; `WRITE_PROT_DISABLED) begin : gen_word_wide_wp
1394                          always @(posedge clka) begin : wr_sync
1395                            integer row;
1396                            reg [P_WIDTH_ADDR_LSB_WRITE_A-1:0] addralsb;
1397                            for (row=0; row&lt;P_NUM_ROWS_WRITE_A; row=row+1) begin : for_mem_rows
1398                              addralsb = row;
1399                                if (wea_i)
1400                                  mem[{addra_int, addralsb}] &lt;= dina_i[`ONE_ROW_OF_DIN];
1401                            end : for_mem_rows
1402                          end : wr_sync
1403                        end : gen_word_wide_wp
1404                        
1405                        // Synchronous port A write-first read; port width is wider than at least one other data port; no output pipeline;
1406                        // write and read combined special case
1407                        else if (`MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_WIDE &amp;&amp; `MEM_PORTA_RD_REG &amp;&amp; `WRITE_PROT_ENABLED) begin : gen_wf_wide_reg
1408                          always @(posedge clka) begin : wr_rd_sync
1409                            integer row;
1410                            reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
1411                            for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
1412                              addralsb = row;
1413                                if (ena_i) begin
1414                                  if (wea_i)
1415                                    mem[{addra_int, addralsb}] &lt;= dina_i[`ONE_ROW_OF_DIN];
1416                                end
1417                            end : for_mem_rows
1418                          end : wr_rd_sync
1419                        end : gen_wf_wide_reg
1420                        else if (`MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_WIDE &amp;&amp; `MEM_PORTA_RD_REG &amp;&amp; `WRITE_PROT_DISABLED) begin : gen_wf_wide_reg_wp
1421                          always @(posedge clka) begin : wr_rd_sync
1422                            integer row;
1423                            reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
1424                            for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
1425                              addralsb = row;
1426                                  if (wea_i)
1427                                    mem[{addra_int, addralsb}] &lt;= dina_i[`ONE_ROW_OF_DIN];
1428                            end : for_mem_rows
1429                          end : wr_rd_sync
1430                        end : gen_wf_wide_reg_wp
1431                    
1432                        // Synchronous port A write; byte-wide write; port width is the narrowest of the data ports
1433                        else if (`MEM_PORTA_WR_BYTE &amp;&amp; `MEM_PORTA_WR_NARROW &amp;&amp; `WRITE_PROT_ENABLED) begin : gen_byte_narrow
1434                          for (genvar col=0; col&lt;P_NUM_COLS_WRITE_A; col=col+1) begin : for_mem_cols
1435                            always @(posedge clka) begin : wr_sync
1436                              if (ena_i) begin
1437                                if (wea_i[col])
1438                                  mem[addra_int][`ONE_COL_OF_DINA] &lt;= dina_i[`ONE_COL_OF_DINA];
1439                              end
1440                            end : wr_sync
1441                          end : for_mem_cols
1442                        end : gen_byte_narrow
1443                        else if (`MEM_PORTA_WR_BYTE &amp;&amp; `MEM_PORTA_WR_NARROW &amp;&amp; `WRITE_PROT_DISABLED) begin : gen_byte_narrow_wp
1444                          for (genvar col=0; col&lt;P_NUM_COLS_WRITE_A; col=col+1) begin : for_mem_cols
1445                            always @(posedge clka) begin : wr_sync
1446                                if (wea_i[col])
1447                                  mem[addra_int][`ONE_COL_OF_DINA] &lt;= dina_i[`ONE_COL_OF_DINA];
1448                            end : wr_sync
1449                          end : for_mem_cols
1450                        end : gen_byte_narrow_wp
1451                      // Error Injection in ECC modes (&quot;Both encode and Decode&quot; mode and &quot;Encode_only&quot; modes)
1452                      // Append required synthesis attributes
1453                        if(`BOTH_ENC_DEC || `ENC_ONLY) begin : err_inj_ecc
1454                          (* keep = &quot;yes&quot;, xpm_ecc_inject_sbiterr = &quot;yes&quot; *) wire injectsbiterra_i;
1455                          (* keep = &quot;yes&quot;, xpm_ecc_inject_dbiterr = &quot;yes&quot; *) wire injectdbiterra_i;
1456                    
1457                          // Declare injecterr inputs to synth ANDed with LSB data
1458                          (* keep = &quot;yes&quot; *) wire inj_sbiterra_to_synth;
1459                          (* keep = &quot;yes&quot; *) wire inj_dbiterra_to_synth;
1460                          if(`MEM_AUTO_SLP_EN) begin : gen_aslp_dly_inj_err
1461                            // Auto Sleep pipe line delays on the error inject signals      
1462                            reg injsbiterra_aslp_pipe    [AUTO_SLEEP_TIME-1:0]; 
1463                            reg injdbiterra_aslp_pipe    [AUTO_SLEEP_TIME-1:0];
1464                            // Initialize the inject error signal's pipe-lines
1465                            initial begin
1466                              integer aslp_initstage_a;
1467                              for (aslp_initstage_a=0; aslp_initstage_a&lt;AUTO_SLEEP_TIME; aslp_initstage_a=aslp_initstage_a+1) begin : for_injerr_pipe_init
1468                                injsbiterra_aslp_pipe[aslp_initstage_a] = 1'b0;
1469                                injdbiterra_aslp_pipe[aslp_initstage_a] = 1'b0;
1470                              end : for_injerr_pipe_init
1471                            end
1472                            // Connect the user inputs to the pipeline
1473                            always @(posedge clka)
1474                              begin
1475                                injsbiterra_aslp_pipe[0]  &lt;= injectsbiterra;
1476                                injdbiterra_aslp_pipe[0]  &lt;= injectdbiterra;
1477                              end
1478                            for (genvar aslp_stage=1; aslp_stage &lt; AUTO_SLEEP_TIME; aslp_stage = aslp_stage+1) begin : gen_aslp_inp_pipe
1479                              always @(posedge clka) begin
1480                                injsbiterra_aslp_pipe[aslp_stage]  &lt;= injsbiterra_aslp_pipe[aslp_stage-1];
1481                                injdbiterra_aslp_pipe[aslp_stage]  &lt;= injdbiterra_aslp_pipe[aslp_stage-1];
1482                              end
1483                            end : gen_aslp_inp_pipe
1484                            assign injectsbiterra_i  = injsbiterra_aslp_pipe[AUTO_SLEEP_TIME-1];
1485                            assign injectdbiterra_i  = injdbiterra_aslp_pipe[AUTO_SLEEP_TIME-1];
1486                          end : gen_aslp_dly_inj_err
1487                          else begin : gen_naslp_dly_inj_err
1488                            assign injectsbiterra_i = injectsbiterra;
1489                            assign injectdbiterra_i = injectdbiterra;
1490                          end : gen_naslp_dly_inj_err
1491                          //Assignment to error Injection signals passed to synthesis
1492                          assign inj_sbiterra_to_synth = injectsbiterra_i &amp; dina_i[0];
1493                          assign inj_dbiterra_to_synth = injectdbiterra_i &amp; dina_i[0];
1494                        end : err_inj_ecc
1495                    
1496                      end : gen_wr_a
1497                    
1498                      // -------------------------------------------------------------------------------------------------------------------
1499                      // Port B write
1500                      // -------------------------------------------------------------------------------------------------------------------
1501                    
1502                      // -------------------------------------------------------------------------------------------------------------------
1503                      // Auto Sleep delays for port-B
1504                      // -------------------------------------------------------------------------------------------------------------------
1505                    
1506                      wire enb_i;
1507                      wire [(WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B)-1:0] web_i;
1508                      wire [P_WIDTH_ADDR_WRITE_B-1:0] addrb_i;
1509                      wire [WRITE_DATA_WIDTH_B-1:0] dinb_i;
1510                      wire enb_o_pipe_ctrl;
1511                      wire regceb_i;
1512                      if(`MEM_AUTO_SLP_EN &amp;&amp; (`MEM_PORTB_WRITE || `MEM_PORTB_READ)) begin : gen_auto_slp_dly_b
1513                        reg [P_WIDTH_ADDR_WRITE_B-1:0] addrb_aslp_pipe [AUTO_SLEEP_TIME-1:0];
1514                        wire clkb_int;
1515                    
1516                        // In true dual port UltraRAM configurations, use the port A clock delayed by a small amount to model the port B
1517                        // synchronous processes; although both ports share a common clock, port B operations occur after port A operations
1518                        if (`COMMON_CLOCK &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; `MEM_TYPE_RAM_TDP) begin : gen_uram_tdp_common_clock
1519                          assign clkb_int = clka;
1520                        end : gen_uram_tdp_common_clock
1521                    
1522                        // In all other common clocking configurations, use the port A clock for port B synchronous processes
1523                        else if (`COMMON_CLOCK) begin : gen_common_clock
1524                          assign clkb_int = clka;
1525                        end : gen_common_clock
1526                    
1527                        // In independent clocking configurations, use the port B clock for port B synchronous processes
1528                        else if (`INDEPENDENT_CLOCKS) begin : gen_independent_clocks
1529                          assign clkb_int = clkb;
1530                        end : gen_independent_clocks
1531                    
1532                        // Check if write operation is allowed on Port-B, if yes then
1533                        // generate the pipeline register stages on write enable and input data
1534                        if(`MEM_PORTB_WRITE) begin : gen_aslp_wr_b
1535                          reg [(WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B)-1:0] web_aslp_pipe [AUTO_SLEEP_TIME-1:0];
1536                          reg [WRITE_DATA_WIDTH_B-1:0] dinb_aslp_pipe [AUTO_SLEEP_TIME-1:0];
1537                         // Initialize the web and dinb pipelines
1538                          initial begin
1539                            integer aslp_initstage_b;
1540                            for (aslp_initstage_b=0; aslp_initstage_b&lt;AUTO_SLEEP_TIME; aslp_initstage_b=aslp_initstage_b+1) begin : for_wr_en_pipe_init
1541                              web_aslp_pipe[aslp_initstage_b] = {(WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B){1'b0}};
1542                              dinb_aslp_pipe[aslp_initstage_b] = {WRITE_DATA_WIDTH_B{1'b0}};
1543                            end : for_wr_en_pipe_init
1544                          end
1545                         // Connect the user inputs to the pipeline
1546                          always @(posedge clkb_int) begin
1547                            web_aslp_pipe[0]    &lt;= web;
1548                            dinb_aslp_pipe[0]   &lt;= dinb;
1549                          end
1550                          for (genvar aslp_stage=1; aslp_stage &lt; AUTO_SLEEP_TIME; aslp_stage = aslp_stage+1) begin : gen_aslp_inp_pipe
1551                            always @(posedge clkb_int) begin
1552                              web_aslp_pipe[aslp_stage]   &lt;= web_aslp_pipe[aslp_stage-1];
1553                              dinb_aslp_pipe[aslp_stage]  &lt;= dinb_aslp_pipe[aslp_stage-1];
1554                            end
1555                          end : gen_aslp_inp_pipe
1556                        // Assign the last stage register outputs to appropriate internal signals
1557                            assign web_i  = web_aslp_pipe[AUTO_SLEEP_TIME-1];
1558                            assign dinb_i = dinb_aslp_pipe[AUTO_SLEEP_TIME-1];
1559                        end : gen_aslp_wr_b
1560                        // If write operation is not allowed, then connect the write control signals
1561                        // to zero
1562                        else begin : gnd_wr_b_ctrls
1563                          assign web_i  = {(WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B){1'b0}};
1564                          assign dinb_i = {(WRITE_DATA_WIDTH_B){1'b0}};
1565                        end : gnd_wr_b_ctrls
1566                        if(`MEM_PORTB_WRITE || `MEM_PORTB_READ) begin : gen_aslp_addr_b
1567                          // Generate the pipeline register stages on addrb
1568                          // Initialize the addrb pipelines
1569                          initial begin
1570                            integer aslp_initstage_b;
1571                            for (aslp_initstage_b=0; aslp_initstage_b&lt;AUTO_SLEEP_TIME; aslp_initstage_b=aslp_initstage_b+1) begin : for_addr_pipe_init
1572                              addrb_aslp_pipe[aslp_initstage_b] = {P_WIDTH_ADDR_WRITE_B{1'b0}};
1573                            end : for_addr_pipe_init
1574                          end
1575                          // Connect the user inputs to the pipeline
1576                          always @(posedge clkb_int)
1577                            begin
1578                              addrb_aslp_pipe[0]  &lt;= addrb;
1579                            end
1580                          for (genvar aslp_stage=1; aslp_stage &lt; AUTO_SLEEP_TIME; aslp_stage = aslp_stage+1) begin : gen_aslp_inp_pipe
1581                            always @(posedge clkb_int) begin
1582                              addrb_aslp_pipe[aslp_stage] &lt;= addrb_aslp_pipe[aslp_stage-1];
1583                            end
1584                          end : gen_aslp_inp_pipe
1585                          // Assign the last stage register outputs to internal address
1586                          assign addrb_i = addrb_aslp_pipe[AUTO_SLEEP_TIME-1];
1587                        end : gen_aslp_addr_b
1588                        else begin : gnd_addr_dly
1589                        // If write operation is not allowed, then connect the internal address to zero
1590                          assign addrb_i = {P_WIDTH_ADDR_WRITE_B{1'b0}};
1591                        end : gnd_addr_dly
1592                        // Check if read operation is not allowed, then connect the write control signals
1593                       // to zero
1594                        if(`MEM_PORTB_READ) begin : gen_aslp_rd_b
1595                          if(READ_LATENCY_B &gt;= 2) begin : gen_aslp_dly_regce
1596                            reg regceb_aslp_pipe [AUTO_SLEEP_TIME-1:0];
1597                            // Initialize the regceb pipelines
1598                            initial begin
1599                              integer aslp_initstage_b;
1600                              for (aslp_initstage_b=0; aslp_initstage_b&lt;AUTO_SLEEP_TIME; aslp_initstage_b=aslp_initstage_b+1) begin : for_regce_pipe_init
1601                                regceb_aslp_pipe[aslp_initstage_b] = 1'b0;
1602                              end : for_regce_pipe_init
1603                            end
1604                            // Connect the user inputs to the pipeline
1605                            always @(posedge clkb_int) begin
1606                              regceb_aslp_pipe[0] &lt;= regceb;
1607                            end
1608                            for (genvar aslp_stage=1; aslp_stage &lt; AUTO_SLEEP_TIME; aslp_stage = aslp_stage+1) begin : gen_aslp_inp_pipe
1609                              always @(posedge clkb_int) begin
1610                                regceb_aslp_pipe[aslp_stage]  &lt;= regceb_aslp_pipe[aslp_stage-1];
1611                              end
1612                            end : gen_aslp_inp_pipe
1613                          // Assign the last stage register outputs to internal regce 
1614                            assign  regceb_i = regceb_aslp_pipe[AUTO_SLEEP_TIME-1];
1615                          end : gen_aslp_dly_regce
1616                          else begin : gnd_regce_ctrl
1617                          // If there is no output pipeline, then connect regce to zero
1618                            assign regceb_i = 0;
1619                          end : gnd_regce_ctrl
1620                          if(READ_LATENCY_B &gt; 2) begin : gen_aslp_dly_out_pipe
1621                            reg enb_aslp_pipe [AUTO_SLEEP_TIME-1:0];
1622                            // Initialize the enb pipelines
1623                            initial begin
1624                              integer aslp_initstage_b;
1625                              for (aslp_initstage_b=0; aslp_initstage_b&lt;AUTO_SLEEP_TIME; aslp_initstage_b=aslp_initstage_b+1) begin : for_en_pipe_init
1626                                enb_aslp_pipe[aslp_initstage_b] = 1'b0;
1627                              end : for_en_pipe_init
1628                            end
1629                            // Connect the user inputs to the pipeline
1630                            always @(posedge clkb_int) begin
1631                              enb_aslp_pipe[0]    &lt;= enb;
1632                            end
1633                            for (genvar aslp_stage=1; aslp_stage &lt; AUTO_SLEEP_TIME; aslp_stage = aslp_stage+1) begin : gen_aslp_inp_pipe
1634                              always @(posedge clkb_int) begin
1635                                enb_aslp_pipe[aslp_stage]   &lt;= enb_aslp_pipe[aslp_stage-1];
1636                              end
1637                            end : gen_aslp_inp_pipe
1638                          // Assign the last stage register outputs to internal enable that controls
1639                          // the output pipeline
1640                            assign  enb_o_pipe_ctrl  = enb_aslp_pipe[AUTO_SLEEP_TIME-1];
1641                          end : gen_aslp_dly_out_pipe
1642                          else begin : gnd_pipe_en_ctrl
1643                          // If there is no output pipeline, then connect enable to zero
1644                            assign enb_o_pipe_ctrl = 1'b0;
1645                          end : gnd_pipe_en_ctrl
1646                        end : gen_aslp_rd_b
1647                      end : gen_auto_slp_dly_b
1648                      else begin : gen_nauto_slp_dly_b
1649                        // connect all the internal control signals to the ports when auto sleep is
1650                        // not enabled
1651                        assign web_i  = web;
1652                        assign dinb_i = dinb;
1653                        assign addrb_i = addrb;
1654                        assign enb_o_pipe_ctrl = enb;
1655                        assign regceb_i = regceb;
1656                      end : gen_nauto_slp_dly_b
1657                      // Enable needs to reach URAM early compared to other inputs in Auto Sleep
1658                      // Mode, so no pipe line stages on enable irrespective auto sleep mode
1659                      // enabled/disabled
1660                      assign enb_i    = enb;
1661                    
1662                      // If the memory type is true dual port RAM, generate a port B write process
1663                      if (`MEM_PORTB_WRITE &amp;&amp; !`DISABLE_SYNTH_TEMPL) begin : gen_wr_b
1664                        wire clkb_int;
1665                        wire [P_WIDTH_ADDR_WRITE_B-1:0] addrb_int = addrb_i;
1666                    
1667                        // In true dual port UltraRAM configurations, use the port A clock delayed by a small amount to model the port B
1668                        // synchronous processes; although both ports share a common clock, port B operations occur after port A operations
1669                        if (`COMMON_CLOCK &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; `MEM_TYPE_RAM_TDP) begin : gen_uram_tdp_common_clock
1670                          assign clkb_int = clka;
1671                        end : gen_uram_tdp_common_clock
1672                    
1673                        // In all other common clocking configurations, use the port A clock for port B synchronous processes
1674                        else if (`COMMON_CLOCK) begin : gen_common_clock
1675                          assign clkb_int = clka;
1676                        end : gen_common_clock
1677                    
1678                        // In independent clocking configurations, use the port B clock for port B synchronous processes
1679                        else if (`INDEPENDENT_CLOCKS) begin : gen_independent_clocks
1680                          assign clkb_int = clkb;
1681                        end : gen_independent_clocks
1682                    
1683                        // Synchronous port B write; word-wide write; port width is the narrowest of the data ports
1684                        if (`MEM_PORTB_WR_WORD &amp;&amp; `MEM_PORTB_WR_NARROW &amp;&amp; `WRITE_PROT_ENABLED) begin : gen_word_narrow
1685                          always @(posedge clkb_int) begin
1686       1/1                  if (enb_i) begin
1687       1/1                    if (web_i)
1688       <font color = "red">0/1     ==>              mem[addrb_int] &lt;= dinb_i;</font>
                        MISSING_ELSE
1689                            end
                        MISSING_ELSE
1690                          end
1691                        end : gen_word_narrow
1692                        else if (`MEM_PORTB_WR_WORD &amp;&amp; `MEM_PORTB_WR_NARROW &amp;&amp; `WRITE_PROT_DISABLED) begin : gen_word_narrow_wp
1693                          always @(posedge clkb_int) begin
1694                              if (web_i)
1695                                mem[addrb_int] &lt;= dinb_i;
1696                          end
1697                        end : gen_word_narrow_wp
1698                    
1699                        // Synchronous port B write; word-wide write; port width is wider than at least one other data port;
1700                        // not generated in port B write-first read with wide data width special case
1701                        else if (`MEM_PORTB_WR_WORD &amp;&amp; `MEM_PORTB_WR_WIDE &amp;&amp;
1702                               !(`MEM_TYPE_RAM_TDP &amp;&amp; `MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_WIDE) &amp;&amp; `WRITE_PROT_ENABLED) begin : gen_word_wide
1703                          always @(posedge clkb_int) begin : wr_sync
1704                            integer row;
1705                            reg [P_WIDTH_ADDR_LSB_WRITE_B-1:0] addrblsb;
1706                            for (row=0; row&lt;P_NUM_ROWS_WRITE_B; row=row+1) begin : for_mem_rows
1707                              addrblsb = row;
1708                              if (enb_i) begin
1709                                if (web_i)
1710                                  mem[{addrb_int, addrblsb}] &lt;= dinb_i[`ONE_ROW_OF_DIN];
1711                              end
1712                            end : for_mem_rows
1713                          end : wr_sync
1714                        end : gen_word_wide
1715                        else if (`MEM_PORTB_WR_WORD &amp;&amp; `MEM_PORTB_WR_WIDE &amp;&amp;
1716                               !(`MEM_TYPE_RAM_TDP &amp;&amp; `MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_WIDE) &amp;&amp; `WRITE_PROT_DISABLED) begin : gen_word_wide_wp
1717                          always @(posedge clkb_int) begin : wr_sync
1718                            integer row;
1719                            reg [P_WIDTH_ADDR_LSB_WRITE_B-1:0] addrblsb;
1720                            for (row=0; row&lt;P_NUM_ROWS_WRITE_B; row=row+1) begin : for_mem_rows
1721                              addrblsb = row;
1722                                if (web_i)
1723                                  mem[{addrb_int, addrblsb}] &lt;= dinb_i[`ONE_ROW_OF_DIN];
1724                            end : for_mem_rows
1725                          end : wr_sync
1726                        end : gen_word_wide_wp
1727                        
1728                        else if (`MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_WIDE &amp;&amp; `MEM_PORTB_RD_REG &amp;&amp; `WRITE_PROT_ENABLED) begin : gen_wf_wide_reg
1729                          always @(posedge clkb_int) begin : wr_rd_sync
1730                            integer row;
1731                            reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
1732                            for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
1733                              addrblsb = row;
1734                                if (enb_i) begin
1735                                  if (web_i)
1736                                    mem[{addrb_int, addrblsb}] &lt;= dinb_i[`ONE_ROW_OF_DIN];
1737                                end
1738                            end : for_mem_rows
1739                          end : wr_rd_sync
1740                        end : gen_wf_wide_reg
1741                        else if (`MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_WIDE &amp;&amp; `MEM_PORTB_RD_REG &amp;&amp; `WRITE_PROT_DISABLED) begin : gen_wf_wide_reg_wp
1742                          always @(posedge clkb_int) begin : wr_rd_sync
1743                            integer row;
1744                            reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
1745                            for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
1746                              addrblsb = row;
1747                                  if (web_i)
1748                                    mem[{addrb_int, addrblsb}] &lt;= dinb_i[`ONE_ROW_OF_DIN];
1749                            end : for_mem_rows
1750                          end : wr_rd_sync
1751                        end : gen_wf_wide_reg_wp
1752                    
1753                        // Synchronous port B write; byte-wide write; port width is the narrowest of the data ports
1754                        else if (`MEM_PORTB_WR_BYTE &amp;&amp; `MEM_PORTB_WR_NARROW &amp;&amp; `WRITE_PROT_ENABLED) begin : gen_byte_narrow
1755                          for (genvar col=0; col&lt;P_NUM_COLS_WRITE_B; col=col+1) begin : for_mem_cols
1756                            always @(posedge clkb_int) begin : wr_sync
1757                              if (enb_i) begin
1758                                if (web_i[col])
1759                                  mem[addrb_int][`ONE_COL_OF_DINB] &lt;= dinb_i[`ONE_COL_OF_DINB];
1760                              end
1761                            end : wr_sync
1762                          end : for_mem_cols
1763                        end : gen_byte_narrow
1764                        else if (`MEM_PORTB_WR_BYTE &amp;&amp; `MEM_PORTB_WR_NARROW &amp;&amp; `WRITE_PROT_DISABLED) begin : gen_byte_narrow_wp
1765                          for (genvar col=0; col&lt;P_NUM_COLS_WRITE_B; col=col+1) begin : for_mem_cols
1766                            always @(posedge clkb_int) begin : wr_sync
1767                                if (web_i[col])
1768                                  mem[addrb_int][`ONE_COL_OF_DINB] &lt;= dinb_i[`ONE_COL_OF_DINB];
1769                            end : wr_sync
1770                          end : for_mem_cols
1771                        end : gen_byte_narrow_wp
1772                      // Error Injection in ECC modes (&quot;Both encode and Decode&quot; mode and &quot;Encode_only&quot; modes)
1773                      // Append required synthesis attributes
1774                        if(`BOTH_ENC_DEC || `ENC_ONLY) begin : err_inj_ecc
1775                          (* keep = &quot;yes&quot;, xpm_ecc_inject_sbiterr = &quot;yes&quot; *) reg injectsbiterrb_i;
1776                          (* keep = &quot;yes&quot;, xpm_ecc_inject_dbiterr = &quot;yes&quot; *) reg injectdbiterrb_i;
1777                    
1778                          // Declare injecterr inputs to synth ANDed with LSB data
1779                          (* keep = &quot;yes&quot; *) wire inj_sbiterrb_to_synth;
1780                          (* keep = &quot;yes&quot; *) wire inj_dbiterrb_to_synth;
1781                          if(`MEM_AUTO_SLP_EN) begin : gen_aslp_dly_inj_err
1782                            // Auto Sleep pipe line delays on the error inject signals      
1783                            reg injsbiterrb_aslp_pipe    [AUTO_SLEEP_TIME-1:0];
1784                            reg injdbiterrb_aslp_pipe    [AUTO_SLEEP_TIME-1:0];
1785                    
1786                            // Initialize the error injection pipelines
1787                            initial begin
1788                              integer aslp_initstage_b;
1789                              for (aslp_initstage_b=0; aslp_initstage_b&lt;AUTO_SLEEP_TIME; aslp_initstage_b=aslp_initstage_b+1) begin : for_injerr_pipe_init
1790                                injsbiterrb_aslp_pipe[aslp_initstage_b] = 1'b0;
1791                                injdbiterrb_aslp_pipe[aslp_initstage_b] = 1'b0;
1792                              end : for_injerr_pipe_init
1793                            end
1794                           // Connect the user inputs to the pipeline
1795                            always @(posedge clkb_int) begin
1796                              injsbiterrb_aslp_pipe[0]  &lt;= injectsbiterrb;
1797                              injdbiterrb_aslp_pipe[0]  &lt;= injectdbiterrb;
1798                            end
1799                            for (genvar aslp_stage=1; aslp_stage &lt; AUTO_SLEEP_TIME; aslp_stage = aslp_stage+1) begin : gen_aslp_inp_pipe
1800                              always @(posedge clkb_int) begin
1801                                injsbiterrb_aslp_pipe[aslp_stage]  &lt;= injsbiterrb_aslp_pipe[aslp_stage-1];
1802                                injdbiterrb_aslp_pipe[aslp_stage]  &lt;= injdbiterrb_aslp_pipe[aslp_stage-1];
1803                              end
1804                            end : gen_aslp_inp_pipe
1805                            assign  injectsbiterrb_i  = injsbiterrb_aslp_pipe[AUTO_SLEEP_TIME-1];
1806                            assign  injectdbiterrb_i  = injdbiterrb_aslp_pipe[AUTO_SLEEP_TIME-1];
1807                          end : gen_aslp_dly_inj_err
1808                          else begin : gen_naslp_dly_inj_err
1809                            assign injectsbiterrb_i = injectsbiterrb;
1810                            assign injectdbiterrb_i = injectdbiterrb;
1811                          end : gen_naslp_dly_inj_err
1812                          //Assignment to error Injection signals passed to synthesis
1813                          assign inj_sbiterrb_to_synth = injectsbiterrb_i &amp; dinb_i[0];
1814                          assign inj_dbiterrb_to_synth = injectdbiterrb_i &amp; dinb_i[0];
1815                        end : err_inj_ecc
1816                      end : gen_wr_b
1817                    
1818                      // -------------------------------------------------------------------------------------------------------------------
1819                      // Black Box Instantiation
1820                      // -------------------------------------------------------------------------------------------------------------------
1821                      if(`DISABLE_SYNTH_TEMPL) begin : gen_blk_box
1822                        // Delayed ports(with auto sleep latency) are not connected to this module, as this module is used
1823                        // for asymmetry and URAM does not support asymmetry
1824                        if(`COMMON_CLOCK) begin : gen_bb_sync
1825                          asym_bwe_bb # (
1826                            // Common module parameters
1827                            .MEMORY_TYPE        (MEMORY_TYPE       ),
1828                            .MEMORY_SIZE        (MEMORY_SIZE       ),
1829                            .MEMORY_PRIMITIVE   (MEMORY_PRIMITIVE  ),
1830                            .CLOCKING_MODE      (0                 ), // Common Clock
1831                            .MEMORY_INIT_FILE   (MEMORY_INIT_FILE  ),
1832                            .MEMORY_INIT_PARAM  (MEMORY_INIT_PARAM ),
1833                            .WAKEUP_TIME        (WAKEUP_TIME       ),
1834                            .AUTO_SLEEP_TIME    (AUTO_SLEEP_TIME   ),
1835                    
1836                            // Port A module parameters
1837                            .WRITE_DATA_WIDTH_A (WRITE_DATA_WIDTH_A),
1838                            .READ_DATA_WIDTH_A  (READ_DATA_WIDTH_A ),
1839                            .BYTE_WRITE_WIDTH_A (BYTE_WRITE_WIDTH_A),
1840                            .ADDR_WIDTH_A       (ADDR_WIDTH_A      ),
1841                            .READ_RESET_VALUE_A (READ_RESET_VALUE_A),
1842                            .READ_LATENCY_A     (READ_LATENCY_A    ),
1843                            .WRITE_MODE_A       (WRITE_MODE_A      ),
1844                            .RST_MODE_A         (RST_MODE_A        ),
1845                    
1846                            // Port B module parameters
1847                            .WRITE_DATA_WIDTH_B (WRITE_DATA_WIDTH_B),
1848                            .READ_DATA_WIDTH_B  (READ_DATA_WIDTH_B ),
1849                            .BYTE_WRITE_WIDTH_B (BYTE_WRITE_WIDTH_B),
1850                            .ADDR_WIDTH_B       (ADDR_WIDTH_B      ),
1851                            .READ_RESET_VALUE_B (READ_RESET_VALUE_B),
1852                            .READ_LATENCY_B     (READ_LATENCY_B    ),
1853                            .WRITE_MODE_B       (WRITE_MODE_B      ),
1854                            .RST_MODE_B         (RST_MODE_B        )
1855                          ) xpm_memory_base_inst (
1856                    
1857                            // Common module ports
1858                            .sleep          (sleep                 ),
1859                    
1860                            // Port A module ports
1861                            .clka           (clka                  ),
1862                            .rsta           (rsta                  ),
1863                            .ena            (ena                   ),
1864                            .regcea         (regcea                ),
1865                            .wea            (wea                   ),
1866                            .addra          (addra                 ),
1867                            .dina           (dina                  ),
1868                            .douta          (douta_bb              ),
1869                    
1870                            // Port B module ports
1871                            .clkb           (clka                  ),
1872                            .rstb           (rstb                  ),
1873                            .enb            (enb                   ),
1874                            .regceb         (regceb                ),
1875                            .web            (web                   ),
1876                            .addrb          (addrb                 ),
1877                            .dinb           (dinb                  ),
1878                            .doutb          (doutb_bb              )
1879                          );
1880                          end : gen_bb_sync
1881                          else begin : gen_bb_async
1882                            asym_bwe_bb # (
1883                              // Common module parameters
1884                              .MEMORY_TYPE        (MEMORY_TYPE       ),
1885                              .MEMORY_SIZE        (MEMORY_SIZE       ),
1886                              .MEMORY_PRIMITIVE   (MEMORY_PRIMITIVE  ),
1887                              .CLOCKING_MODE      (1                 ), // Independent Clock
1888                              .MEMORY_INIT_FILE   (MEMORY_INIT_FILE  ),
1889                              .MEMORY_INIT_PARAM  (MEMORY_INIT_PARAM ),
1890                              .WAKEUP_TIME        (WAKEUP_TIME       ),
1891                              .AUTO_SLEEP_TIME    (AUTO_SLEEP_TIME   ),
1892                    
1893                              // Port A module parameters
1894                              .WRITE_DATA_WIDTH_A (WRITE_DATA_WIDTH_A),
1895                              .READ_DATA_WIDTH_A  (READ_DATA_WIDTH_A ),
1896                              .BYTE_WRITE_WIDTH_A (BYTE_WRITE_WIDTH_A),
1897                              .ADDR_WIDTH_A       (ADDR_WIDTH_A      ),
1898                              .READ_RESET_VALUE_A (READ_RESET_VALUE_A),
1899                              .READ_LATENCY_A     (READ_LATENCY_A    ),
1900                              .WRITE_MODE_A       (WRITE_MODE_A      ),
1901                    
1902                              // Port B module parameters
1903                              .WRITE_DATA_WIDTH_B (WRITE_DATA_WIDTH_B),
1904                              .READ_DATA_WIDTH_B  (READ_DATA_WIDTH_B ),
1905                              .BYTE_WRITE_WIDTH_B (BYTE_WRITE_WIDTH_B),
1906                              .ADDR_WIDTH_B       (ADDR_WIDTH_B      ),
1907                              .READ_RESET_VALUE_B (READ_RESET_VALUE_B),
1908                              .READ_LATENCY_B     (READ_LATENCY_B    ),
1909                              .WRITE_MODE_B       (WRITE_MODE_B      )
1910                            ) xpm_memory_base_inst (
1911                    
1912                              // Common module ports
1913                              .sleep          (sleep                 ),
1914                    
1915                              // Port A module ports
1916                              .clka           (clka                  ),
1917                              .rsta           (rsta                  ),
1918                              .ena            (ena                   ),
1919                              .regcea         (regcea                ),
1920                              .wea            (wea                   ),
1921                              .addra          (addra                 ),
1922                              .dina           (dina                  ),
1923                              .douta          (douta_bb              ),
1924                    
1925                              // Port B module ports
1926                              .clkb           (clkb                  ),
1927                              .rstb           (rstb                  ),
1928                              .enb            (enb                   ),
1929                              .regceb         (regceb                ),
1930                              .web            (web                   ),
1931                              .addrb          (addrb                 ),
1932                              .dinb           (dinb                  ),
1933                              .doutb          (doutb_bb              )
1934                            );
1935                          end : gen_bb_async
1936                      end : gen_blk_box
1937                    
1938                      // -------------------------------------------------------------------------------------------------------------------
1939                      // Port A read
1940                      // -------------------------------------------------------------------------------------------------------------------
1941                    
1942                      // If the memory type is single port RAM, true dual port RAM, or any ROM, generate a port A read process
1943                      if (`MEM_PORTA_READ) begin : gen_rd_a
1944                        localparam READ_DATA_WIDTH_A_ECC = `NO_ECC ? READ_DATA_WIDTH_A : P_MIN_WIDTH_DATA_ECC;
1945                        wire [P_WIDTH_ADDR_READ_A-1:0] addra_int = addra_i;
1946                        reg [READ_DATA_WIDTH_A_ECC-1:0] douta_reg;
1947                        localparam logic [READ_DATA_WIDTH_A_ECC-1:0] rsta_val = `ASYNC_RESET_A ? {READ_DATA_WIDTH_A_ECC{1'b0}} : rst_val_conv_a(READ_RESET_VALUE_A);
1948                        reg sbiterra_i = 1'b0 ;
1949                        reg dbiterra_i = 1'b0 ;
1950                    
1951                        initial begin
1952       1/1                if (`MEM_PORTA_RD_REG) begin : init_rstval
1953       <font color = "red">0/1     ==>          douta_reg = rsta_val;</font>
1954                          end : init_rstval
1955       1/1                else if (`MEM_PORTA_RD_PIPE &amp;&amp; `MEM_PORTA_NC) begin : init_rstval_NC
1956       1/1                  douta_reg = rsta_val;
1957                          end : init_rstval_NC
1958       <font color = "red">0/1     ==>        else if (`MEM_PORTA_RD_PIPE &amp;&amp; (`MEM_PORTA_WF || `MEM_PORTA_RF)) begin : init_zero</font>
1959       <font color = "red">0/1     ==>          douta_reg = {READ_DATA_WIDTH_A_ECC{1'b0}};</font>
1960                          end : init_zero
                   <font color = "red">==>  MISSING_ELSE</font>
1961                        end
1962                        if (!`DISABLE_SYNTH_TEMPL) begin : gen_rd_a_synth_template
1963                          // Asynchronous port A read; port width is the narrowest of the data ports; no output pipeline
1964                          if (`MEM_PORTA_RD_NARROW &amp;&amp; `MEM_PORTA_RD_COMB) begin : gen_narrow_comb
1965                            always @(*) begin
1966                              douta_reg = mem[addra_int];
1967                            end
1968                          end : gen_narrow_comb
1969                    
1970                          // Asynchronous port A read; port width is wider than at least one other data port; no output pipeline
1971                          else if (`MEM_PORTA_RD_WIDE &amp;&amp; `MEM_PORTA_RD_COMB) begin : gen_wide_comb
1972                            always @(*) begin : rd_comb
1973                              integer row;
1974                              reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
1975                              for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
1976                                addralsb = row;
1977                                douta_reg[`ONE_ROW_OF_DIN] = mem[{addra_int, addralsb}];
1978                              end : for_mem_rows
1979                            end : rd_comb
1980                          end : gen_wide_comb
1981                    
1982                          // Synchronous port A write-first read; port width is the narrowest of the data ports; no output pipeline
1983                          else if (`MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_NARROW &amp;&amp; `MEM_PORTA_RD_REG &amp;&amp; `MEM_PORTA_WR_WORD) begin : gen_wf_narrow_reg
1984                            if(`ASYNC_RESET_A) begin
1985                              always @(posedge rsta or posedge clka) begin
1986                                if (rsta)
1987                                  douta_reg &lt;= rsta_val;
1988                                else begin
1989                                  if (ena_i) begin
1990                                    if (wea_i)
1991                                      douta_reg &lt;= dina_i;
1992                                    else
1993                                      douta_reg &lt;= mem[addra_int];
1994                                  end
1995                                end
1996                              end
1997                            end
1998                            else begin
1999                              always @(posedge clka) begin
2000                                if (rsta)
2001                                  douta_reg &lt;= rsta_val;
2002                                else begin
2003                                  if (ena_i) begin
2004                                    if (wea_i)
2005                                      douta_reg &lt;= dina_i;
2006                                    else
2007                                      douta_reg &lt;= mem[addra_int];
2008                                  end
2009                                end
2010                              end
2011                            end
2012                          end : gen_wf_narrow_reg
2013                    
2014                          // Synchronous port A write-first read; port width is the narrowest of the data ports; no output pipeline;
2015                          // symmetric byte-wide write special case
2016                          else if (`MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_NARROW &amp;&amp; `MEM_PORTA_RD_REG &amp;&amp;
2017                                   `MEM_PORTA_WR_NARROW &amp;&amp; `MEM_PORTA_WR_BYTE) begin : gen_wf_narrow_reg_sym_byte
2018                            for (genvar col=0; col&lt;P_NUM_COLS_WRITE_A; col=col+1) begin : for_mem_cols
2019                              if(`ASYNC_RESET_A) begin
2020                                always @(posedge rsta or posedge clka) begin : wr_sync
2021                                  if (rsta)
2022                                    douta_reg[`ONE_COL_OF_DINA] &lt;= rsta_val[`ONE_COL_OF_DINA];
2023                                  else begin
2024                                    if (ena_i) begin
2025                                      if (wea_i[col])
2026                                        douta_reg[`ONE_COL_OF_DINA] &lt;= dina_i[`ONE_COL_OF_DINA];
2027                                      else
2028                                        douta_reg[`ONE_COL_OF_DINA] &lt;= mem[addra_int][`ONE_COL_OF_DINA];
2029                                    end
2030                                  end
2031                                end : wr_sync
2032                              end
2033                              else begin 
2034                                always @(posedge clka) begin : wr_sync
2035                                  if (rsta)
2036                                    douta_reg[`ONE_COL_OF_DINA] &lt;= rsta_val[`ONE_COL_OF_DINA];
2037                                  else begin
2038                                    if (ena_i) begin
2039                                      if (wea_i[col])
2040                                        douta_reg[`ONE_COL_OF_DINA] &lt;= dina_i[`ONE_COL_OF_DINA];
2041                                      else
2042                                        douta_reg[`ONE_COL_OF_DINA] &lt;= mem[addra_int][`ONE_COL_OF_DINA];
2043                                    end
2044                                  end
2045                                end : wr_sync
2046                              end
2047                            end : for_mem_cols
2048                          end : gen_wf_narrow_reg_sym_byte
2049                    
2050                          // Synchronous port A write-first read; port width is the narrowest of the data ports; output pipeline
2051                          else if (`MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_NARROW &amp;&amp; `MEM_PORTA_RD_PIPE &amp;&amp; `MEM_PORTA_WR_WORD) begin : gen_wf_narrow_pipe
2052                            always @(posedge clka) begin
2053                              if (ena_i) begin
2054                                if (wea_i)
2055                                  douta_reg &lt;= dina_i;
2056                                else
2057                                  douta_reg &lt;= mem[addra_int];
2058                              end
2059                            end
2060                          end : gen_wf_narrow_pipe
2061                    
2062                          // Synchronous port A write-first read; port width is the narrowest of the data ports; output pipeline;
2063                          // symmetric byte-wide write special case
2064                          else if (`MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_NARROW &amp;&amp; `MEM_PORTA_RD_PIPE &amp;&amp;
2065                                   `MEM_PORTA_WR_NARROW &amp;&amp; `MEM_PORTA_WR_BYTE) begin : gen_wf_narrow_pipe_sym_byte
2066                            for (genvar col=0; col&lt;P_NUM_COLS_WRITE_A; col=col+1) begin : for_mem_cols
2067                              always @(posedge clka) begin : wr_sync
2068                                if (ena_i) begin
2069                                  if (wea_i[col])
2070                                    douta_reg[`ONE_COL_OF_DINA] &lt;= dina_i[`ONE_COL_OF_DINA];
2071                                  else
2072                                    douta_reg[`ONE_COL_OF_DINA] &lt;= mem[addra_int][`ONE_COL_OF_DINA];
2073                                end
2074                              end : wr_sync
2075                            end : for_mem_cols
2076                          end : gen_wf_narrow_pipe_sym_byte
2077                    
2078                          // Synchronous port A write-first read; port width is wider than at least one other data port; no output pipeline;
2079                          // write and read combined special case
2080                          else if (`MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_WIDE &amp;&amp; `MEM_PORTA_RD_REG) begin : gen_wf_wide_reg
2081                            if(`ASYNC_RESET_A) begin
2082                              always @(posedge rsta or posedge clka) begin : wr_rd_sync
2083                                integer row;
2084                                reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
2085                                for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
2086                                  addralsb = row;
2087                                  if (rsta)
2088                                    douta_reg[`ONE_ROW_OF_DIN] &lt;= rsta_val[`ONE_ROW_OF_DIN];
2089                                  else begin
2090                                    if (ena_i) begin
2091                                      if (wea_i)
2092                                        douta_reg[`ONE_ROW_OF_DIN] &lt;= dina_i[`ONE_ROW_OF_DIN];
2093                                      else
2094                                        douta_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addra_int, addralsb}];
2095                                    end
2096                                  end
2097                                end : for_mem_rows
2098                              end : wr_rd_sync
2099                            end
2100                            else begin 
2101                              always @(posedge clka) begin : wr_rd_sync
2102                                integer row;
2103                                reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
2104                                for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
2105                                  addralsb = row;
2106                                  if (rsta)
2107                                    douta_reg[`ONE_ROW_OF_DIN] &lt;= rsta_val[`ONE_ROW_OF_DIN];
2108                                  else begin
2109                                    if (ena_i) begin
2110                                      if (wea_i)
2111                                        douta_reg[`ONE_ROW_OF_DIN] &lt;= dina_i[`ONE_ROW_OF_DIN];
2112                                      else
2113                                        douta_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addra_int, addralsb}];
2114                                    end
2115                                  end
2116                                end : for_mem_rows
2117                              end : wr_rd_sync
2118                            end
2119                          end : gen_wf_wide_reg
2120                    
2121                          // Synchronous port A write-first read; port width is wider than at least one other data port; output pipeline;
2122                          // write and read combined special case
2123                          else if (`MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_WIDE &amp;&amp; `MEM_PORTA_RD_PIPE) begin : gen_wf_wide_pipe
2124                            always @(posedge clka) begin : wr_rd_sync
2125                              integer row;
2126                              reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
2127                              for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
2128                                addralsb = row;
2129                                if (ena_i) begin
2130                                  if (wea_i)
2131                                    mem[{addra_int, addralsb}] = dina_i[`ONE_ROW_OF_DIN];
2132                                  douta_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addra_int, addralsb}];
2133                                end
2134                              end : for_mem_rows
2135                            end : wr_rd_sync
2136                          end : gen_wf_wide_pipe
2137                    
2138                          // Synchronous port A read-first read; port width is the narrowest of the data ports; no output pipeline
2139                          else if (`MEM_PORTA_RF &amp;&amp; `MEM_PORTA_RD_NARROW &amp;&amp; `MEM_PORTA_RD_REG) begin : gen_rf_narrow_reg
2140                            if(`ASYNC_RESET_A) begin
2141                              always @(posedge rsta or posedge clka) begin
2142                                if (rsta)
2143                                  douta_reg &lt;= rsta_val;
2144                                else begin
2145                                  if (ena_i)
2146                                    douta_reg &lt;= mem[addra_int];
2147                                end
2148                              end
2149                            end
2150                            else begin
2151                              always @(posedge clka) begin
2152                                if (rsta)
2153                                  douta_reg &lt;= rsta_val;
2154                                else begin
2155                                  if (ena_i)
2156                                    douta_reg &lt;= mem[addra_int];
2157                                end
2158                              end
2159                            end
2160                          end : gen_rf_narrow_reg
2161                    
2162                          // Synchronous port A read-first read; port width is the narrowest of the data ports; output pipeline
2163                          else if (`MEM_PORTA_RF &amp;&amp; `MEM_PORTA_RD_NARROW &amp;&amp; `MEM_PORTA_RD_PIPE) begin : gen_rf_narrow_pipe
2164                            always @(posedge clka) begin
2165                              if (ena_i)
2166                                douta_reg &lt;= mem[addra_int];
2167                            end
2168                          end : gen_rf_narrow_pipe
2169                    
2170                          // Synchronous port A read-first read; port width is wider than at least one other data port; no output pipeline
2171                          else if (`MEM_PORTA_RF &amp;&amp; `MEM_PORTA_RD_WIDE &amp;&amp; `MEM_PORTA_RD_REG) begin : gen_rf_wide_reg
2172                            if(`ASYNC_RESET_A) begin
2173                              always @(posedge rsta or posedge clka) begin : rd_sync
2174                                integer row;
2175                                reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
2176                                for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
2177                                  addralsb = row;
2178                                  if (rsta)
2179                                    douta_reg[`ONE_ROW_OF_DIN] &lt;= rsta_val[`ONE_ROW_OF_DIN];
2180                                  else begin
2181                                    if (ena_i)
2182                                      douta_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addra_int, addralsb}];
2183                                  end
2184                                end : for_mem_rows
2185                              end : rd_sync
2186                            end
2187                            else begin
2188                              always @(posedge clka) begin : rd_sync
2189                                integer row;
2190                                reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
2191                                for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
2192                                  addralsb = row;
2193                                  if (rsta)
2194                                    douta_reg[`ONE_ROW_OF_DIN] &lt;= rsta_val[`ONE_ROW_OF_DIN];
2195                                  else begin
2196                                    if (ena_i)
2197                                      douta_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addra_int, addralsb}];
2198                                  end
2199                                end : for_mem_rows
2200                              end : rd_sync
2201                            end
2202                          end : gen_rf_wide_reg
2203                    
2204                          // Synchronous port A read-first read; port width is wider than at least one other data port; output pipeline
2205                          else if (`MEM_PORTA_RF &amp;&amp; `MEM_PORTA_RD_WIDE &amp;&amp; `MEM_PORTA_RD_PIPE) begin : gen_rf_wide_pipe
2206                            always @(posedge clka) begin : rd_sync
2207                              integer row;
2208                              reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
2209                              for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
2210                                addralsb = row;
2211                                if (ena_i)
2212                                  douta_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addra_int, addralsb}];
2213                              end : for_mem_rows
2214                            end : rd_sync
2215                          end : gen_rf_wide_pipe
2216                    
2217                          // Synchronous port A no-change read; port width is the narrowest of the data ports; no output pipeline
2218                          else if (`MEM_PORTA_NC &amp;&amp; `MEM_PORTA_RD_NARROW &amp;&amp; `MEM_PORTA_RD_REG) begin : gen_nc_narrow_reg
2219                            if(`ASYNC_RESET_A) begin
2220                              always @(posedge rsta or posedge clka) begin
2221                                if (rsta)
2222                                  douta_reg &lt;= rsta_val;
2223                                else begin
2224                                  if (ena_i) begin
2225                                    if (~|wea_i)
2226                                      douta_reg &lt;= mem[addra_int];
2227                                  end
2228                                end
2229                              end
2230                            end
2231                            else begin
2232                              always @(posedge clka) begin
2233                                if (rsta)
2234                                  douta_reg &lt;= rsta_val;
2235                                else begin
2236                                  if (ena_i) begin
2237                                    if (~|wea_i)
2238                                      douta_reg &lt;= mem[addra_int];
2239                                  end
2240                                end
2241                              end
2242                            end
2243                          end : gen_nc_narrow_reg
2244                    
2245                          // Synchronous port A no-change read; port width is the narrowest of the data ports; output pipeline
2246                          else if (`MEM_PORTA_NC &amp;&amp; `MEM_PORTA_RD_NARROW &amp;&amp; `MEM_PORTA_RD_PIPE) begin : gen_nc_narrow_pipe
2247                            always @(posedge clka) begin
2248       1/1                    if (ena_i) begin
2249       1/1                      if (~|wea_i)
2250       1/1                        douta_reg &lt;= mem[addra_int];
                   <font color = "red">==>  MISSING_ELSE</font>
2251                              end
                        MISSING_ELSE
2252                            end
2253                          end : gen_nc_narrow_pipe
2254                    
2255                          // Synchronous port A no-change read; port width is wider than at least one other data port; no output pipeline
2256                          else if (`MEM_PORTA_NC &amp;&amp; `MEM_PORTA_RD_WIDE &amp;&amp; `MEM_PORTA_RD_REG) begin : gen_nc_wide_reg
2257                            if(`ASYNC_RESET_A) begin
2258                              always @(posedge rsta or posedge clka) begin : rd_sync
2259                                integer row;
2260                                reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
2261                                for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
2262                                  addralsb = row;
2263                                  if (rsta)
2264                                    douta_reg[`ONE_ROW_OF_DIN] &lt;= rsta_val[`ONE_ROW_OF_DIN];
2265                                  else begin
2266                                    if (ena_i) begin
2267                                      if (~|wea_i)
2268                                        douta_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addra_int, addralsb}];
2269                                    end
2270                                  end
2271                                end : for_mem_rows
2272                              end : rd_sync
2273                            end
2274                            else begin
2275                              always @(posedge clka) begin : rd_sync
2276                                integer row;
2277                                reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
2278                                for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
2279                                  addralsb = row;
2280                                  if (rsta)
2281                                    douta_reg[`ONE_ROW_OF_DIN] &lt;= rsta_val[`ONE_ROW_OF_DIN];
2282                                  else begin
2283                                    if (ena_i) begin
2284                                      if (~|wea_i)
2285                                        douta_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addra_int, addralsb}];
2286                                    end
2287                                  end
2288                                end : for_mem_rows
2289                              end : rd_sync
2290                            end
2291                          end : gen_nc_wide_reg
2292                    
2293                          // Synchronous port A no-change read; port width is wider than at least one other data port; output pipeline
2294                          else if (`MEM_PORTA_NC &amp;&amp; `MEM_PORTA_RD_WIDE &amp;&amp; `MEM_PORTA_RD_PIPE) begin : gen_nc_wide_pipe
2295                            always @(posedge clka) begin : rd_sync
2296                              integer row;
2297                              reg [P_WIDTH_ADDR_LSB_READ_A-1:0] addralsb;
2298                              for (row=0; row&lt;P_NUM_ROWS_READ_A; row=row+1) begin : for_mem_rows
2299                                addralsb = row;
2300                                if (ena_i) begin
2301                                  if (~|wea_i)
2302                                    douta_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addra_int, addralsb}];
2303                                end
2304                              end : for_mem_rows
2305                            end : rd_sync
2306                          end : gen_nc_wide_pipe
2307                        end : gen_rd_a_synth_template
2308                        else begin : gen_rd_a_synth_black_box
2309                          always @(*) begin
2310                            douta_reg = douta_bb;
2311                          end
2312                        end : gen_rd_a_synth_black_box
2313                    
2314                        // If no output pipeline is used, then the enabled read process directly drives the data output port
2315                        if (`MEM_PORTA_RD_COMB || `MEM_PORTA_RD_REG) begin : gen_douta
2316                          assign douta = douta_reg;
2317                        end : gen_douta
2318                    
2319                        // If an output pipeline is used, generate it
2320                        else if (`MEM_PORTA_RD_PIPE) begin : gen_douta_pipe
2321                          reg                         ena_pipe   [READ_LATENCY_A-2:0];
2322                          reg [READ_DATA_WIDTH_A_ECC-1:0] douta_pipe [READ_LATENCY_A-2:0];
2323                    
2324                          always @(posedge clka) begin
2325       1/1                  ena_pipe[0] &lt;= ena_o_pipe_ctrl;
2326                          end
2327                    
2328                          // Initialize the final output pipeline stage to the specified reset value, and all prior stages to zero
2329                          initial begin
2330                            integer initstage;
2331       1/1                  for (initstage=0; initstage&lt;READ_LATENCY_A-1; initstage=initstage+1) begin : for_pipe_init
2332       1/1                    if (initstage &lt; READ_LATENCY_A-2 &amp;&amp; (`MEM_PORTA_WF || `MEM_PORTA_RF)) begin : init_zero
2333       <font color = "red">0/1     ==>              douta_pipe[initstage] = {READ_DATA_WIDTH_A{1'b0}};</font>
2334                              end : init_zero
2335       1/1                    else if (initstage &lt; READ_LATENCY_A-2 &amp;&amp; `MEM_PORTA_NC) begin : init_rstval_NC
2336       <font color = "red">0/1     ==>              douta_pipe[initstage] = rsta_val;</font>
2337                              end : init_rstval_NC
2338                              else begin : init_rstval
2339       1/1                      douta_pipe[initstage] = rsta_val;
2340                              end : init_rstval
2341                            end : for_pipe_init
2342                          end
2343                    
2344                          // If two stages are used, the synchronous read output drives the final pipeline stage
2345                          if (READ_LATENCY_A == 2) begin : gen_stage
2346                            if(`ASYNC_RESET_A) begin
2347                              always @(posedge rsta or posedge clka) begin
2348                                if (rsta)
2349                                  douta_pipe[0] &lt;= rsta_val;
2350                                else begin
2351                                  if (regcea_i)
2352                                    douta_pipe[0] &lt;= douta_reg;
2353                                end
2354                              end
2355                            end
2356                            else begin
2357                              always @(posedge clka) begin
2358       1/1                      if (rsta)
2359       <font color = "red">0/1     ==>                douta_pipe[0] &lt;= rsta_val;</font>
2360                                else begin
2361       1/1                        if (regcea_i)
2362       1/1                          douta_pipe[0] &lt;= douta_reg;
                   <font color = "red">==>  MISSING_ELSE</font>
2363                                end
2364                              end
2365                            end
2366                          end : gen_stage
2367                    
2368                          // If more than two stages are used, loops generate all pipeline stages except the first and last
2369                          else if (READ_LATENCY_A &gt; 2) begin : gen_stages
2370                            always @(posedge clka) begin
2371                              if (ena_pipe[0])
2372                                douta_pipe[0] &lt;= douta_reg;
2373                            end
2374                    
2375                            for (genvar estage=1; estage&lt;READ_LATENCY_A-1; estage=estage+1) begin : gen_epipe
2376                              always @(posedge clka) begin
2377                                ena_pipe[estage] &lt;= ena_pipe[estage-1];
2378                              end
2379                            end : gen_epipe
2380                    
2381                            for (genvar dstage=1; dstage&lt;READ_LATENCY_A-2; dstage=dstage+1) begin : gen_dpipe
2382                              always @(posedge clka) begin
2383                                if (ena_pipe[dstage])
2384                                  douta_pipe[dstage] &lt;= douta_pipe[dstage-1];
2385                              end
2386                            end : gen_dpipe
2387                    
2388                            if(`ASYNC_RESET_A) begin
2389                              always @(posedge rsta or posedge clka) begin
2390                                if (rsta)
2391                                  douta_pipe[READ_LATENCY_A-2] &lt;= rsta_val;
2392                                else begin
2393                                  if (regcea_i)
2394                                    douta_pipe[READ_LATENCY_A-2] &lt;= douta_pipe[READ_LATENCY_A-3];
2395                                end
2396                              end
2397                            end
2398                            else begin
2399                              always @(posedge clka) begin
2400                                if (rsta)
2401                                  douta_pipe[READ_LATENCY_A-2] &lt;= rsta_val;
2402                                else begin
2403                                  if (regcea_i)
2404                                    douta_pipe[READ_LATENCY_A-2] &lt;= douta_pipe[READ_LATENCY_A-3];
2405                                end
2406                              end
2407                            end
2408                          end : gen_stages
2409                    
2410                          // The final pipeline stage drives the data output port
2411                          assign douta = douta_pipe[READ_LATENCY_A-2];
2412                        end : gen_douta_pipe
2413                        if(ECC_MODE == 2 || ECC_MODE == 3) begin : pipeline_ecc_status
2414                          // Error status signals (should be pipelined along with the data)
2415                          if (`MEM_PORTA_READ &amp;&amp; (`MEM_PRIM_ULTRA || `MEM_PRIM_AUTO)) begin : status_out_proc_a
2416                            // ECC status signal declarations
2417                            (* keep = &quot;yes&quot;, xpm_ecc_sbiterr = &quot;yes&quot;*)  wire sbiterra_ram;
2418                            (* keep = &quot;yes&quot;, xpm_ecc_dbiterr = &quot;yes&quot;*)  wire dbiterra_ram;
2419                            reg sbiterra_in_pipe;
2420                            reg dbiterra_in_pipe;
2421                            
2422                            // WRITE_FIRST Mode
2423                            if (`MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_REG) begin : ecc_status_wf_reg
2424                              always @(posedge clka) begin
2425                                if(rsta) begin
2426                                  sbiterra_in_pipe &lt;= 1'b0;
2427                                  dbiterra_in_pipe &lt;= 1'b0;
2428                                end
2429                                else if (ena_i) begin
2430                                    sbiterra_in_pipe &lt;= sbiterra_ram;
2431                                    dbiterra_in_pipe &lt;= dbiterra_ram;
2432                                end
2433                              end
2434                            end : ecc_status_wf_reg
2435                    
2436                            if (`MEM_PORTA_WF &amp;&amp; `MEM_PORTA_RD_PIPE) begin : ecc_status_wf_pipe
2437                              always @(posedge clka) begin
2438                                if (ena_i) begin
2439                                    sbiterra_in_pipe &lt;= sbiterra_ram;
2440                                    dbiterra_in_pipe &lt;= dbiterra_ram;
2441                                end
2442                              end
2443                            end : ecc_status_wf_pipe
2444                    
2445                            // READ_FIRST Mode
2446                            if (`MEM_PORTA_RF &amp;&amp; `MEM_PORTA_RD_REG) begin : ecc_status_rf_reg
2447                              always @(posedge clka) begin
2448                                if(rsta) begin
2449                                  sbiterra_in_pipe &lt;= 1'b0;
2450                                  dbiterra_in_pipe &lt;= 1'b0;
2451                                end
2452                                else if (ena_i) begin
2453                                  sbiterra_in_pipe &lt;= sbiterra_ram;
2454                                  dbiterra_in_pipe &lt;= dbiterra_ram;
2455                                end
2456                              end
2457                            end : ecc_status_rf_reg
2458                    
2459                            if (`MEM_PORTA_RF &amp;&amp; `MEM_PORTA_RD_PIPE) begin : ecc_status_rf_pipe
2460                              always @(posedge clka) begin
2461                                if (ena_i) begin
2462                                  sbiterra_in_pipe &lt;= sbiterra_ram;
2463                                  dbiterra_in_pipe &lt;= dbiterra_ram;
2464                                end
2465                              end
2466                            end : ecc_status_rf_pipe
2467                    
2468                            // NO_CHANGE Mode
2469                            if (`MEM_PORTA_NC &amp;&amp; `MEM_PORTA_RD_REG) begin : ecc_status_nc_reg
2470                              always @(posedge clka) begin
2471                                if(rsta) begin
2472                                  sbiterra_in_pipe &lt;= 1'b0;
2473                                  dbiterra_in_pipe &lt;= 1'b0;
2474                                end
2475                                else if (ena_i) begin
2476                                  if(~(|wea_i)) begin
2477                                    sbiterra_in_pipe &lt;= sbiterra_ram;
2478                                    dbiterra_in_pipe &lt;= dbiterra_ram;
2479                                  end
2480                                end
2481                              end
2482                            end : ecc_status_nc_reg
2483                    
2484                            if (`MEM_PORTA_NC &amp;&amp; `MEM_PORTA_RD_PIPE) begin : ecc_status_nc_pipe
2485                              always @(posedge clka) begin
2486                                if (ena_i) begin
2487                                  if(~(|wea_i)) begin
2488                                    sbiterra_in_pipe &lt;= sbiterra_ram;
2489                                    dbiterra_in_pipe &lt;= dbiterra_ram;
2490                                  end
2491                                end
2492                              end
2493                            end : ecc_status_nc_pipe
2494                     
2495                            if (READ_LATENCY_A &gt;= 2) begin : ecc_status_a_pipe
2496                              reg sbiterra_pipe   [READ_LATENCY_A-2:0];    
2497                              reg dbiterra_pipe   [READ_LATENCY_A-2:0];    
2498                              if (READ_LATENCY_A == 2) begin : RL_2_dly_err_status
2499                                always @(posedge clka) begin
2500                                  if(rsta) begin
2501                                    sbiterra_i &lt;= 1'b0;
2502                                    dbiterra_i &lt;= 1'b0;
2503                                  end
2504                                  else if (regcea_i) begin
2505                                    sbiterra_i &lt;= sbiterra_in_pipe;
2506                                    dbiterra_i &lt;= dbiterra_in_pipe;
2507                                  end
2508                                end
2509                              end : RL_2_dly_err_status
2510                    
2511                              if (READ_LATENCY_A &gt; 2) begin : RL_gr_2_dly_err_status
2512                                reg ena_ecc_pipe   [READ_LATENCY_A-2:0];
2513                                always @(posedge clka) begin
2514                                  ena_ecc_pipe[0] &lt;= ena_o_pipe_ctrl;
2515                                end
2516                            
2517                                for (genvar ecc_estage_a=1; ecc_estage_a&lt;READ_LATENCY_A-1; ecc_estage_a=ecc_estage_a+1) begin : gen_epipe
2518                                  always @(posedge clka) begin
2519                                    ena_ecc_pipe[ecc_estage_a] &lt;= ena_ecc_pipe[ecc_estage_a-1];
2520                                  end
2521                                end : gen_epipe
2522                    
2523                                always @(posedge clka) begin
2524                                  if(ena_ecc_pipe[0]) begin
2525                                    sbiterra_pipe[0] &lt;= sbiterra_in_pipe;
2526                                    dbiterra_pipe[0] &lt;= dbiterra_in_pipe;
2527                                  end
2528                                end
2529                                for (genvar ecc_errstage_a=1; ecc_errstage_a&lt;READ_LATENCY_A-2; ecc_errstage_a=ecc_errstage_a+1) begin : porta_gen_ecc_epipe
2530                                  always @(posedge clka) begin
2531                                    if (ena_ecc_pipe[ecc_errstage_a]) begin
2532                                      sbiterra_pipe[ecc_errstage_a]   &lt;= sbiterra_pipe[ecc_errstage_a-1];
2533                                      dbiterra_pipe[ecc_errstage_a]   &lt;= dbiterra_pipe[ecc_errstage_a-1];
2534                                    end
2535                                  end
2536                                end : porta_gen_ecc_epipe
2537                                always @(posedge clka) begin
2538                                  if(rsta) begin
2539                                    sbiterra_i &lt;= 1'b0;
2540                                    dbiterra_i &lt;= 1'b0;
2541                                  end
2542                                  else if (regcea_i) begin
2543                                    sbiterra_i &lt;= sbiterra_pipe[READ_LATENCY_A-3];
2544                                    dbiterra_i &lt;= dbiterra_pipe[READ_LATENCY_A-3];
2545                                  end
2546                                end
2547                              end : RL_gr_2_dly_err_status
2548                            end : ecc_status_a_pipe
2549                            else begin :ecc_status_a_reg
2550                              always @(*) begin
2551                                sbiterra_i = sbiterra_in_pipe;
2552                                dbiterra_i = dbiterra_in_pipe;
2553                              end
2554                            end : ecc_status_a_reg
2555                          end : status_out_proc_a
2556                        end : pipeline_ecc_status
2557                        else begin : no_ecc_err_status
2558                    //      always_comb begin
2559                    //        sbiterra_i = 0;
2560                    //        dbiterra_i = 0;
2561                    //      end
2562                        end : no_ecc_err_status
2563                        // Assign Output signals
2564                        assign sbiterra = sbiterra_i;
2565                        assign dbiterra = dbiterra_i;
2566                      end : gen_rd_a
2567                    
2568                      // If a port A read process is not generated, drive the data output port to a constant zero
2569                      else begin : gen_no_rd_a
2570                        assign douta = {READ_DATA_WIDTH_A{1'b0}};
2571                        assign sbiterra = 1'b0;
2572                        assign dbiterra = 1'b0;
2573                      end : gen_no_rd_a
2574                    
2575                      // -------------------------------------------------------------------------------------------------------------------
2576                      // Port B read
2577                      // -------------------------------------------------------------------------------------------------------------------
2578                    
2579                      // If the memory type is simple dual port RAM, true dual port RAM, or dual port ROM, generate a port B read process
2580                      if (`MEM_PORTB_READ) begin : gen_rd_b
2581                        wire clkb_int;
2582                    
2583                        // In true dual port UltraRAM configurations, use the port A clock delayed by a small amount to model the port B
2584                        // synchronous processes; although both ports share a common clock, port B operations occur after port A operations
2585                        if (`COMMON_CLOCK &amp;&amp; `MEM_PRIM_ULTRA &amp;&amp; `MEM_TYPE_RAM_TDP) begin : gen_uram_tdp_common_clock
2586                          assign clkb_int = clka;
2587                        end : gen_uram_tdp_common_clock
2588                    
2589                        // In all other common clocking configurations, use the port A clock for port B synchronous processes
2590                        else if (`COMMON_CLOCK) begin : gen_common_clock
2591                          assign clkb_int = clka;
2592                        end : gen_common_clock
2593                    
2594                        // In independent clocking configurations, use the port B clock for port B synchronous processes
2595                        else if (`INDEPENDENT_CLOCKS) begin : gen_independent_clocks
2596                          assign clkb_int = clkb;
2597                        end : gen_independent_clocks
2598                    
2599                        localparam READ_DATA_WIDTH_B_ECC = `NO_ECC ? READ_DATA_WIDTH_B : P_MIN_WIDTH_DATA_ECC;
2600                        wire [P_WIDTH_ADDR_READ_B-1:0] addrb_int = addrb_i;
2601                        localparam EMB_XDC = USE_EMBEDDED_CONSTRAINT ? &quot;yes&quot; : &quot;no&quot;;
2602                        (* dram_emb_xdc = EMB_XDC *) reg [READ_DATA_WIDTH_B_ECC-1:0] doutb_reg;
2603                        localparam logic [READ_DATA_WIDTH_B_ECC-1:0] rstb_val = `ASYNC_RESET_B ? {READ_DATA_WIDTH_B_ECC{1'b0}} : rst_val_conv_b(READ_RESET_VALUE_B);
2604                        // ECC error status signals
2605                        reg sbiterrb_i = 1'b0 ;
2606                        reg dbiterrb_i = 1'b0 ;
2607                    
2608                        // Initialize doutb_reg to the specified reset value if it is the only output register, or to zero if an output
2609                        // pipeline is used
2610                        initial begin
2611       1/1                if (`MEM_PORTB_RD_REG) begin : init_rstval
2612       <font color = "red">0/1     ==>          doutb_reg = rstb_val;</font>
2613                          end : init_rstval
2614       1/1                else if (`MEM_PORTB_RD_PIPE &amp;&amp; `MEM_PORTB_NC) begin : init_rstval_NC
2615       1/1                  doutb_reg = rstb_val;
2616                          end : init_rstval_NC
2617       <font color = "red">0/1     ==>        else if (`MEM_PORTB_RD_PIPE &amp;&amp; (`MEM_PORTB_WF || `MEM_PORTB_RF)) begin : init_zero</font>
2618       <font color = "red">0/1     ==>          doutb_reg = {READ_DATA_WIDTH_B_ECC{1'b0}};</font>
2619                          end : init_zero
                   <font color = "red">==>  MISSING_ELSE</font>
2620                        end
2621                        if (!`DISABLE_SYNTH_TEMPL) begin : gen_rd_b_synth_template
2622                        // Asynchronous port B read; port width is the narrowest of the data ports; no output pipeline
2623                        if (`MEM_PORTB_RD_NARROW &amp;&amp; `MEM_PORTB_RD_COMB) begin : gen_narrow_comb
2624                          always @(*) begin
2625                            doutb_reg = mem[addrb_int];
2626                          end
2627                        end : gen_narrow_comb
2628                    
2629                        // Asynchronous port B read; port width is wider than at least one other data port; no output pipeline
2630                        else if (`MEM_PORTB_RD_WIDE &amp;&amp; `MEM_PORTB_RD_COMB) begin : gen_wide_comb
2631                          always @(*) begin : rd_comb
2632                            integer row;
2633                            reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
2634                            for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
2635                              addrblsb = row;
2636                              doutb_reg[`ONE_ROW_OF_DIN] = mem[{addrb_int, addrblsb}];
2637                            end : for_mem_rows
2638                          end : rd_comb
2639                        end : gen_wide_comb
2640                    
2641                        // Synchronous port B write-first read; port width is the narrowest of the data ports; no output pipeline
2642                        else if (`MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_NARROW &amp;&amp; `MEM_PORTB_RD_REG &amp;&amp; `MEM_PORTB_WR_WORD) begin : gen_wf_narrow_reg
2643                          if(`ASYNC_RESET_B) begin
2644                            always @(posedge rstb or posedge clkb_int) begin
2645                              if (rstb)
2646                                doutb_reg &lt;= rstb_val;
2647                              else begin
2648                                if (enb_i) begin
2649                                  if (web_i)
2650                                    doutb_reg &lt;= dinb_i;
2651                                  else
2652                                    doutb_reg &lt;= mem[addrb_int];
2653                                end
2654                              end
2655                            end
2656                          end
2657                          else begin
2658                            always @(posedge clkb_int) begin
2659                              if (rstb)
2660                                doutb_reg &lt;= rstb_val;
2661                              else begin
2662                                if (enb_i) begin
2663                                  if (web_i)
2664                                    doutb_reg &lt;= dinb_i;
2665                                  else
2666                                    doutb_reg &lt;= mem[addrb_int];
2667                                end
2668                              end
2669                            end
2670                          end
2671                        end : gen_wf_narrow_reg
2672                    
2673                        // Synchronous port B write-first read; port width is the narrowest of the data ports; no output pipeline;
2674                        // symmetric byte-wide write special case
2675                        else if (`MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_NARROW &amp;&amp; `MEM_PORTB_RD_REG &amp;&amp;
2676                                 `MEM_PORTB_WR_NARROW &amp;&amp; `MEM_PORTB_WR_BYTE) begin : gen_wf_narrow_reg_sym_byte
2677                          for (genvar col=0; col&lt;P_NUM_COLS_WRITE_B; col=col+1) begin : for_mem_cols
2678                            if(`ASYNC_RESET_B) begin
2679                            always @(posedge rstb or posedge clkb_int) begin : wr_sync
2680                              if (rstb)
2681                                doutb_reg[`ONE_COL_OF_DINB] &lt;= rstb_val[`ONE_COL_OF_DINB];
2682                              else begin
2683                                if (enb_i) begin
2684                                  if (web_i[col])
2685                                    doutb_reg[`ONE_COL_OF_DINB] &lt;= dinb_i[`ONE_COL_OF_DINB];
2686                                  else
2687                                    doutb_reg[`ONE_COL_OF_DINB] &lt;= mem[addrb_int][`ONE_COL_OF_DINB];
2688                                end
2689                              end
2690                            end : wr_sync
2691                          end
2692                          else begin
2693                            always @(posedge clkb_int) begin : wr_sync
2694                              if (rstb)
2695                                doutb_reg[`ONE_COL_OF_DINB] &lt;= rstb_val[`ONE_COL_OF_DINB];
2696                              else begin
2697                                if (enb_i) begin
2698                                  if (web_i[col])
2699                                    doutb_reg[`ONE_COL_OF_DINB] &lt;= dinb_i[`ONE_COL_OF_DINB];
2700                                  else
2701                                    doutb_reg[`ONE_COL_OF_DINB] &lt;= mem[addrb_int][`ONE_COL_OF_DINB];
2702                                end
2703                              end
2704                            end : wr_sync
2705                          end
2706                        end : for_mem_cols
2707                        end : gen_wf_narrow_reg_sym_byte
2708                    
2709                        // Synchronous port B write-first read; port width is the narrowest of the data ports; output pipeline;
2710                        // UltraRAM simple dual port RAM special case
2711                        else if (`MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_NARROW &amp;&amp; `MEM_PORTB_RD_PIPE &amp;&amp;
2712                                 `MEM_PRIM_ULTRA &amp;&amp; `MEM_TYPE_RAM_SDP) begin : gen_wf_narrow_pipe_ultra_sdp
2713                          reg [P_WIDTH_ADDR_WRITE_B-1:0] addrb_reg = {P_WIDTH_ADDR_WRITE_B{1'b0}};
2714                          always @(posedge clkb_int) begin
2715                            addrb_reg &lt;= addrb_int;
2716                          end
2717                          always @(*) begin
2718                            doutb_reg = mem[addrb_reg];
2719                          end
2720                        end : gen_wf_narrow_pipe_ultra_sdp
2721                    
2722                        // Synchronous port B write-first read; port width is the wider of the data ports; output pipeline;
2723                        // UltraRAM simple dual port RAM special case
2724                        else if (`MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_WIDE &amp;&amp; `MEM_PORTB_RD_PIPE &amp;&amp;
2725                                 `MEM_PRIM_ULTRA &amp;&amp; `MEM_TYPE_RAM_SDP) begin : gen_wf_wide_pipe_ultra_sdp
2726                          reg [P_WIDTH_ADDR_WRITE_B-1:0] addrb_reg = {P_WIDTH_ADDR_WRITE_B{1'b0}};
2727                          always @(posedge clkb_int) begin
2728                            addrb_reg &lt;= addrb_int;
2729                          end
2730                          always @(*) begin : rd_comb
2731                            integer row;
2732                            reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
2733                            for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
2734                              addrblsb = row;
2735                              doutb_reg[`ONE_ROW_OF_DIN] = mem[{addrb_reg, addrblsb}];
2736                            end : for_mem_rows
2737                          end : rd_comb
2738                        end : gen_wf_wide_pipe_ultra_sdp
2739                    
2740                    
2741                        // Synchronous port B write-first read; port width is the narrowest of the data ports; output pipeline
2742                        else if (`MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_NARROW &amp;&amp; `MEM_PORTB_RD_PIPE &amp;&amp; `MEM_PORTB_WR_WORD) begin : gen_wf_narrow_pipe
2743                          always @(posedge clkb_int) begin
2744                            if (enb_i) begin
2745                              if (web_i)
2746                                doutb_reg &lt;= dinb_i;
2747                              else
2748                                doutb_reg &lt;= mem[addrb_int];
2749                            end
2750                          end
2751                        end : gen_wf_narrow_pipe
2752                    
2753                        // Synchronous port B write-first read; port width is the narrowest of the data ports; output pipeline;
2754                        // symmetric byte-wide write special case
2755                        else if (`MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_NARROW &amp;&amp; `MEM_PORTB_RD_PIPE &amp;&amp;
2756                                 `MEM_PORTB_WR_NARROW &amp;&amp; `MEM_PORTB_WR_BYTE) begin : gen_wf_narrow_pipe_sym_byte
2757                          for (genvar col=0; col&lt;P_NUM_COLS_WRITE_B; col=col+1) begin : for_mem_cols
2758                            always @(posedge clkb_int) begin : wr_sync
2759                              if (enb_i) begin
2760                                if (web_i[col])
2761                                  doutb_reg[`ONE_COL_OF_DINB] &lt;= dinb_i[`ONE_COL_OF_DINB];
2762                                else
2763                                  doutb_reg[`ONE_COL_OF_DINB] &lt;= mem[addrb_int][`ONE_COL_OF_DINB];
2764                              end
2765                            end : wr_sync
2766                          end : for_mem_cols
2767                        end : gen_wf_narrow_pipe_sym_byte
2768                    
2769                        // Synchronous port B write-first read; port width is wider than at least one other data port; no output pipeline;
2770                        // write and read combined special case
2771                        else if (`MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_WIDE &amp;&amp; `MEM_PORTB_RD_REG) begin : gen_wf_wide_reg
2772                          if(`ASYNC_RESET_B) begin
2773                            always @(posedge rstb or posedge clkb_int) begin : wr_rd_sync
2774                              integer row;
2775                              reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
2776                              for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
2777                                addrblsb = row;
2778                                if (rstb)
2779                                  doutb_reg[`ONE_ROW_OF_DIN] &lt;= rstb_val[`ONE_ROW_OF_DIN];
2780                                else begin
2781                                  if (enb_i) begin
2782                                    if (web_i)
2783                                      doutb_reg[`ONE_ROW_OF_DIN] &lt;= dinb_i[`ONE_ROW_OF_DIN];
2784                                    else
2785                                      doutb_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addrb_int, addrblsb}];
2786                                  end
2787                                end
2788                              end : for_mem_rows
2789                            end : wr_rd_sync
2790                          end
2791                          else begin
2792                            always @(posedge clkb_int) begin : wr_rd_sync
2793                              integer row;
2794                              reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
2795                              for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
2796                                addrblsb = row;
2797                                if (rstb)
2798                                  doutb_reg[`ONE_ROW_OF_DIN] &lt;= rstb_val[`ONE_ROW_OF_DIN];
2799                                else begin
2800                                  if (enb_i) begin
2801                                    if (web_i)
2802                                      doutb_reg[`ONE_ROW_OF_DIN] &lt;= dinb_i[`ONE_ROW_OF_DIN];
2803                                    else
2804                                      doutb_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addrb_int, addrblsb}];
2805                                  end
2806                                end
2807                              end : for_mem_rows
2808                            end : wr_rd_sync
2809                          end 
2810                        end : gen_wf_wide_reg
2811                    
2812                        // Synchronous port B write-first read; port width is wider than at least one other data port; output pipeline;
2813                        // write and read combined special case
2814                        else if (`MEM_PORTB_WF &amp;&amp; `MEM_PORTB_RD_WIDE &amp;&amp; `MEM_PORTB_RD_PIPE) begin : gen_wf_wide_pipe
2815                          always @(posedge clkb_int) begin : wr_rd_sync
2816                            integer row;
2817                            reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
2818                            for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
2819                              addrblsb = row;
2820                              if (enb_i) begin
2821                                if (web_i)
2822                                  mem[{addrb_int, addrblsb}] = dinb_i[`ONE_ROW_OF_DIN];
2823                                doutb_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addrb_int, addrblsb}];
2824                              end
2825                            end : for_mem_rows
2826                          end : wr_rd_sync
2827                        end : gen_wf_wide_pipe
2828                    
2829                        // Synchronous port B read-first read; port width is the narrowest of the data ports; no output pipeline
2830                        else if (`MEM_PORTB_RF &amp;&amp; `MEM_PORTB_RD_NARROW &amp;&amp; `MEM_PORTB_RD_REG) begin : gen_rf_narrow_reg
2831                          if(`ASYNC_RESET_B) begin
2832                            always @(posedge rstb or posedge clkb_int) begin
2833                              if (rstb)
2834                                doutb_reg &lt;= rstb_val;
2835                              else begin
2836                                if (enb_i)
2837                                  doutb_reg &lt;= mem[addrb_int];
2838                              end
2839                            end
2840                          end
2841                          else begin
2842                            always @(posedge clkb_int) begin
2843                              if (rstb)
2844                                doutb_reg &lt;= rstb_val;
2845                              else begin
2846                                if (enb_i)
2847                                  doutb_reg &lt;= mem[addrb_int];
2848                              end
2849                            end
2850                          end
2851                        end : gen_rf_narrow_reg
2852                    
2853                        // Synchronous port B read-first read; port width is the narrowest of the data ports; output pipeline
2854                        else if (`MEM_PORTB_RF &amp;&amp; `MEM_PORTB_RD_NARROW &amp;&amp; `MEM_PORTB_RD_PIPE) begin : gen_rf_narrow_pipe
2855                          always @(posedge clkb_int) begin
2856                            if (enb_i)
2857                              doutb_reg &lt;= mem[addrb_int];
2858                          end
2859                        end : gen_rf_narrow_pipe
2860                    
2861                        // Synchronous port B read-first read; port width is wider than at least one other data port; no output pipeline
2862                        else if (`MEM_PORTB_RF &amp;&amp; `MEM_PORTB_RD_WIDE &amp;&amp; `MEM_PORTB_RD_REG) begin : gen_rf_wide_reg
2863                          if(`ASYNC_RESET_B) begin
2864                            always @(posedge rstb or posedge clkb_int) begin : rd_sync
2865                              integer row;
2866                              reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
2867                              for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
2868                                addrblsb = row;
2869                                if (rstb)
2870                                  doutb_reg[`ONE_ROW_OF_DIN] &lt;= rstb_val[`ONE_ROW_OF_DIN];
2871                                else begin
2872                                  if (enb_i)
2873                                    doutb_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addrb_int, addrblsb}];
2874                                end
2875                              end : for_mem_rows
2876                            end : rd_sync
2877                          end
2878                          else begin
2879                            always @(posedge clkb_int) begin : rd_sync
2880                              integer row;
2881                              reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
2882                              for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
2883                                addrblsb = row;
2884                                if (rstb)
2885                                  doutb_reg[`ONE_ROW_OF_DIN] &lt;= rstb_val[`ONE_ROW_OF_DIN];
2886                                else begin
2887                                  if (enb_i)
2888                                    doutb_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addrb_int, addrblsb}];
2889                                end
2890                              end : for_mem_rows
2891                            end : rd_sync
2892                          end
2893                        end : gen_rf_wide_reg
2894                    
2895                        // Synchronous port B read-first read; port width is wider than at least one other data port; output pipeline
2896                        else if (`MEM_PORTB_RF &amp;&amp; `MEM_PORTB_RD_WIDE &amp;&amp; `MEM_PORTB_RD_PIPE) begin : gen_rf_wide_pipe
2897                          always @(posedge clkb_int) begin : rd_sync
2898                            integer row;
2899                            reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
2900                            for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
2901                              addrblsb = row;
2902                              if (enb_i)
2903                                doutb_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addrb_int, addrblsb}];
2904                            end : for_mem_rows
2905                          end : rd_sync
2906                        end : gen_rf_wide_pipe
2907                    
2908                        // Synchronous port B no-change read; port width is the narrowest of the data ports; no output pipeline
2909                        else if (`MEM_PORTB_NC &amp;&amp; `MEM_PORTB_RD_NARROW &amp;&amp; `MEM_PORTB_RD_REG) begin : gen_nc_narrow_reg
2910                          if(`ASYNC_RESET_B) begin
2911                            always @(posedge rstb or posedge clkb_int) begin
2912                              if (rstb)
2913                                doutb_reg &lt;= rstb_val;
2914                              else begin
2915                                if (enb_i) begin
2916                                  if (~|web_i)
2917                                    doutb_reg &lt;= mem[addrb_int];
2918                                end
2919                              end
2920                            end
2921                          end
2922                          else begin
2923                            always @(posedge clkb_int) begin
2924                              if (rstb)
2925                                doutb_reg &lt;= rstb_val;
2926                              else begin
2927                                if (enb_i) begin
2928                                  if (~|web_i)
2929                                    doutb_reg &lt;= mem[addrb_int];
2930                                end
2931                              end
2932                            end
2933                          end
2934                        end : gen_nc_narrow_reg
2935                    
2936                        // Synchronous port B no-change read; port width is the narrowest of the data ports; output pipeline
2937                        else if (`MEM_PORTB_NC &amp;&amp; `MEM_PORTB_RD_NARROW &amp;&amp; `MEM_PORTB_RD_PIPE) begin : gen_nc_narrow_pipe
2938                          always @(posedge clkb_int) begin
2939       1/1                  if (enb_i) begin
2940       1/1                    if (~|web_i)
2941       1/1                      doutb_reg &lt;= mem[addrb_int];
                   <font color = "red">==>  MISSING_ELSE</font>
2942                            end
                        MISSING_ELSE
2943                          end
2944                        end : gen_nc_narrow_pipe
2945                    
2946                        // Synchronous port B no-change read; port width is wider than at least one other data port; no output pipeline
2947                        else if (`MEM_PORTB_NC &amp;&amp; `MEM_PORTB_RD_WIDE &amp;&amp; `MEM_PORTB_RD_REG) begin : gen_nc_wide_reg
2948                          if(`ASYNC_RESET_B) begin
2949                            always @(posedge rstb or posedge clkb_int) begin : rd_sync
2950                              integer row;
2951                              reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
2952                              for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
2953                                addrblsb = row;
2954                                if (rstb)
2955                                  doutb_reg[`ONE_ROW_OF_DIN] &lt;= rstb_val[`ONE_ROW_OF_DIN];
2956                                else begin
2957                                  if (enb_i) begin
2958                                    if (~|web_i)
2959                                      doutb_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addrb_int, addrblsb}];
2960                                  end
2961                                end
2962                              end : for_mem_rows
2963                            end : rd_sync
2964                          end
2965                          else begin
2966                            always @(posedge clkb_int) begin : rd_sync
2967                              integer row;
2968                              reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
2969                              for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
2970                                addrblsb = row;
2971                                if (rstb)
2972                                  doutb_reg[`ONE_ROW_OF_DIN] &lt;= rstb_val[`ONE_ROW_OF_DIN];
2973                                else begin
2974                                  if (enb_i) begin
2975                                    if (~|web_i)
2976                                      doutb_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addrb_int, addrblsb}];
2977                                  end
2978                                end
2979                              end : for_mem_rows
2980                            end : rd_sync
2981                          end
2982                        end : gen_nc_wide_reg
2983                    
2984                        // Synchronous port B no-change read; port width is wider than at least one other data port; output pipeline
2985                        else if (`MEM_PORTB_NC &amp;&amp; `MEM_PORTB_RD_WIDE &amp;&amp; `MEM_PORTB_RD_PIPE) begin : gen_nc_wide_pipe
2986                          always @(posedge clkb_int) begin : rd_sync
2987                            integer row;
2988                            reg [P_WIDTH_ADDR_LSB_READ_B-1:0] addrblsb;
2989                            for (row=0; row&lt;P_NUM_ROWS_READ_B; row=row+1) begin : for_mem_rows
2990                              addrblsb = row;
2991                              if (enb_i) begin
2992                                if (~|web_i)
2993                                  doutb_reg[`ONE_ROW_OF_DIN] &lt;= mem[{addrb_int, addrblsb}];
2994                              end
2995                            end : for_mem_rows
2996                          end : rd_sync
2997                        end : gen_nc_wide_pipe
2998                        end : gen_rd_b_synth_template
2999                        else begin : gen_rd_b_synth_black_box
3000                          always @(*) begin
3001                            doutb_reg = doutb_bb;
3002                          end
3003                        end : gen_rd_b_synth_black_box
3004                        // If no output pipeline is used, then the enabled read process directly drives the data output port
3005                        if (`MEM_PORTB_RD_COMB || `MEM_PORTB_RD_REG) begin : gen_doutb
3006                          assign doutb = doutb_reg;
3007                        end : gen_doutb
3008                    
3009                        // If an output pipeline is used, generate it
3010                        else if (`MEM_PORTB_RD_PIPE) begin : gen_doutb_pipe
3011                          reg                         enb_pipe   [READ_LATENCY_B-2:0];
3012                          reg [READ_DATA_WIDTH_B_ECC-1:0] doutb_pipe [READ_LATENCY_B-2:0];
3013                    
3014                          always @(posedge clkb_int) begin
3015       1/1                  enb_pipe[0] &lt;= enb_o_pipe_ctrl;
3016                          end
3017                    
3018                          // Initialize the final output pipeline stage to the specified reset value, and all prior stages to zero
3019                          initial begin
3020                            integer initstage;
3021       1/1                  for (initstage=0; initstage&lt;READ_LATENCY_B-1; initstage=initstage+1) begin : for_pipe_init
3022       1/1                    if (initstage &lt; READ_LATENCY_B-2 &amp;&amp; (`MEM_PORTB_WF || `MEM_PORTB_RF)) begin : init_zero
3023       <font color = "red">0/1     ==>              doutb_pipe[initstage] = {READ_DATA_WIDTH_B_ECC{1'b0}};</font>
3024                              end : init_zero
3025       1/1                    else if (initstage &lt; READ_LATENCY_B-2 &amp;&amp; `MEM_PORTB_NC ) begin : init_rstval_NC
3026       <font color = "red">0/1     ==>              doutb_pipe[initstage] = rstb_val;</font>
3027                              end : init_rstval_NC
3028                              else begin : init_rstval
3029       1/1                      doutb_pipe[initstage] = rstb_val;
3030                              end : init_rstval
3031                            end : for_pipe_init
3032                          end
3033                    
3034                          // If two stages are used, the synchronous read output drives the final pipeline stage
3035                          if (READ_LATENCY_B == 2) begin : gen_stage
3036                            if(`ASYNC_RESET_B) begin
3037                              always @(posedge rstb or posedge clkb_int) begin
3038                                if (rstb)
3039                                  doutb_pipe[0] &lt;= rstb_val;
3040                                else begin
3041                                  if (regceb_i)
3042                                    doutb_pipe[0] &lt;= doutb_reg;
3043                                end
3044                              end
3045                            end
3046                            else begin
3047                              always @(posedge clkb_int) begin
3048       1/1                      if (rstb)
3049       <font color = "red">0/1     ==>                doutb_pipe[0] &lt;= rstb_val;</font>
3050                                else begin
3051       1/1                        if (regceb_i)
3052       1/1                          doutb_pipe[0] &lt;= doutb_reg;
                   <font color = "red">==>  MISSING_ELSE</font>
3053                                end
3054                              end
3055                            end
3056                          end : gen_stage
3057                    
3058                          // If more than two stages are used, loops generate all pipeline stages except the first and last
3059                          else if (READ_LATENCY_B &gt; 2) begin : gen_stages
3060                            always @(posedge clkb_int) begin
3061                              if (enb_pipe[0])
3062                                doutb_pipe[0] &lt;= doutb_reg;
3063                            end
3064                    
3065                            for (genvar estage=1; estage&lt;READ_LATENCY_B-1; estage=estage+1) begin : gen_epipe
3066                              always @(posedge clkb_int) begin
3067                                enb_pipe[estage] &lt;= enb_pipe[estage-1];
3068                              end
3069                            end : gen_epipe
3070                    
3071                            for (genvar dstage=1; dstage&lt;READ_LATENCY_B-2; dstage=dstage+1) begin : gen_dpipe
3072                              always @(posedge clkb_int) begin
3073                                if (enb_pipe[dstage])
3074                                  doutb_pipe[dstage] &lt;= doutb_pipe[dstage-1];
3075                              end
3076                            end : gen_dpipe
3077                    
3078                            if(`ASYNC_RESET_B) begin
3079                              always @(posedge rstb or posedge clkb_int) begin
3080                                if (rstb)
3081                                  doutb_pipe[READ_LATENCY_B-2] &lt;= rstb_val;
3082                                else begin
3083                                  if (regceb_i)
3084                                    doutb_pipe[READ_LATENCY_B-2] &lt;= doutb_pipe[READ_LATENCY_B-3];
3085                                end
3086                              end
3087                            end
3088                            else begin
3089                              always @(posedge clkb_int) begin
3090                                if (rstb)
3091                                  doutb_pipe[READ_LATENCY_B-2] &lt;= rstb_val;
3092                                else begin
3093                                  if (regceb_i)
3094                                    doutb_pipe[READ_LATENCY_B-2] &lt;= doutb_pipe[READ_LATENCY_B-3];
3095                                end
3096                              end
3097                            end
3098                          end : gen_stages
3099                    
3100                          // The final pipeline stage drives the data output port
3101                          assign doutb = doutb_pipe[READ_LATENCY_B-2];
3102                        end : gen_doutb_pipe
3103                    
3104                        if(ECC_MODE == 2 || ECC_MODE == 3) begin : pipeline_ecc_status
3105                          (* keep = &quot;yes&quot;, xpm_ecc_sbiterr = &quot;yes&quot;*)  wire sbiterrb_ram;
3106                          (* keep = &quot;yes&quot;, xpm_ecc_dbiterr = &quot;yes&quot;*)  wire dbiterrb_ram;
3107                          reg sbiterrb_in_pipe;
3108                          reg dbiterrb_in_pipe;
3109                    
3110                          // WRITE_FIRST Mode
3111                          // This mode is allowed only for Ultra RAM + SDP + RL &gt; 3
3112                          if (`MEM_PORTB_WF) begin : ecc_status_wf_reg
3113                            always @(*) begin
3114                              sbiterrb_in_pipe &lt;= sbiterrb_ram;
3115                              dbiterrb_in_pipe &lt;= dbiterrb_ram;
3116                            end
3117                          end : ecc_status_wf_reg
3118                    
3119                          // READ_FIRST Mode
3120                          if (`MEM_PORTB_RF &amp;&amp; `MEM_PORTB_RD_REG) begin : ecc_status_rf_reg
3121                            always @(posedge clkb_int) begin
3122                              if(rstb) begin
3123                                sbiterrb_in_pipe &lt;= 1'b0;
3124                                dbiterrb_in_pipe &lt;= 1'b0;
3125                              end
3126                              else if (enb_i) begin
3127                                sbiterrb_in_pipe &lt;= sbiterrb_ram;
3128                                dbiterrb_in_pipe &lt;= dbiterrb_ram;
3129                              end
3130                            end
3131                          end : ecc_status_rf_reg
3132                    
3133                          if (`MEM_PORTB_RF &amp;&amp; `MEM_PORTB_RD_PIPE) begin : ecc_status_rf_pipe
3134                            always @(posedge clkb_int) begin
3135                              if (enb_i) begin
3136                                sbiterrb_in_pipe &lt;= sbiterrb_ram;
3137                                dbiterrb_in_pipe &lt;= dbiterrb_ram;
3138                              end
3139                            end
3140                          end : ecc_status_rf_pipe
3141                    
3142                          // NO_CHANGE Mode
3143                          if (`MEM_PORTB_NC &amp;&amp; `MEM_PORTB_RD_REG) begin : ecc_status_nc_reg
3144                            always @(posedge clkb_int) begin
3145                              if(rstb) begin
3146                                sbiterrb_in_pipe &lt;= 1'b0;
3147                                dbiterrb_in_pipe &lt;= 1'b0;
3148                              end
3149                              else if (enb_i) begin
3150                                if(~(|web_i)) begin
3151                                  sbiterrb_in_pipe &lt;= sbiterrb_ram;
3152                                  dbiterrb_in_pipe &lt;= dbiterrb_ram;
3153                                end
3154                              end
3155                            end
3156                          end : ecc_status_nc_reg
3157                    
3158                          if (`MEM_PORTB_NC &amp;&amp; `MEM_PORTB_RD_PIPE) begin : ecc_status_nc_pipe
3159                            always @(posedge clkb_int) begin
3160                              if (enb_i) begin
3161                                if(~(|web_i)) begin
3162                                  sbiterrb_in_pipe &lt;= sbiterrb_ram;
3163                                  dbiterrb_in_pipe &lt;= dbiterrb_ram;
3164                                end
3165                              end
3166                            end
3167                          end : ecc_status_nc_pipe
3168                    
3169                          // Error status signals (should be pipelined along with the data)
3170                          if (READ_LATENCY_B &gt;= 2) begin : ecc_status_b_pipe
3171                            reg sbiterrb_pipe   [READ_LATENCY_B-2:0];    
3172                            reg dbiterrb_pipe   [READ_LATENCY_B-2:0];    
3173                     
3174                            if (READ_LATENCY_B == 2) begin : RL_2_dly_err_status
3175                              always @(posedge clkb_int) begin
3176                                if(rstb) begin
3177                                  sbiterrb_i &lt;= 1'b0;
3178                                  dbiterrb_i &lt;= 1'b0;
3179                                end
3180                                else if (regceb_i) begin
3181                                  sbiterrb_i &lt;= sbiterrb_in_pipe;
3182                                  dbiterrb_i &lt;= dbiterrb_in_pipe;
3183                                end
3184                              end
3185                            end : RL_2_dly_err_status
3186                    
3187                            if (READ_LATENCY_B &gt; 2) begin : RL_gr_2_dly_err_status
3188                            reg enb_ecc_pipe   [READ_LATENCY_B-2:0];
3189                              always @(posedge clkb_int) begin
3190                                enb_ecc_pipe[0] &lt;= enb_o_pipe_ctrl;
3191                              end
3192                    
3193                              for (genvar ecc_estage_b=1; ecc_estage_b&lt;READ_LATENCY_B-1; ecc_estage_b=ecc_estage_b+1) begin : gen_epipe
3194                                always @(posedge clkb_int) begin
3195                                  enb_ecc_pipe[ecc_estage_b] &lt;= enb_ecc_pipe[ecc_estage_b-1];
3196                                end
3197                              end : gen_epipe
3198                    
3199                              always @(posedge clkb_int) begin
3200                                if (enb_ecc_pipe[0]) begin
3201                                  sbiterrb_pipe[0] &lt;= sbiterrb_in_pipe;
3202                                  dbiterrb_pipe[0] &lt;= dbiterrb_in_pipe;
3203                                end
3204                              end
3205                              for (genvar ecc_errstage_b=1; ecc_errstage_b&lt;READ_LATENCY_B-2; ecc_errstage_b=ecc_errstage_b+1) begin : portb_gen_ecc_epipe
3206                                always @(posedge clkb_int) begin
3207                                  if (enb_ecc_pipe[ecc_errstage_b]) begin
3208                                    sbiterrb_pipe[ecc_errstage_b]   &lt;= sbiterrb_pipe[ecc_errstage_b-1];
3209                                    dbiterrb_pipe[ecc_errstage_b]   &lt;= dbiterrb_pipe[ecc_errstage_b-1];
3210                                  end
3211                                end
3212                              end : portb_gen_ecc_epipe
3213                              always @(posedge clkb_int) begin
3214                                if(rstb) begin
3215                                  sbiterrb_i &lt;= 1'b0;
3216                                  dbiterrb_i &lt;= 1'b0;
3217                                end
3218                                else if (regceb_i) begin
3219                                  sbiterrb_i &lt;= sbiterrb_pipe[READ_LATENCY_B-3];
3220                                  dbiterrb_i &lt;= dbiterrb_pipe[READ_LATENCY_B-3];
3221                                end
3222                              end
3223                              end : RL_gr_2_dly_err_status
3224                          end : ecc_status_b_pipe
3225                          else begin :ecc_status_b_reg
3226                            always @(*) begin
3227                              sbiterrb_i = sbiterrb_in_pipe;
3228                              dbiterrb_i = dbiterrb_in_pipe;
3229                            end
3230                          end : ecc_status_b_reg
3231                        end : pipeline_ecc_status
3232                        else begin : no_ecc_err_status
3233                    //      always_comb begin
3234                    //        sbiterrb_i = 0;
3235                    //        dbiterrb_i = 0;
3236                    //      end
3237                        end : no_ecc_err_status
3238                        // Assign to output signals
3239                         assign sbiterrb = sbiterrb_i;
3240                         assign dbiterrb = dbiterrb_i;
3241                      end : gen_rd_b
3242                    
3243                      // If a port B read process is not generated, drive the data output port to a constant zero
3244                      else begin : gen_no_rd_b
3245                        assign doutb = {READ_DATA_WIDTH_B{1'b0}};
3246                        assign sbiterrb = 1'b0;
3247                        assign dbiterrb = 1'b0;
3248                      end : gen_no_rd_b
3249                    
3250                      // -------------------------------------------------------------------------------------------------------------------
3251                      // Simulation constructs
3252                      // -------------------------------------------------------------------------------------------------------------------
3253                      // synthesis translate_off
3254                      // Param to enable or disable the cover points/assertion checks
3255                    
3256                      // Sleep related signals shall be used across the simulation model,
3257                      // so declaring them globally
3258                      reg sleep_int_a = 0; // sleep port registered on Port-A clock 
3259                      reg sleep_int_b = 0; // sleep port registered on Port-B clock
3260                      wire [ADDR_WIDTH_A-1:0] addra_aslp_sim; // Delayed address in auto sleep mode that is
3261                                                              // used to check out of range addressing
3262                      wire [ADDR_WIDTH_B-1:0] addrb_aslp_sim;
3263                    
3264                      // Internal wires to accomodate Auto sleep mode delays if enabled
3265                      wire injectsbiterra_sim;
3266                      wire injectdbiterra_sim;
3267                      wire injectsbiterrb_sim;
3268                      wire injectdbiterrb_sim;
3269                    
3270                      initial begin
3271       2/2            #1;
3272       1/1              if (`REPORT_MESSAGES &amp;&amp; (!`MEM_TYPE_RAM_TDP || !`MEM_TYPE_RAM_SDP || `MEM_PRIM_DISTRIBUTED || `MEM_PRIM_ULTRA))
3273       <font color = "red">0/1     ==>        $warning(&quot;MESSAGE_CONTROL (%0d) specifies simulation message reporting, but this release of XPM_MEMORY only reports messages for true dual port RAM and simple dual port RAM configurations which specify auto or block memory primitive types.&quot;, MESSAGE_CONTROL);</font>
                        MISSING_ELSE
3274       1/1              if (`REPORT_MESSAGES &amp;&amp; (`MEM_TYPE_RAM_TDP || `MEM_TYPE_RAM_SDP) &amp;&amp; !(`MEM_PRIM_DISTRIBUTED || `MEM_PRIM_ULTRA))
3275                        `ifdef OBSOLETE
3276                          $warning(&quot;Vivado Simulator does not currently support the SystemVerilog Assertion syntax used within XPM_MEMORY. Memory collisions will not be reported.&quot;);
3277                        `else
3278       <font color = "red">0/1     ==>        $info(&quot;MESSAGE_CONTROL (%0d) specifies simulation message reporting, this release of XPM_MEMORY reports messages for potential write-write and write-read collisions in this configuration.&quot;, MESSAGE_CONTROL);</font>
                        MISSING_ELSE
3279                        `endif
3280                      end
3281                    
3282                      // Simulation assertions warn of the effects when potential write-write, write-read collisions occur and illegal access to memory
3283                      `ifndef OBSOLETE
3284                    
3285                      // The below message is to catch the out-of range address access for a write
3286                      // operation.
3287                    
3288                      if (`REPORT_MESSAGES &amp;&amp; `MEM_PORTA_WRITE &amp;&amp; AUTO_SLEEP_TIME == 0 &amp;&amp; !(`DISABLE_SYNTH_TEMPL)) begin : illegal_wr_ena
3289                        assert property (@(posedge clka)
3290                          !(ena === 1 &amp;&amp; |wea &amp;&amp; (addra &gt; gen_wr_a.addra_int) ))
3291                        else
3292                          $warning(&quot;XPM_MEMORY_OUT_OF_RANGE_WRITE_ACCESS : Write Operation on Port-A to an out-of-range address at time %0t; Actual Address --&gt; %0h , effective address is %0h.There is a chance that data at the effective address location may get written in the synthesis netlist, and there by the simulation mismatch can occur between behavioral model and netlist simulations&quot;, $time,addra,gen_wr_a.addra_int);
3293                      end : illegal_wr_ena
3294                    
3295                      if (`REPORT_MESSAGES &amp;&amp; `MEM_PORTB_WRITE &amp;&amp; AUTO_SLEEP_TIME == 0 &amp;&amp; !(`DISABLE_SYNTH_TEMPL)) begin : illegal_wr_enb
3296                        assert property (@(posedge gen_wr_b.clkb_int)
3297                          !(enb === 1 &amp;&amp; |web &amp;&amp; (addrb &gt; gen_wr_b.addrb_int) ))
3298                        else
3299                          $warning(&quot;XPM_MEMORY_OUT_OF_RANGE_WRITE_ACCESS : Write Operation on Port-B to an out-of-range address at time %0t; Actual Address --&gt; %0h , effective address is %0h.There is a chance that data at the effective address location may get written in the synthesis netlist, and there by the simulation mismatch can occur between behavioral model and netlist simulations&quot;, $time,addrb,gen_wr_b.addrb_int);
3300                      end : illegal_wr_enb
3301                    
3302                      // In ECC Reset is not supported and these messages are not guarded under
3303                      // MESSAGE_CONTROL param, as these are critical.
3304                    
3305                      if (!(`NO_ECC) &amp;&amp; `MEM_PORTA_READ) begin : illegal_rsta_in_ecc
3306                        assert property (@(posedge clka)
3307                          !(rsta))
3308                        else
3309                          $warning(&quot;XPM_MEMORY_ILLEGAL_RESET_IN_ECC_MODE : Attempt to reset the data output through Port-A at time %0t when ECC is enabled ; reset operation is not supported when ECC is enabled.&quot;, $time);
3310                      end : illegal_rsta_in_ecc
3311                    
3312                      if (!(`NO_ECC) &amp;&amp; `MEM_PORTB_READ) begin : illegal_rstb_in_ecc
3313                        assert property (@(posedge gen_rd_b.clkb_int)
3314                          !(rstb))
3315                        else
3316                          $warning(&quot;XPM_MEMORY_ILLEGAL_RESET_IN_ECC_MODE : Attempt to reset the data output through Port-B at time %0t when ECC is enabled ; reset operation is not supported when ECC is enabled.&quot;, $time);
3317                      end : illegal_rstb_in_ecc
3318                    
3319                      if (`REPORT_MESSAGES) begin : gen_assert_illegal_mem_access_w
3320                        // Assertion to catch illegal write access to the memory through port-B when
3321                        // the memory type is set to simple Dual port RAM
3322                        if (`MEM_TYPE_RAM_SDP) begin : illegal_mem_access_w_sdp
3323                          assert property (@(posedge clkb)
3324                            !(enb &amp;&amp; |web))
3325                          else
3326                            $warning(&quot;XPM_MEMORY_ILLEGAL_WRITE_SDP : Attempt to write to memory through Port-B at address 0x%0h at time %0t when the memory type is set to simple dual port RAM ; data outputs and memory content may be corrupted.&quot;, addrb, $time);
3327                        end : illegal_mem_access_w_sdp
3328                        // Assertion to catch illegal write access to the memory through port-A when
3329                        // the memory type is set to single port ROM/Dual Port ROM
3330                        if (`MEM_TYPE_ROM) begin : illegal_mem_access_w_rom
3331                          assert property (@(posedge clka)
3332                            !(ena &amp;&amp; |wea))
3333                          else
3334                            $warning(&quot;XPM_MEMORY_ILLEGAL_WRITE_ROM: Attempt to write to memory through Port-A at address 0x%0h at time %0t for ROM configuration ; data outputs and memory content may be corrupted.&quot;, addra, $time);
3335                        end : illegal_mem_access_w_rom
3336                        // Assertion to catch illegal write access to the memory through port-B when
3337                        // the memory type is set to Dual Port ROM
3338                        if (`MEM_TYPE_ROM_DP) begin : illegal_mem_access_w_dprom
3339                          assert property (@(posedge clkb)
3340                            !(enb &amp;&amp; |web))
3341                          else
3342                            $warning(&quot;XPM_MEMORY_ILLEGAL_WRITE_ROM: Attempt to write to memory through Port-B at address 0x%0h at time %0t for ROM configuration ; data outputs and memory content may be corrupted.&quot;, addrb, $time);
3343                        end : illegal_mem_access_w_dprom
3344                    
3345                      // Assertion to catch illegal REGCE assertion after Reset
3346                    
3347                      if(`MEM_PORTA_READ &amp;&amp; `MEM_PORTA_RD_PIPE &amp;&amp; `REPORT_MESSAGES) begin : illegal_regcea_after_rsta
3348                        reg flag_rst_regce_a = 1'b0;
3349                        // flag generation to capture the reset to valid enable duration
3350                        always @(posedge clka)
3351                          begin
3352                           if (rsta)
3353                             flag_rst_regce_a &lt;= 1'b1;
3354                           else begin
3355                             if (gen_rd_a.gen_douta_pipe.ena_pipe[READ_LATENCY_A-2])
3356                               flag_rst_regce_a &lt;= 1'b0;
3357                           end
3358                          end
3359                          // Assertion
3360                          assert property (@(posedge clka)
3361                            !(~rsta &amp;&amp; regcea &amp;&amp; flag_rst_regce_a))
3362                          else
3363                            $warning(&quot;regcea asserted at address 0x%0h at time %0t after reset without a valid read happened to the memory ; reset value on the output port maynot be preserved.&quot;, addra, $time);
3364                      end : illegal_regcea_after_rsta
3365                      
3366                      if(`MEM_PORTB_READ &amp;&amp; `MEM_PORTB_RD_PIPE &amp;&amp; `REPORT_MESSAGES) begin : illegal_regcea_after_rstb
3367                        reg flag_rst_regce_b = 1'b0;
3368                        // flag generation to capture the reset to valid enable duration
3369                        always @(posedge clkb)
3370                          begin
3371                           if (rstb)
3372                             flag_rst_regce_b &lt;= 1'b1;
3373                           else begin
3374                             if (gen_rd_b.gen_doutb_pipe.enb_pipe[READ_LATENCY_B-2])
3375                               flag_rst_regce_b &lt;= 1'b0;
3376                           end
3377                          end
3378                          // Assertion
3379                          assert property (@(posedge clkb)
3380                            !(~rstb &amp;&amp; regceb &amp;&amp; flag_rst_regce_b))
3381                          else
3382                            $warning(&quot;regceb asserted at address 0x%0h at time %0t after reset without a valid read happened to the memory ; reset value on the output port maynot be preserved.&quot;, addrb, $time);
3383                      end : illegal_regcea_after_rstb
3384                    
3385                      // Decode only mode can not have error injection
3386                        if (`DEC_ONLY) begin : illegal_injerr_dec_only
3387                          assert property (@(posedge clka)
3388                            !(ena &amp;&amp; |wea &amp;&amp; injectsbiterra))
3389                          else
3390                            $warning(&quot;XPM_MEMORY_ILLEGAL_ERR_INJ_ASSRT: Attempt to inject single bit error into the memory through Port-A at address 0x%0h at time %0t in Decode only mode configuration ; Error injection is not allowed in Decode only mode.&quot;, addra, $time);
3391                          assert property (@(posedge clka)
3392                            !(ena &amp;&amp; |wea &amp;&amp; injectdbiterra))
3393                          else
3394                            $warning(&quot;XPM_MEMORY_ILLEGAL_ERR_INJ_ASSRT: Attempt to inject double bit error into the memory through Port-A at address 0x%0h at time %0t in Decode only mode configuration ; Error injection is not allowed in Decode only mode.&quot;, addra, $time);
3395                          assert property (@(posedge clkb)
3396                            !(enb &amp;&amp; |web &amp;&amp; injectsbiterrb))
3397                          else
3398                            $warning(&quot;XPM_MEMORY_ILLEGAL_ERR_INJ_ASSRT: Attempt to inject single bit error into the memory through Port-B at address 0x%0h at time %0t in Decode only mode configuration ; Error injection is not allowed in Decode only mode.&quot;, addrb, $time);
3399                    
3400                          assert property (@(posedge clkb)
3401                            !(enb &amp;&amp; |web &amp;&amp; injectdbiterrb))
3402                          else
3403                            $warning(&quot;XPM_MEMORY_ILLEGAL_ERR_INJ_ASSRT: Attempt to inject double bit error into the memory through Port-B at address 0x%0h at time %0t in Decode only mode configuration ; Error injection is not allowed in Decode only mode.&quot;, addrb, $time);
3404                    
3405                        end : illegal_injerr_dec_only
3406                    
3407                      end : gen_assert_illegal_mem_access_w
3408                    
3409                      if ((`MEM_TYPE_RAM_TDP || `MEM_TYPE_RAM_SDP) &amp;&amp; !(`MEM_PRIM_DISTRIBUTED || `MEM_PRIM_ULTRA)) begin : gen_assert_coll_ww
3410                    
3411                        // When port A and port B use independent clocks, capture write transactions to detect collisions
3412                        reg wra = 1'b0;
3413                        reg wrb = 1'b0;
3414                        reg rda_cap = 1'b0;
3415                        reg rdb_cap = 1'b0;
3416                        reg [(WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A)-1:0] wea_cap = 'b0;
3417                        reg [(WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B)-1:0] web_cap = 'b0;
3418                        reg [P_WIDTH_ADDR_WRITE_A-1:0] addra_cap = 'b0;
3419                        reg [P_WIDTH_ADDR_WRITE_A-1:0] addra_rd_cap = 'b0;
3420                        reg [P_WIDTH_ADDR_WRITE_B-1:0] addrb_cap = 'b0;
3421                        reg [P_WIDTH_ADDR_WRITE_B-1:0] addrb_rd_cap = 'b0;
3422                    
3423                        /**************************************************************************************************
3424                        | Collision Minimum and Maximum window requirements                                               |
3425                        |   Minimum window requirement = 50 ps                                                            |
3426                        |   Maximum window requirement --&gt;                                                                |
3427                        |     If the clock period is &gt;= 3000 ps, then the window is 3000 ps                               |
3428                        |     If the clock period is &gt;50 ps  &lt; 3000 ps, then the window is &quot;Clock period&quot; ps              |
3429                        **************************************************************************************************/
3430                        integer t_half_period_a = 3000;
3431                        integer t_half_period_b = 3000;
3432                        reg clk_prd_det_a = 0;
3433                        reg clk_prd_det_b = 0;
3434                        // Determine the clock periods
3435                       initial begin
3436       2/2                  @(posedge clka);
3437       1/1                    t_half_period_a = $time/1.0;
3438       2/2                  @ (negedge clka) t_half_period_a = $time/1.0 - t_half_period_a;
3439       1/1                  clk_prd_det_a &lt;= 1;
3440                       end
3441                       initial begin
3442       2/2                  @(posedge clkb);
3443       1/1                    t_half_period_b = $time/1.0;
3444       2/2                  @ (negedge clkb) t_half_period_b = $time/1.0 - t_half_period_b;
3445       1/1                  clk_prd_det_b &lt;= 1;
3446                       end
3447                    
3448                       integer col_win_max = 0;
3449                       
3450                        always @(clka or clkb) begin
3451       1/1                if(~(clk_prd_det_a &amp;&amp; clk_prd_det_b)) begin
3452       1/1                  if(t_half_period_a &gt; 1500 &amp;&amp; t_half_period_b &gt; 1500)
3453       1/1                    col_win_max = 3000;
3454       1/1                  else if(t_half_period_a &lt;= 1500 &amp;&amp; t_half_period_a &lt;= t_half_period_b)
3455       1/1                    col_win_max = 2 * t_half_period_a;
3456       <font color = "red">0/1     ==>          else if(t_half_period_b &lt;= 1500 &amp;&amp; t_half_period_b &lt;= t_half_period_a)</font>
3457       <font color = "red">0/1     ==>            col_win_max = 2 * t_half_period_b;</font>
3458                            else
3459       <font color = "red">0/1     ==>            col_win_max = 500;</font>
3460                          end
                        MISSING_ELSE
3461                        end
3462                    
3463                        reg col_win_wr_a = 'b0;
3464                        reg col_win_rd_a = 'b0;
3465                    
3466                        always @(posedge clka) begin
3467       1/1                if(ena) begin
3468       1/1                  if(|wea) begin
3469       <font color = "red">0/1     ==>            col_win_wr_a &lt;= 1'b1;</font>
3470       <font color = "red">0/1     ==>            col_win_wr_a &lt;= #(col_win_max) 1'b0;</font>
3471                            end
                        MISSING_ELSE
3472                          end
                        MISSING_ELSE
3473                        end
3474                        
3475                        always @(posedge clka) begin
3476       1/1                if(ena) begin
3477       1/1                  if(~(|wea)) begin
3478       1/1                    col_win_rd_a &lt;= 1'b1;
3479       1/1                    col_win_rd_a &lt;= #(col_win_max) 1'b0;
3480                            end
                   <font color = "red">==>  MISSING_ELSE</font>
3481                          end
                        MISSING_ELSE
3482                        end
3483                    
3484                        reg col_win_wr_b = 'b0;
3485                        reg col_win_rd_b = 'b0;
3486                    
3487                        always @(posedge clkb) begin
3488       1/1                if(enb) begin
3489       1/1                  if(|web) begin
3490       <font color = "red">0/1     ==>            col_win_wr_b &lt;= 1'b1;</font>
3491       <font color = "red">0/1     ==>            col_win_wr_b &lt;= #(col_win_max) 1'b0;</font>
3492                            end
                        MISSING_ELSE
3493                          end
                        MISSING_ELSE
3494                        end
3495                        
3496                        always @(posedge clkb) begin
3497       1/1                if(enb) begin
3498       1/1                  if(~(|web)) begin
3499       1/1                    col_win_rd_b &lt;= 1'b1;
3500       1/1                    col_win_rd_b &lt;= #(col_win_max) 1'b0;
3501                            end
                   <font color = "red">==>  MISSING_ELSE</font>
3502                          end
                        MISSING_ELSE
3503                        end
3504                    
3505                        if (`INDEPENDENT_CLOCKS) begin : gen_wr_cap
3506                        
3507                          // Capture port A write transactions for one port A clock cycle, for purposes of detecting a collision at clock B
3508                          always @(posedge clka) begin
3509                            if (ena &amp;&amp; |wea) begin
3510                              wra       &lt;= 1'b1;
3511                              wea_cap   &lt;= wea;
3512                              addra_cap &lt;= addra_i;
3513                            end
3514                            else
3515                              wra &lt;= 1'b0;
3516                          end
3517                          
3518                          // Capture port A read transactions for one port A clock cycle, for purposes of detecting a collision at clock B
3519                          always @(posedge clka) begin
3520                            rda_cap   &lt;= (ena &amp;&amp; ~(|wea));
3521                            if(ena &amp;&amp; ~(|wea))
3522                              addra_rd_cap &lt;= addra_i;          
3523                          end
3524                    
3525                          // Capture port B write transactions for one port B clock cycle, for purposes of detecting a collision at clock A
3526                          always @(posedge clkb) begin
3527                            if (enb &amp;&amp; |web) begin
3528                              wrb       &lt;= 1'b1;
3529                              web_cap   &lt;= web;
3530                              addrb_cap &lt;= addrb_i;
3531                            end
3532                            else
3533                              wrb &lt;= 1'b0;
3534                          end
3535                    
3536                          // Capture port B read transactions for one port B clock cycle, for purposes of detecting a collision at clock A
3537                          always @(posedge clkb) begin
3538                            rdb_cap   &lt;= (enb &amp;&amp; ~(|web));
3539                            if(enb &amp;&amp; ~(|web))
3540                              addrb_rd_cap &lt;= addrb_i;
3541                          end
3542                    
3543                        end : gen_wr_cap
3544                    
3545                        if(`REPORT_MESSAGES) begin : gen_coll_msgs
3546                         // Port A and port B write data widths are symmetric
3547                         if (WRITE_DATA_WIDTH_A == WRITE_DATA_WIDTH_B) begin : gen_wdw_sym
3548                    
3549                          // Port A and port B write enable widths are symmetric
3550                          if (BYTE_WRITE_WIDTH_A == BYTE_WRITE_WIDTH_B) begin : gen_we_sym
3551                    
3552                            // Port A and port B use a common clock
3553                            if (`COMMON_CLOCK) begin : gen_clock
3554                              assert property (@(posedge clka)
3555                                ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; |(wea &amp; web)))
3556                              else
3557                                $warning(&quot;COLLISION: potential write-write collision to memory at time %0t (address location --&gt; %0d); data outputs and memory content may be corrupted.&quot;, $time,addra);
3558                              if (!`IS_COLLISION_SAFE) begin : col_unsafe
3559                                assert property (@(posedge clka)
3560                                  ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; (|wea &amp;&amp; ~(|web))))
3561                                else
3562                                  $warning(&quot;COLLISION: potential write-read collision to memory at time %0t; data outputs and memory content may be corrupted (Write happened through --&gt; Port-A, Read happened through --&gt; Port-B at address location %0d).&quot;, $time,addra);
3563                    
3564                                assert property (@(posedge clka)
3565                                  ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; (~(|wea) &amp;&amp; |web )))
3566                                else
3567                                  $warning(&quot;COLLISION: potential write-read collision to memory at time %0t; data outputs and memory content may be corrupted (Write happened through --&gt; Port-B, Read happened through --&gt; Port-A at address location %0d).&quot;, $time,addrb);
3568                              end : col_unsafe
3569                    
3570                            end : gen_clock
3571                    
3572                            // Port A and port B use independent clocks
3573                            else if (`INDEPENDENT_CLOCKS) begin : gen_clocks
3574                    
3575                              assert property (@(posedge clkb)
3576                                enb &amp;&amp; |web &amp;&amp; $rose(wra) |-&gt; !((addrb == addra_cap) &amp;&amp; |(web &amp; wea_cap)))
3577                              else
3578                                $warning(&quot;COLLISION: potential write-write collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3579                              assert property (@(posedge clka)
3580                                ena &amp;&amp; |wea &amp;&amp; $rose(wrb) |-&gt; !((addra == addrb_cap) &amp;&amp; |(wea &amp; web_cap)))
3581                              else
3582                                $warning(&quot;COLLISION: potential write-write collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3583                    
3584                              if (!`IS_COLLISION_SAFE) begin : col_unsafe
3585                              assert property (@(posedge clkb)
3586                                enb &amp;&amp; |web &amp;&amp; $rose(rda_cap) |-&gt; !((addrb == addra_rd_cap) &amp;&amp; (~(|wea_cap) &amp;&amp; |web)))
3587                              else
3588                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3589                              assert property (@(posedge clkb)
3590                                enb &amp;&amp; ~(|web) &amp;&amp; $rose(wra) |-&gt; !((addrb == addra_cap) &amp;&amp; (|wea_cap &amp;&amp; ~(|web))))
3591                              else
3592                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3593                    
3594                              assert property (@(posedge clka)
3595                                ena &amp;&amp; |wea &amp;&amp; $rose(rdb_cap) |-&gt; !((addra == addrb_rd_cap) &amp;&amp; (|wea &amp;&amp; ~(|web_cap))))
3596                              else
3597                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3598                              assert property (@(posedge clka)
3599                                ena &amp;&amp; ~(|wea) &amp;&amp; $rose(wra) |-&gt; !((addra == addrb_cap) &amp;&amp; (~(|wea) &amp;&amp; (|web_cap))))
3600                              else
3601                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3602                              end : col_unsafe
3603                    
3604                            end : gen_clocks
3605                          end : gen_we_sym
3606                    
3607                          // Port A write enable is wider than port B write enable
3608                          else if (WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A &gt; 1) begin : gen_we_wide_a
3609                    
3610                            // Port A and port B use a common clock
3611                            if (`COMMON_CLOCK) begin : gen_clock
3612                              assert property (@(posedge clka)
3613                                ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; |(wea &amp; {(WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A){web}})))
3614                              else
3615                                $warning(&quot;COLLISION: potential write-write collision to memory at time %0t (address location --&gt; %0d); data outputs and memory content may be corrupted.&quot;, $time,addra);
3616                              
3617                              if (!`IS_COLLISION_SAFE) begin : col_unsafe
3618                              assert property (@(posedge clka)
3619                                ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; (|wea &amp;&amp; ~(|web))))
3620                              else
3621                                $warning(&quot;COLLISION: potential write-read collision to memory at time %0t; data outputs and memory content may be corrupted (Write happened through --&gt; Port-A, Read happened through --&gt; Port-B at address location %0d).&quot;, $time,addra);
3622                    
3623                              assert property (@(posedge clka)
3624                                ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; (~(|wea) &amp;&amp; |web )))
3625                              else
3626                                $warning(&quot;COLLISION: potential write-read collision to memory at time %0t; data outputs and memory content may be corrupted (Write happened through --&gt; Port-B, Read happened through --&gt; Port-A at address location %0d).&quot;, $time,addrb);
3627                              end : col_unsafe
3628                    
3629                            end : gen_clock
3630                    
3631                            // Port A and port B use independent clocks
3632                            else if (`INDEPENDENT_CLOCKS) begin : gen_clocks
3633                              assert property (@(posedge clkb)
3634                                enb &amp;&amp; web &amp;&amp; $rose(wra) |-&gt; !((addrb == addra_cap) &amp;&amp; |({(WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A){web}} &amp; wea_cap)))
3635                              else
3636                                $warning(&quot;COLLISION: potential write-write collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3637                              assert property (@(posedge clka)
3638                                ena &amp;&amp; |wea &amp;&amp; $rose(wrb) |-&gt; !((addra == addrb_cap) &amp;&amp; |(wea &amp; {(WRITE_DATA_WIDTH_A/BYTE_WRITE_WIDTH_A){web_cap}})))
3639                              else
3640                                $warning(&quot;COLLISION: potential write-write collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3641                            
3642                              if (!`IS_COLLISION_SAFE) begin : col_unsafe
3643                              assert property (@(posedge clkb)
3644                                enb &amp;&amp; |web &amp;&amp; $rose(rda_cap) |-&gt; !((addrb == addra_rd_cap) &amp;&amp; (~(|wea_cap) &amp;&amp; |web)))
3645                              else
3646                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3647                              assert property (@(posedge clkb)
3648                                enb &amp;&amp; ~(|web) &amp;&amp; $rose(wra) |-&gt; !((addrb == addra_cap) &amp;&amp; (|wea_cap &amp;&amp; ~(|web))))
3649                              else
3650                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3651                    
3652                              assert property (@(posedge clka)
3653                                ena &amp;&amp; |wea &amp;&amp; $rose(rdb_cap) |-&gt; !((addra == addrb_rd_cap) &amp;&amp; (|wea &amp;&amp; ~(|web_cap))))
3654                              else
3655                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3656                              assert property (@(posedge clka)
3657                                ena &amp;&amp; ~(|wea) &amp;&amp; $rose(wra) |-&gt; !((addra == addrb_cap) &amp;&amp; (~(|wea) &amp;&amp; (|web_cap))))
3658                              else
3659                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3660                              end : col_unsafe
3661                    
3662                            end : gen_clocks
3663                          end : gen_we_wide_a
3664                    
3665                          // Port B write enable is wider than port A write enable
3666                          else if (WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B &gt; 1) begin : gen_we_wide_b
3667                    
3668                            // Port A and port B use a common clock
3669                            if (`COMMON_CLOCK) begin : gen_clock
3670                              assert property (@(posedge clka)
3671                                ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; |({(WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B){wea}} &amp; web)))
3672                              else
3673                                $warning(&quot;COLLISION: potential write-write collision to memory at time %0t (address location --&gt; %0d); data outputs and memory content may be corrupted.&quot;, $time,addra);
3674                        
3675                              if (!`IS_COLLISION_SAFE) begin : col_unsafe
3676                              assert property (@(posedge clka)
3677                                ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; (|wea &amp;&amp; ~(|web))))
3678                              else
3679                                $warning(&quot;COLLISION: potential write-read collision to memory at time %0t; data outputs and memory content may be corrupted (Write happened through --&gt; Port-A, Read happened through --&gt; Port-B at address location %0d).&quot;, $time,addra);
3680                    
3681                              assert property (@(posedge clka)
3682                                ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; (~(|wea) &amp;&amp; |web )))
3683                              else
3684                                $warning(&quot;COLLISION: potential write-read collision to memory at time %0t; data outputs and memory content may be corrupted (Write happened through --&gt; Port-B, Read happened through --&gt; Port-A at address location %0d).&quot;, $time,addrb);
3685                              end : col_unsafe
3686                            end : gen_clock
3687                    
3688                            // Port A and port B use independent clocks
3689                            else if (`INDEPENDENT_CLOCKS) begin : gen_clocks
3690                              assert property (@(posedge clkb)
3691                                enb &amp;&amp; |web &amp;&amp; $rose(wra) |-&gt; !((addrb == addra_cap) &amp;&amp; |(web &amp; {(WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B){wea_cap}})))
3692                              else
3693                                $warning(&quot;COLLISION: potential write-write collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3694                              assert property (@(posedge clka)
3695                                ena &amp;&amp; |wea &amp;&amp; $rose(wrb) |-&gt; !((addra == addrb_cap) &amp;&amp; |({(WRITE_DATA_WIDTH_B/BYTE_WRITE_WIDTH_B){wea}} &amp; web_cap)))
3696                              else
3697                                $warning(&quot;COLLISION: potential write-write collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3698                     
3699                              if (!`IS_COLLISION_SAFE) begin : col_unsafe
3700                                assert property (@(posedge clkb)
3701                                  enb &amp;&amp; |web &amp;&amp; $rose(rda_cap) |-&gt; !((addrb == addra_rd_cap) &amp;&amp; (~(|wea_cap) &amp;&amp; |web)))
3702                                else
3703                                  $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3704                                assert property (@(posedge clkb)
3705                                  enb &amp;&amp; ~(|web) &amp;&amp; $rose(wra) |-&gt; !((addrb == addra_cap) &amp;&amp; (|wea_cap &amp;&amp; ~(|web))))
3706                                else
3707                                  $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3708                    
3709                                assert property (@(posedge clka)
3710                                  ena &amp;&amp; |wea &amp;&amp; $rose(rdb_cap) |-&gt; !((addra == addrb_rd_cap) &amp;&amp; (|wea &amp;&amp; ~(|web_cap))))
3711                                else
3712                                  $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3713                                assert property (@(posedge clka)
3714                                  ena &amp;&amp; ~(|wea) &amp;&amp; $rose(wra) |-&gt; !((addra == addrb_cap) &amp;&amp; (~(|wea) &amp;&amp; (|web_cap))))
3715                                else
3716                                  $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3717                              end : col_unsafe
3718                    
3719                            end : gen_clocks
3720                          end : gen_we_wide_b
3721                        end : gen_wdw_sym
3722                    
3723                        // Port A write data is wider than port B write data
3724                        else if (WRITE_DATA_WIDTH_A &gt; WRITE_DATA_WIDTH_B) begin : gen_wdw_wide_a
3725                    
3726                          // Port A and port B use a common clock
3727                          if (`COMMON_CLOCK) begin : gen_clock
3728                            assert property (@(posedge clka)
3729                              ena &amp;&amp; enb |-&gt; !((addra == addrb &gt;&gt; P_WIDTH_ADDR_WRITE_B-P_WIDTH_ADDR_WRITE_A) &amp;&amp; |(wea &amp; web)))
3730                            else
3731                              $warning(&quot;COLLISION: potential write-write collision to memory at time %0t (address location --&gt; %0d); data outputs and memory content may be corrupted.&quot;, $time,addra);
3732                    
3733                            if (!`IS_COLLISION_SAFE) begin : col_unsafe
3734                              assert property (@(posedge clka)
3735                                  ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; (|wea &amp;&amp; ~(|web))))
3736                              else
3737                                $warning(&quot;COLLISION: potential write-read collision to memory at time %0t; data outputs and memory content may be corrupted (Write happened through --&gt; Port-A, Read happened through --&gt; Port-B at address location %0d).&quot;, $time,addra);
3738                              assert property (@(posedge clka)
3739                                ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; (~(|wea) &amp;&amp; |web )))
3740                              else
3741                                $warning(&quot;COLLISION: potential write-read collision to memory at time %0t; data outputs and memory content may be corrupted (Write happened through --&gt; Port-B, Read happened through --&gt; Port-A at address location %0d).&quot;, $time,addrb);
3742                    
3743                            end : col_unsafe
3744                           end : gen_clock
3745                    
3746                          // Port A and port B use independent clocks
3747                          else if (`INDEPENDENT_CLOCKS) begin : gen_clocks
3748                            assert property (@(posedge clkb)
3749                              enb &amp;&amp; |web &amp;&amp; $rose(wra) |-&gt; !((addra_cap == addrb &gt;&gt; P_WIDTH_ADDR_WRITE_B-P_WIDTH_ADDR_WRITE_A) &amp;&amp; |(web &amp; wea_cap)))
3750                            else
3751                              $warning(&quot;COLLISION: potential write-write collision to memory at port A address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3752                            assert property (@(posedge clka)
3753                              ena &amp;&amp; |wea &amp;&amp; $rose(wrb) |-&gt; !((addra == addrb_cap &gt;&gt; P_WIDTH_ADDR_WRITE_B-P_WIDTH_ADDR_WRITE_A) &amp;&amp; |(wea &amp; web_cap)))
3754                            else
3755                              $warning(&quot;COLLISION: potential write-write collision to memory at port B address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3756                    
3757                            if (!`IS_COLLISION_SAFE) begin : col_unsafe
3758                              assert property (@(posedge clkb)
3759                                enb &amp;&amp; |web &amp;&amp; $rose(rda_cap) |-&gt; !((addra_rd_cap == addrb &gt;&gt; P_WIDTH_ADDR_WRITE_B-P_WIDTH_ADDR_WRITE_A) &amp;&amp; (~(|wea_cap) &amp;&amp; |web)))
3760                              else
3761                                $warning(&quot;COLLISION: potential write-read collision to memory at port A address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3762                              assert property (@(posedge clka)
3763                                ena &amp;&amp; |wea &amp;&amp; $rose(rdb_cap) |-&gt; !((addra == addrb_rd_cap &gt;&gt; P_WIDTH_ADDR_WRITE_B-P_WIDTH_ADDR_WRITE_A) &amp;&amp; (|wea &amp;&amp; ~(|web_cap))))
3764                              else
3765                                $warning(&quot;COLLISION: potential write-read collision to memory at port B address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3766                    
3767                              assert property (@(posedge clkb)
3768                                enb &amp;&amp; ~(|web) &amp;&amp; $rose(wra) |-&gt; !((addrb &gt;&gt; P_WIDTH_ADDR_WRITE_B-P_WIDTH_ADDR_WRITE_A == addra_cap) &amp;&amp; (|wea_cap &amp;&amp; ~(|web))))
3769                              else
3770                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3771                    
3772                              assert property (@(posedge clka)
3773                                ena &amp;&amp; ~(|wea) &amp;&amp; $rose(wra) |-&gt; !((addra == addrb_cap &gt;&gt; P_WIDTH_ADDR_WRITE_B-P_WIDTH_ADDR_WRITE_A) &amp;&amp; (~(|wea) &amp;&amp; (|web_cap))))
3774                              else
3775                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3776                            end : col_unsafe
3777                    
3778                          end : gen_clocks
3779                        end : gen_wdw_wide_a
3780                    
3781                        // Port B write data is wider than port A write data
3782                        else if (WRITE_DATA_WIDTH_B &gt; WRITE_DATA_WIDTH_A) begin : gen_wdw_wide_b
3783                    
3784                          // Port A and port B use a common clock
3785                          if (`COMMON_CLOCK) begin : gen_clock
3786                            assert property (@(posedge clka)
3787                              ena &amp;&amp; enb |-&gt; !((addrb == addra &gt;&gt; P_WIDTH_ADDR_WRITE_A-P_WIDTH_ADDR_WRITE_B) &amp;&amp; |(wea &amp; web)))
3788                            else
3789                              $warning(&quot;COLLISION: potential write-write collision to memory at time %0t (address location --&gt; %0d); data outputs and memory content may be corrupted.&quot;, $time,addra);
3790                    
3791                            if (!`IS_COLLISION_SAFE) begin : col_unsafe
3792                              assert property (@(posedge clka)
3793                                  ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; (|wea &amp;&amp; ~(|web))))
3794                              else
3795                                $warning(&quot;COLLISION: potential write-read collision to memory at time %0t; data outputs and memory content may be corrupted (Write happened through --&gt; Port-A, Read happened through --&gt; Port-B at address location %0d).&quot;, $time,addra);
3796                    
3797                              assert property (@(posedge clka)
3798                                ena &amp;&amp; enb |-&gt; !((addra == addrb) &amp;&amp; (~(|wea) &amp;&amp; |web )))
3799                              else
3800                                $warning(&quot;COLLISION: potential write-read collision to memory at time %0t; data outputs and memory content may be corrupted (Write happened through --&gt; Port-B, Read happened through --&gt; Port-A at address location %0d).&quot;, $time,addrb);
3801                            end : col_unsafe
3802                    
3803                           end : gen_clock
3804                    
3805                          // Port A and port B use independent clocks
3806                          else if (`INDEPENDENT_CLOCKS) begin : gen_clocks
3807                            assert property (@(posedge clkb)
3808                              enb &amp;&amp; |web &amp;&amp; $rose(wra) |-&gt; !((addrb == addra_cap &gt;&gt; P_WIDTH_ADDR_WRITE_A-P_WIDTH_ADDR_WRITE_B) &amp;&amp; |(web &amp; wea_cap)))
3809                            else
3810                              $warning(&quot;COLLISION: potential write-write collision to memory at port A address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3811                            assert property (@(posedge clka)
3812                              ena &amp;&amp; |wea &amp;&amp; $rose(wrb) |-&gt; !((addrb_cap == addra &gt;&gt; P_WIDTH_ADDR_WRITE_A-P_WIDTH_ADDR_WRITE_B) &amp;&amp; |(wea &amp; web_cap)))
3813                            else
3814                              $warning(&quot;COLLISION: potential write-write collision to memory at port B address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3815                    
3816                            if (!`IS_COLLISION_SAFE) begin : col_unsafe
3817                              assert property (@(posedge clkb)
3818                                enb &amp;&amp; |web &amp;&amp; $rose(rda_cap) |-&gt; !((addrb == addra_rd_cap &gt;&gt; P_WIDTH_ADDR_WRITE_A-P_WIDTH_ADDR_WRITE_B) &amp;&amp; (~(|wea_cap) &amp;&amp; |web)))
3819                              else
3820                                $warning(&quot;COLLISION: potential write-read collision to memory at port A address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3821                              assert property (@(posedge clka)
3822                                ena &amp;&amp; |wea &amp;&amp; $rose(rdb_cap) |-&gt; !((addrb_rd_cap == addra &gt;&gt; P_WIDTH_ADDR_WRITE_A-P_WIDTH_ADDR_WRITE_B) &amp;&amp; (|wea &amp;&amp; ~(|web_cap))))
3823                              else
3824                                $warning(&quot;COLLISION: potential write-read collision to memory at port B address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3825                    
3826                              assert property (@(posedge clkb)
3827                                enb &amp;&amp; ~(|web) &amp;&amp; $rose(wra) |-&gt; !((addrb == addra_cap &gt;&gt; P_WIDTH_ADDR_WRITE_A-P_WIDTH_ADDR_WRITE_B) &amp;&amp; (|wea_cap &amp;&amp; ~(|web))))
3828                              else
3829                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addra_cap, $time);
3830                    
3831                              assert property (@(posedge clka)
3832                                ena &amp;&amp; ~(|wea) &amp;&amp; $rose(wra) |-&gt; !((addra &gt;&gt; P_WIDTH_ADDR_WRITE_A-P_WIDTH_ADDR_WRITE_B == addrb_cap) &amp;&amp; (~(|wea) &amp;&amp; (|web_cap))))
3833                              else
3834                                $warning(&quot;COLLISION: potential write-read collision to memory at address 0x%0h at time %0t; data outputs and memory content may be corrupted.&quot;, addrb_cap, $time);
3835                            end : col_unsafe
3836                    
3837                          end : gen_clocks
3838                        end : gen_wdw_wide_b
3839                      end : gen_coll_msgs
3840                    
3841                    ////////////////////////////////////////////////////////////////////////////////////////////
3842                    // code is for Common clock and symmetric case
3843                    ////////////////////////////////////////////////////////////////////////////////////////////
3844                     if (`COMMON_CLOCK &amp;&amp; (((WRITE_DATA_WIDTH_A == WRITE_DATA_WIDTH_B) &amp;&amp; (WRITE_DATA_WIDTH_A == READ_DATA_WIDTH_B) &amp;&amp; (READ_DATA_WIDTH_A == WRITE_DATA_WIDTH_B) &amp;&amp; `NO_ECC) || !`NO_ECC)) begin : sync_clk_sym 
3845                     reg wr_wr_col = 0;
3846                       always @(ena or enb or addra_i or addrb_i or wea or web or dina_i or dinb_i) begin
3847       1/1               if ((ena == 1'b1 &amp;&amp; enb == 1'b1)) begin
3848       1/1                 if (addra_i == addrb_i) begin
3849       1/1                   if(|wea &amp;&amp; |web) begin
3850       <font color = "red">0/1     ==>             force dina_i  = {WRITE_DATA_WIDTH_A{1'bX}};</font>
3851       <font color = "red">0/1     ==>             force dinb_i  = {WRITE_DATA_WIDTH_B{1'bX}};</font>
3852       <font color = "red">0/1     ==>             wr_wr_col     &lt;= 1'b1;</font>
3853                             end
3854                             else begin
3855       1/1                    release dina_i;
3856       1/1                    release dinb_i;
3857       1/1                    wr_wr_col     &lt;= 1'b0;
3858                             end
3859                           end
3860                           else begin
3861       1/1                   release dina_i;
3862       1/1                   release dinb_i;
3863       1/1                   wr_wr_col     &lt;= 1'b0;
3864                           end
3865                         end
3866                         else begin
3867       1/1                 release dina_i;
3868       1/1                 release dinb_i;
3869       1/1                 wr_wr_col     &lt;= 1'b0;
3870                         end
3871                       end
3872                    
3873                       if (`MEM_PORTB_READ &amp;&amp; !(`IS_COLLISION_SAFE)) begin : gen_rd_b_coll
3874                         always @(posedge clka) begin
3875       1/1                 if (enb == 1'b1) begin
3876       1/1                   if (ena == 1'b1 &amp;&amp; (addra_i == addrb_i)) begin
3877       1/1                     if((|wea &amp; ~(|web)) || wr_wr_col) begin
3878       <font color = "red">0/1     ==>               if(READ_LATENCY_B == 1) begin</font>
3879       <font color = "red">0/1     ==>                 force gen_rd_b.doutb_reg = {READ_DATA_WIDTH_B{1'bX}};</font>
3880                                 end
3881                                 else begin
3882       <font color = "red">0/2     ==>                 #1ps force gen_rd_b.doutb_reg = {READ_DATA_WIDTH_B{1'bX}};</font>
3883                                 end
3884                               end
3885                               else begin
3886       1/1                       release gen_rd_b.doutb_reg;
3887                               end
3888                             end
3889                             else begin
3890       1/1                     release gen_rd_b.doutb_reg;
3891                             end
3892                           end
                        MISSING_ELSE
3893                         end
3894                       end : gen_rd_b_coll
3895                    
3896                       if (`MEM_PORTA_READ &amp;&amp; !(`IS_COLLISION_SAFE)) begin : gen_rd_a_coll
3897                          always @(posedge clka) begin
3898       1/1                  if (ena == 1'b1) begin
3899       1/1                    if (enb == 1'b1 &amp;&amp; (addra_i == addrb_i)) begin
3900       1/1                      if((~(|wea) &amp; |web) || wr_wr_col)begin
3901       <font color = "red">0/1     ==>                if (READ_LATENCY_A == 1) begin</font>
3902       <font color = "red">0/1     ==>                  force gen_rd_a.douta_reg = {READ_DATA_WIDTH_A{1'bX}};</font>
3903                                  end
3904                                  else begin
3905       <font color = "red">0/2     ==>                  #1ps force gen_rd_a.douta_reg = {READ_DATA_WIDTH_A{1'bX}};</font>
3906                                  end
3907                                end
3908                                else begin
3909       1/1                        release gen_rd_a.douta_reg;
3910                                end
3911                              end
3912                              else begin
3913       1/1                      release gen_rd_a.douta_reg;
3914                              end
3915                            end
                        MISSING_ELSE
</pre>
</div>
<div class="ui-layout-south">
<table align=center><tr><td class="s0 cl">0%</td>
<td class="s1 cl">10%</td>
<td class="s2 cl">20%</td>
<td class="s3 cl">30%</td>
<td class="s4 cl">40%</td>
<td class="s5 cl">50%</td>
<td class="s6 cl">60%</td>
<td class="s7 cl">70%</td>
<td class="s8 cl">80%</td>
<td class="s9 cl">90%</td>
<td class="s10 cl">100%</td></tr></table></div>
</body>
</html>
